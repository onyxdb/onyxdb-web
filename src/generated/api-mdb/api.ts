/* tslint:disable */
/* eslint-disable */
/**
 * OpenAPI definition
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type {Configuration} from './configuration';
import type {AxiosInstance, AxiosPromise, RawAxiosRequestConfig} from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import {
    assertParamExists,
    createRequestFunction,
    DUMMY_BASE_URL,
    serializeDataIfNeeded,
    setApiKeyToObject,
    setBasicAuthToObject,
    setBearerAuthToObject,
    setOAuthToObject,
    setSearchParams,
    toPathString,
} from './common';
import type {RequestArgs} from './base';
// @ts-ignore
import {BASE_PATH, BaseAPI, COLLECTION_FORMATS, operationServerMap, RequiredError} from './base';

/**
 *
 * @export
 * @interface CreateMongoDatabaseRequest
 */
export interface CreateMongoDatabaseRequest {
    /**
     *
     * @type {string}
     * @memberof CreateMongoDatabaseRequest
     */
    name: string;
}

/**
 *
 * @export
 * @interface ListMongoDatabasesResponse
 */
export interface ListMongoDatabasesResponse {
    /**
     *
     * @type {Array<MongoDatabase>}
     * @memberof ListMongoDatabasesResponse
     */
    databases: Array<MongoDatabase>;
}

/**
 *
 * @export
 * @interface ListMongoUsersResponse
 */
export interface ListMongoUsersResponse {
    /**
     *
     * @type {Array<MongoUser>}
     * @memberof ListMongoUsersResponse
     */
    users: Array<MongoUser>;
}

/**
 *
 * @export
 * @interface MongoDatabase
 */
export interface MongoDatabase {
    /**
     *
     * @type {string}
     * @memberof MongoDatabase
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof MongoDatabase
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof MongoDatabase
     */
    clusterId: string;
    /**
     *
     * @type {string}
     * @memberof MongoDatabase
     */
    createdAt: string;
    /**
     *
     * @type {string}
     * @memberof MongoDatabase
     */
    createdBy: string;
    /**
     *
     * @type {boolean}
     * @memberof MongoDatabase
     */
    isDeleted: boolean;
    /**
     *
     * @type {string}
     * @memberof MongoDatabase
     */
    deletedAt: string;
    /**
     *
     * @type {string}
     * @memberof MongoDatabase
     */
    deletedBy: string;
}

/**
 *
 * @export
 * @interface MongoHost
 */
export interface MongoHost {
    /**
     *
     * @type {string}
     * @memberof MongoHost
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof MongoHost
     */
    clusterId: string;
    /**
     *
     * @type {string}
     * @memberof MongoHost
     */
    type: MongoHostTypeEnum;
    /**
     *
     * @type {string}
     * @memberof MongoHost
     */
    status: MongoHostStatusEnum;
    /**
     *
     * @type {string}
     * @memberof MongoHost
     */
    role: MongoHostRoleEnum;
}

export const MongoHostTypeEnum = {
    Unknown: 'unknown',
    Mongod: 'mongod',
} as const;

export type MongoHostTypeEnum = (typeof MongoHostTypeEnum)[keyof typeof MongoHostTypeEnum];
export const MongoHostStatusEnum = {
    Unknown: 'unknown',
    Alive: 'alive',
    Dead: 'dead',
} as const;

export type MongoHostStatusEnum = (typeof MongoHostStatusEnum)[keyof typeof MongoHostStatusEnum];
export const MongoHostRoleEnum = {
    Unknown: 'unknown',
    Primary: 'primary',
    Secondary: 'secondary',
} as const;

export type MongoHostRoleEnum = (typeof MongoHostRoleEnum)[keyof typeof MongoHostRoleEnum];

/**
 *
 * @export
 * @interface MongoListHostsResponse
 */
export interface MongoListHostsResponse {
    /**
     *
     * @type {Array<MongoHost>}
     * @memberof MongoListHostsResponse
     */
    hosts: Array<MongoHost>;
}

/**
 *
 * @export
 * @interface MongoPermission
 */
export interface MongoPermission {
    /**
     *
     * @type {string}
     * @memberof MongoPermission
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof MongoPermission
     */
    databaseId: string;
    /**
     *
     * @type {string}
     * @memberof MongoPermission
     */
    createdAt: string;
    /**
     *
     * @type {string}
     * @memberof MongoPermission
     */
    createdBy: string;
    /**
     *
     * @type {boolean}
     * @memberof MongoPermission
     */
    isDeleted: boolean;
    /**
     *
     * @type {string}
     * @memberof MongoPermission
     */
    deletedAt: string;
    /**
     *
     * @type {string}
     * @memberof MongoPermission
     */
    deletedBy: string;
    /**
     *
     * @type {Array<string>}
     * @memberof MongoPermission
     */
    roles: Array<string>;
}

/**
 *
 * @export
 * @interface MongoPermissionToCreate
 */
export interface MongoPermissionToCreate {
    /**
     *
     * @type {string}
     * @memberof MongoPermissionToCreate
     */
    databaseId: string;
    /**
     *
     * @type {Array<string>}
     * @memberof MongoPermissionToCreate
     */
    roles: Array<string>;
}

/**
 *
 * @export
 * @interface MongoUser
 */
export interface MongoUser {
    /**
     *
     * @type {string}
     * @memberof MongoUser
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof MongoUser
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof MongoUser
     */
    clusterId: string;
    /**
     *
     * @type {string}
     * @memberof MongoUser
     */
    createdAt: string;
    /**
     *
     * @type {string}
     * @memberof MongoUser
     */
    createdBy: string;
    /**
     *
     * @type {boolean}
     * @memberof MongoUser
     */
    isDeleted: boolean;
    /**
     *
     * @type {string}
     * @memberof MongoUser
     */
    deletedAt: string;
    /**
     *
     * @type {string}
     * @memberof MongoUser
     */
    deletedBy: string;
    /**
     *
     * @type {Array<MongoPermission>}
     * @memberof MongoUser
     */
    permissions: Array<MongoPermission>;
}

/**
 *
 * @export
 * @interface MongoUserToCreate
 */
export interface MongoUserToCreate {
    /**
     *
     * @type {string}
     * @memberof MongoUserToCreate
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof MongoUserToCreate
     */
    password: string;
    /**
     *
     * @type {Array<MongoPermissionToCreate>}
     * @memberof MongoUserToCreate
     */
    permissions: Array<MongoPermissionToCreate>;
}

/**
 *
 * @export
 * @interface UpdateMongoHostsRequest
 */
export interface UpdateMongoHostsRequest {
    /**
     *
     * @type {Array<MongoHost>}
     * @memberof UpdateMongoHostsRequest
     */
    hosts?: Array<MongoHost>;
}

/**
 *
 * @export
 * @interface V1ClusterResources
 */
export interface V1ClusterResources {
    /**
     *
     * @type {string}
     * @memberof V1ClusterResources
     */
    presetId: string;
    /**
     *
     * @type {string}
     * @memberof V1ClusterResources
     */
    storageClass: string;
    /**
     *
     * @type {number}
     * @memberof V1ClusterResources
     */
    storage: number;
}

/**
 *
 * @export
 * @interface V1ClusterStatusResponse
 */
export interface V1ClusterStatusResponse {
    /**
     *
     * @type {string}
     * @memberof V1ClusterStatusResponse
     */
    value: string;
    /**
     *
     * @type {string}
     * @memberof V1ClusterStatusResponse
     */
    message: string;
}

/**
 *
 * @export
 * @interface V1CreateMongoClusterRequest
 */
export interface V1CreateMongoClusterRequest {
    /**
     *
     * @type {string}
     * @memberof V1CreateMongoClusterRequest
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof V1CreateMongoClusterRequest
     */
    description: string;
    /**
     *
     * @type {string}
     * @memberof V1CreateMongoClusterRequest
     */
    projectId: string;
    /**
     *
     * @type {V1MongoConfig}
     * @memberof V1CreateMongoClusterRequest
     */
    config: V1MongoConfig;
}

/**
 *
 * @export
 * @interface V1CreateMongoClusterResponse
 */
export interface V1CreateMongoClusterResponse {
    /**
     *
     * @type {string}
     * @memberof V1CreateMongoClusterResponse
     */
    id: string;
}

/**
 *
 * @export
 * @interface V1CreateProjectRequest
 */
export interface V1CreateProjectRequest {
    /**
     *
     * @type {string}
     * @memberof V1CreateProjectRequest
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof V1CreateProjectRequest
     */
    description: string;
    /**
     *
     * @type {string}
     * @memberof V1CreateProjectRequest
     */
    productId: string;
}

/**
 *
 * @export
 * @interface V1CreateResourcePresetRequest
 */
export interface V1CreateResourcePresetRequest {
    /**
     *
     * @type {string}
     * @memberof V1CreateResourcePresetRequest
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof V1CreateResourcePresetRequest
     */
    type: V1CreateResourcePresetRequestTypeEnum;
    /**
     *
     * @type {number}
     * @memberof V1CreateResourcePresetRequest
     */
    vcpu: number;
    /**
     *
     * @type {number}
     * @memberof V1CreateResourcePresetRequest
     */
    ram: number;
}

export const V1CreateResourcePresetRequestTypeEnum = {
    CpuOptimized: 'cpu_optimized',
    Standard: 'standard',
    RamOptimized: 'ram_optimized',
} as const;

export type V1CreateResourcePresetRequestTypeEnum =
    (typeof V1CreateResourcePresetRequestTypeEnum)[keyof typeof V1CreateResourcePresetRequestTypeEnum];

/**
 *
 * @export
 * @interface V1CreateZoneRequest
 */
export interface V1CreateZoneRequest {
    /**
     *
     * @type {string}
     * @memberof V1CreateZoneRequest
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof V1CreateZoneRequest
     */
    description: string;
    /**
     *
     * @type {string}
     * @memberof V1CreateZoneRequest
     */
    selector: string;
}

/**
 *
 * @export
 * @interface V1DeleteMongoClusterResponse
 */
export interface V1DeleteMongoClusterResponse {
    /**
     *
     * @type {string}
     * @memberof V1DeleteMongoClusterResponse
     */
    operationId: string;
}

/**
 *
 * @export
 * @interface V1ListMongoClustersResponse
 */
export interface V1ListMongoClustersResponse {
    /**
     *
     * @type {Array<V1MongoClusterResponse>}
     * @memberof V1ListMongoClustersResponse
     */
    clusters: Array<V1MongoClusterResponse>;
}

/**
 *
 * @export
 * @interface V1ListProjectsResponse
 */
export interface V1ListProjectsResponse {
    /**
     *
     * @type {Array<V1ProjectResponse>}
     * @memberof V1ListProjectsResponse
     */
    projects: Array<V1ProjectResponse>;
}

/**
 *
 * @export
 * @interface V1ListResourcePresetsResponse
 */
export interface V1ListResourcePresetsResponse {
    /**
     *
     * @type {Array<V1ResourcePresetResponse>}
     * @memberof V1ListResourcePresetsResponse
     */
    resourcePresets: Array<V1ResourcePresetResponse>;
}

/**
 *
 * @export
 * @interface V1ListZonesResponse
 */
export interface V1ListZonesResponse {
    /**
     *
     * @type {Array<V1ZoneResponse>}
     * @memberof V1ListZonesResponse
     */
    zones: Array<V1ZoneResponse>;
}

/**
 *
 * @export
 * @interface V1MongoClusterResponse
 */
export interface V1MongoClusterResponse {
    /**
     *
     * @type {string}
     * @memberof V1MongoClusterResponse
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof V1MongoClusterResponse
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof V1MongoClusterResponse
     */
    description: string;
    /**
     *
     * @type {V1ClusterStatusResponse}
     * @memberof V1MongoClusterResponse
     */
    status: V1ClusterStatusResponse;
    /**
     *
     * @type {string}
     * @memberof V1MongoClusterResponse
     */
    projectId: string;
    /**
     *
     * @type {V1MongoConfig}
     * @memberof V1MongoClusterResponse
     */
    config: V1MongoConfig;
}

/**
 *
 * @export
 * @interface V1MongoConfig
 */
export interface V1MongoConfig {
    /**
     *
     * @type {V1ClusterResources}
     * @memberof V1MongoConfig
     */
    resources: V1ClusterResources;
    /**
     *
     * @type {number}
     * @memberof V1MongoConfig
     */
    replicas: number;
}

/**
 *
 * @export
 * @interface V1MongoUpdateClusterRequest
 */
export interface V1MongoUpdateClusterRequest {
    /**
     *
     * @type {string}
     * @memberof V1MongoUpdateClusterRequest
     */
    name: string;
    /**
     *
     * @type {V1MongoConfig}
     * @memberof V1MongoUpdateClusterRequest
     */
    config: V1MongoConfig;
}

/**
 *
 * @export
 * @interface V1ProjectResponse
 */
export interface V1ProjectResponse {
    /**
     *
     * @type {string}
     * @memberof V1ProjectResponse
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof V1ProjectResponse
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof V1ProjectResponse
     */
    description: string;
    /**
     *
     * @type {string}
     * @memberof V1ProjectResponse
     */
    productId: string;
    /**
     *
     * @type {boolean}
     * @memberof V1ProjectResponse
     */
    isArchived: boolean;
}

/**
 *
 * @export
 * @interface V1ResourcePresetResponse
 */
export interface V1ResourcePresetResponse {
    /**
     *
     * @type {string}
     * @memberof V1ResourcePresetResponse
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof V1ResourcePresetResponse
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof V1ResourcePresetResponse
     */
    type: V1ResourcePresetResponseTypeEnum;
    /**
     *
     * @type {number}
     * @memberof V1ResourcePresetResponse
     */
    vcpu: number;
    /**
     *
     * @type {number}
     * @memberof V1ResourcePresetResponse
     */
    ram: number;
}

export const V1ResourcePresetResponseTypeEnum = {
    CpuOptimized: 'cpu_optimized',
    Standard: 'standard',
    RamOptimized: 'ram_optimized',
} as const;

export type V1ResourcePresetResponseTypeEnum =
    (typeof V1ResourcePresetResponseTypeEnum)[keyof typeof V1ResourcePresetResponseTypeEnum];

/**
 *
 * @export
 * @interface V1ScheduledOperationResponse
 */
export interface V1ScheduledOperationResponse {
    /**
     *
     * @type {string}
     * @memberof V1ScheduledOperationResponse
     */
    id: string;
}

/**
 *
 * @export
 * @interface V1UpdateProjectRequest
 */
export interface V1UpdateProjectRequest {
    /**
     *
     * @type {string}
     * @memberof V1UpdateProjectRequest
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof V1UpdateProjectRequest
     */
    description: string;
}

/**
 *
 * @export
 * @interface V1UpdateResourcePresetRequest
 */
export interface V1UpdateResourcePresetRequest {
    /**
     *
     * @type {string}
     * @memberof V1UpdateResourcePresetRequest
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof V1UpdateResourcePresetRequest
     */
    type: V1UpdateResourcePresetRequestTypeEnum;
    /**
     *
     * @type {number}
     * @memberof V1UpdateResourcePresetRequest
     */
    vcpu: number;
    /**
     *
     * @type {number}
     * @memberof V1UpdateResourcePresetRequest
     */
    ram: number;
}

export const V1UpdateResourcePresetRequestTypeEnum = {
    CpuOptimized: 'cpu_optimized',
    Standard: 'standard',
    RamOptimized: 'ram_optimized',
} as const;

export type V1UpdateResourcePresetRequestTypeEnum =
    (typeof V1UpdateResourcePresetRequestTypeEnum)[keyof typeof V1UpdateResourcePresetRequestTypeEnum];

/**
 *
 * @export
 * @interface V1UpdateZoneRequest
 */
export interface V1UpdateZoneRequest {
    /**
     *
     * @type {string}
     * @memberof V1UpdateZoneRequest
     */
    description: string;
    /**
     *
     * @type {string}
     * @memberof V1UpdateZoneRequest
     */
    selector: string;
}

/**
 *
 * @export
 * @interface V1ZoneResponse
 */
export interface V1ZoneResponse {
    /**
     *
     * @type {string}
     * @memberof V1ZoneResponse
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof V1ZoneResponse
     */
    description: string;
    /**
     *
     * @type {string}
     * @memberof V1ZoneResponse
     */
    selector: string;
}

/**
 * V1ManagedMongoDbApi - axios parameter creator
 * @export
 */
export const V1ManagedMongoDbApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Create MongoDB cluster
         * @param {V1CreateMongoClusterRequest} v1CreateMongoClusterRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCluster: async (
            v1CreateMongoClusterRequest: V1CreateMongoClusterRequest,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'v1CreateMongoClusterRequest' is not null or undefined
            assertParamExists(
                'createCluster',
                'v1CreateMongoClusterRequest',
                v1CreateMongoClusterRequest,
            );
            const localVarPath = `/api/v1/managed-mongodb/clusters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = serializeDataIfNeeded(
                v1CreateMongoClusterRequest,
                localVarRequestOptions,
                configuration,
            );

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create MongoDB database
         * @param {string} clusterId
         * @param {CreateMongoDatabaseRequest} createMongoDatabaseRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDatabase: async (
            clusterId: string,
            createMongoDatabaseRequest: CreateMongoDatabaseRequest,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('createDatabase', 'clusterId', clusterId);
            // verify required parameter 'createMongoDatabaseRequest' is not null or undefined
            assertParamExists(
                'createDatabase',
                'createMongoDatabaseRequest',
                createMongoDatabaseRequest,
            );
            const localVarPath = `/api/managed-mongodb/v1/clusters/{clusterId}/databases`.replace(
                `{${'clusterId'}}`,
                encodeURIComponent(String(clusterId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = serializeDataIfNeeded(
                createMongoDatabaseRequest,
                localVarRequestOptions,
                configuration,
            );

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create MongoDB user
         * @param {string} clusterId
         * @param {MongoUserToCreate} mongoUserToCreate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: async (
            clusterId: string,
            mongoUserToCreate: MongoUserToCreate,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('createUser', 'clusterId', clusterId);
            // verify required parameter 'mongoUserToCreate' is not null or undefined
            assertParamExists('createUser', 'mongoUserToCreate', mongoUserToCreate);
            const localVarPath = `/api/managed-mongodb/v1/clusters/{clusterId}/users`.replace(
                `{${'clusterId'}}`,
                encodeURIComponent(String(clusterId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = serializeDataIfNeeded(
                mongoUserToCreate,
                localVarRequestOptions,
                configuration,
            );

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete MongoDB cluster
         * @param {string} clusterId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCluster: async (
            clusterId: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('deleteCluster', 'clusterId', clusterId);
            const localVarPath = `/api/v1/managed-mongodb/clusters/{clusterId}`.replace(
                `{${'clusterId'}}`,
                encodeURIComponent(String(clusterId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete MongoDB database
         * @param {string} clusterId
         * @param {string} databaseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDatabase: async (
            clusterId: string,
            databaseId: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('deleteDatabase', 'clusterId', clusterId);
            // verify required parameter 'databaseId' is not null or undefined
            assertParamExists('deleteDatabase', 'databaseId', databaseId);
            const localVarPath =
                `/api/managed-mongodb/v1/clusters/{clusterId}/databases/{databaseId}`
                    .replace(`{${'clusterId'}}`, encodeURIComponent(String(clusterId)))
                    .replace(`{${'databaseId'}}`, encodeURIComponent(String(databaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete MongoDB user
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (
            userId: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteUser', 'userId', userId);
            const localVarPath = `/api/managed-mongodb/v1/clusters/users/{userId}`.replace(
                `{${'userId'}}`,
                encodeURIComponent(String(userId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get MongoDB cluster
         * @param {string} clusterId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCluster: async (
            clusterId: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('getCluster', 'clusterId', clusterId);
            const localVarPath = `/api/v1/managed-mongodb/clusters/{clusterId}`.replace(
                `{${'clusterId'}}`,
                encodeURIComponent(String(clusterId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get MongoDB user
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (
            userId: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUser', 'userId', userId);
            const localVarPath = `/api/managed-mongodb/v1/clusters/users/{userId}`.replace(
                `{${'userId'}}`,
                encodeURIComponent(String(userId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get MongoDB clusters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listClusters: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/managed-mongodb/clusters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List MongoDB databases
         * @param {string} clusterId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabases: async (
            clusterId: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('listDatabases', 'clusterId', clusterId);
            const localVarPath = `/api/managed-mongodb/v1/clusters/{clusterId}/databases`.replace(
                `{${'clusterId'}}`,
                encodeURIComponent(String(clusterId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get MongoDB hosts
         * @param {string} clusterId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHosts: async (
            clusterId: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('listHosts', 'clusterId', clusterId);
            const localVarPath = `/api/managed-mongodb/v1/clusters/{clusterId}/hosts`.replace(
                `{${'clusterId'}}`,
                encodeURIComponent(String(clusterId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List MongoDB users
         * @param {string} clusterId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers: async (
            clusterId: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('listUsers', 'clusterId', clusterId);
            const localVarPath = `/api/managed-mongodb/v1/clusters/{clusterId}/users`.replace(
                `{${'clusterId'}}`,
                encodeURIComponent(String(clusterId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update MongoDB cluster
         * @param {string} clusterId
         * @param {V1MongoUpdateClusterRequest} v1MongoUpdateClusterRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCluster: async (
            clusterId: string,
            v1MongoUpdateClusterRequest: V1MongoUpdateClusterRequest,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('updateCluster', 'clusterId', clusterId);
            // verify required parameter 'v1MongoUpdateClusterRequest' is not null or undefined
            assertParamExists(
                'updateCluster',
                'v1MongoUpdateClusterRequest',
                v1MongoUpdateClusterRequest,
            );
            const localVarPath = `/api/v1/managed-mongodb/clusters/{clusterId}`.replace(
                `{${'clusterId'}}`,
                encodeURIComponent(String(clusterId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = serializeDataIfNeeded(
                v1MongoUpdateClusterRequest,
                localVarRequestOptions,
                configuration,
            );

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update MongoDB hosts
         * @param {UpdateMongoHostsRequest} updateMongoHostsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHosts: async (
            updateMongoHostsRequest: UpdateMongoHostsRequest,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'updateMongoHostsRequest' is not null or undefined
            assertParamExists('updateHosts', 'updateMongoHostsRequest', updateMongoHostsRequest);
            const localVarPath = `/api/internal/managed-mongodb/v1/clusters/hosts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = serializeDataIfNeeded(
                updateMongoHostsRequest,
                localVarRequestOptions,
                configuration,
            );

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * V1ManagedMongoDbApi - functional programming interface
 * @export
 */
export const V1ManagedMongoDbApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = V1ManagedMongoDbApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Create MongoDB cluster
         * @param {V1CreateMongoClusterRequest} v1CreateMongoClusterRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCluster(
            v1CreateMongoClusterRequest: V1CreateMongoClusterRequest,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1CreateMongoClusterResponse>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCluster(
                v1CreateMongoClusterRequest,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['V1ManagedMongoDbApi.createCluster']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Create MongoDB database
         * @param {string} clusterId
         * @param {CreateMongoDatabaseRequest} createMongoDatabaseRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDatabase(
            clusterId: string,
            createMongoDatabaseRequest: CreateMongoDatabaseRequest,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1ScheduledOperationResponse>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDatabase(
                clusterId,
                createMongoDatabaseRequest,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['V1ManagedMongoDbApi.createDatabase']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Create MongoDB user
         * @param {string} clusterId
         * @param {MongoUserToCreate} mongoUserToCreate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUser(
            clusterId: string,
            mongoUserToCreate: MongoUserToCreate,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1ScheduledOperationResponse>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(
                clusterId,
                mongoUserToCreate,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['V1ManagedMongoDbApi.createUser']?.[localVarOperationServerIndex]
                    ?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Delete MongoDB cluster
         * @param {string} clusterId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCluster(
            clusterId: string,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1DeleteMongoClusterResponse>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCluster(
                clusterId,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['V1ManagedMongoDbApi.deleteCluster']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Delete MongoDB database
         * @param {string} clusterId
         * @param {string} databaseId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDatabase(
            clusterId: string,
            databaseId: string,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1ScheduledOperationResponse>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDatabase(
                clusterId,
                databaseId,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['V1ManagedMongoDbApi.deleteDatabase']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Delete MongoDB user
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(
            userId: string,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1ScheduledOperationResponse>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['V1ManagedMongoDbApi.deleteUser']?.[localVarOperationServerIndex]
                    ?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get MongoDB cluster
         * @param {string} clusterId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCluster(
            clusterId: string,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1MongoClusterResponse>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCluster(
                clusterId,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['V1ManagedMongoDbApi.getCluster']?.[localVarOperationServerIndex]
                    ?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get MongoDB user
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(
            userId: string,
            options?: RawAxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MongoUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['V1ManagedMongoDbApi.getUser']?.[localVarOperationServerIndex]
                    ?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get MongoDB clusters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listClusters(
            options?: RawAxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1ListMongoClustersResponse>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listClusters(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['V1ManagedMongoDbApi.listClusters']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary List MongoDB databases
         * @param {string} clusterId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDatabases(
            clusterId: string,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListMongoDatabasesResponse>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDatabases(
                clusterId,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['V1ManagedMongoDbApi.listDatabases']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get MongoDB hosts
         * @param {string} clusterId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listHosts(
            clusterId: string,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<MongoListHostsResponse>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listHosts(clusterId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['V1ManagedMongoDbApi.listHosts']?.[localVarOperationServerIndex]
                    ?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary List MongoDB users
         * @param {string} clusterId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUsers(
            clusterId: string,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListMongoUsersResponse>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUsers(clusterId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['V1ManagedMongoDbApi.listUsers']?.[localVarOperationServerIndex]
                    ?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Update MongoDB cluster
         * @param {string} clusterId
         * @param {V1MongoUpdateClusterRequest} v1MongoUpdateClusterRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCluster(
            clusterId: string,
            v1MongoUpdateClusterRequest: V1MongoUpdateClusterRequest,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1ScheduledOperationResponse>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCluster(
                clusterId,
                v1MongoUpdateClusterRequest,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['V1ManagedMongoDbApi.updateCluster']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Update MongoDB hosts
         * @param {UpdateMongoHostsRequest} updateMongoHostsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateHosts(
            updateMongoHostsRequest: UpdateMongoHostsRequest,
            options?: RawAxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateHosts(
                updateMongoHostsRequest,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['V1ManagedMongoDbApi.updateHosts']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
    };
};

/**
 * V1ManagedMongoDbApi - factory interface
 * @export
 */
export const V1ManagedMongoDbApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = V1ManagedMongoDbApiFp(configuration);
    return {
        /**
         *
         * @summary Create MongoDB cluster
         * @param {V1ManagedMongoDbApiCreateClusterRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCluster(
            requestParameters: V1ManagedMongoDbApiCreateClusterRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<V1CreateMongoClusterResponse> {
            return localVarFp
                .createCluster(requestParameters.v1CreateMongoClusterRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Create MongoDB database
         * @param {V1ManagedMongoDbApiCreateDatabaseRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDatabase(
            requestParameters: V1ManagedMongoDbApiCreateDatabaseRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<V1ScheduledOperationResponse> {
            return localVarFp
                .createDatabase(
                    requestParameters.clusterId,
                    requestParameters.createMongoDatabaseRequest,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Create MongoDB user
         * @param {V1ManagedMongoDbApiCreateUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(
            requestParameters: V1ManagedMongoDbApiCreateUserRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<V1ScheduledOperationResponse> {
            return localVarFp
                .createUser(
                    requestParameters.clusterId,
                    requestParameters.mongoUserToCreate,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete MongoDB cluster
         * @param {V1ManagedMongoDbApiDeleteClusterRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCluster(
            requestParameters: V1ManagedMongoDbApiDeleteClusterRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<V1DeleteMongoClusterResponse> {
            return localVarFp
                .deleteCluster(requestParameters.clusterId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete MongoDB database
         * @param {V1ManagedMongoDbApiDeleteDatabaseRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDatabase(
            requestParameters: V1ManagedMongoDbApiDeleteDatabaseRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<V1ScheduledOperationResponse> {
            return localVarFp
                .deleteDatabase(requestParameters.clusterId, requestParameters.databaseId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete MongoDB user
         * @param {V1ManagedMongoDbApiDeleteUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(
            requestParameters: V1ManagedMongoDbApiDeleteUserRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<V1ScheduledOperationResponse> {
            return localVarFp
                .deleteUser(requestParameters.userId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get MongoDB cluster
         * @param {V1ManagedMongoDbApiGetClusterRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCluster(
            requestParameters: V1ManagedMongoDbApiGetClusterRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<V1MongoClusterResponse> {
            return localVarFp
                .getCluster(requestParameters.clusterId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get MongoDB user
         * @param {V1ManagedMongoDbApiGetUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(
            requestParameters: V1ManagedMongoDbApiGetUserRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<MongoUser> {
            return localVarFp
                .getUser(requestParameters.userId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get MongoDB clusters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listClusters(options?: RawAxiosRequestConfig): AxiosPromise<V1ListMongoClustersResponse> {
            return localVarFp.listClusters(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List MongoDB databases
         * @param {V1ManagedMongoDbApiListDatabasesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabases(
            requestParameters: V1ManagedMongoDbApiListDatabasesRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<ListMongoDatabasesResponse> {
            return localVarFp
                .listDatabases(requestParameters.clusterId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get MongoDB hosts
         * @param {V1ManagedMongoDbApiListHostsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHosts(
            requestParameters: V1ManagedMongoDbApiListHostsRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<MongoListHostsResponse> {
            return localVarFp
                .listHosts(requestParameters.clusterId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List MongoDB users
         * @param {V1ManagedMongoDbApiListUsersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers(
            requestParameters: V1ManagedMongoDbApiListUsersRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<ListMongoUsersResponse> {
            return localVarFp
                .listUsers(requestParameters.clusterId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update MongoDB cluster
         * @param {V1ManagedMongoDbApiUpdateClusterRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCluster(
            requestParameters: V1ManagedMongoDbApiUpdateClusterRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<V1ScheduledOperationResponse> {
            return localVarFp
                .updateCluster(
                    requestParameters.clusterId,
                    requestParameters.v1MongoUpdateClusterRequest,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update MongoDB hosts
         * @param {V1ManagedMongoDbApiUpdateHostsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHosts(
            requestParameters: V1ManagedMongoDbApiUpdateHostsRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .updateHosts(requestParameters.updateMongoHostsRequest, options)
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createCluster operation in V1ManagedMongoDbApi.
 * @export
 * @interface V1ManagedMongoDbApiCreateClusterRequest
 */
export interface V1ManagedMongoDbApiCreateClusterRequest {
    /**
     *
     * @type {V1CreateMongoClusterRequest}
     * @memberof V1ManagedMongoDbApiCreateCluster
     */
    readonly v1CreateMongoClusterRequest: V1CreateMongoClusterRequest;
}

/**
 * Request parameters for createDatabase operation in V1ManagedMongoDbApi.
 * @export
 * @interface V1ManagedMongoDbApiCreateDatabaseRequest
 */
export interface V1ManagedMongoDbApiCreateDatabaseRequest {
    /**
     *
     * @type {string}
     * @memberof V1ManagedMongoDbApiCreateDatabase
     */
    readonly clusterId: string;

    /**
     *
     * @type {CreateMongoDatabaseRequest}
     * @memberof V1ManagedMongoDbApiCreateDatabase
     */
    readonly createMongoDatabaseRequest: CreateMongoDatabaseRequest;
}

/**
 * Request parameters for createUser operation in V1ManagedMongoDbApi.
 * @export
 * @interface V1ManagedMongoDbApiCreateUserRequest
 */
export interface V1ManagedMongoDbApiCreateUserRequest {
    /**
     *
     * @type {string}
     * @memberof V1ManagedMongoDbApiCreateUser
     */
    readonly clusterId: string;

    /**
     *
     * @type {MongoUserToCreate}
     * @memberof V1ManagedMongoDbApiCreateUser
     */
    readonly mongoUserToCreate: MongoUserToCreate;
}

/**
 * Request parameters for deleteCluster operation in V1ManagedMongoDbApi.
 * @export
 * @interface V1ManagedMongoDbApiDeleteClusterRequest
 */
export interface V1ManagedMongoDbApiDeleteClusterRequest {
    /**
     *
     * @type {string}
     * @memberof V1ManagedMongoDbApiDeleteCluster
     */
    readonly clusterId: string;
}

/**
 * Request parameters for deleteDatabase operation in V1ManagedMongoDbApi.
 * @export
 * @interface V1ManagedMongoDbApiDeleteDatabaseRequest
 */
export interface V1ManagedMongoDbApiDeleteDatabaseRequest {
    /**
     *
     * @type {string}
     * @memberof V1ManagedMongoDbApiDeleteDatabase
     */
    readonly clusterId: string;

    /**
     *
     * @type {string}
     * @memberof V1ManagedMongoDbApiDeleteDatabase
     */
    readonly databaseId: string;
}

/**
 * Request parameters for deleteUser operation in V1ManagedMongoDbApi.
 * @export
 * @interface V1ManagedMongoDbApiDeleteUserRequest
 */
export interface V1ManagedMongoDbApiDeleteUserRequest {
    /**
     *
     * @type {string}
     * @memberof V1ManagedMongoDbApiDeleteUser
     */
    readonly userId: string;
}

/**
 * Request parameters for getCluster operation in V1ManagedMongoDbApi.
 * @export
 * @interface V1ManagedMongoDbApiGetClusterRequest
 */
export interface V1ManagedMongoDbApiGetClusterRequest {
    /**
     *
     * @type {string}
     * @memberof V1ManagedMongoDbApiGetCluster
     */
    readonly clusterId: string;
}

/**
 * Request parameters for getUser operation in V1ManagedMongoDbApi.
 * @export
 * @interface V1ManagedMongoDbApiGetUserRequest
 */
export interface V1ManagedMongoDbApiGetUserRequest {
    /**
     *
     * @type {string}
     * @memberof V1ManagedMongoDbApiGetUser
     */
    readonly userId: string;
}

/**
 * Request parameters for listDatabases operation in V1ManagedMongoDbApi.
 * @export
 * @interface V1ManagedMongoDbApiListDatabasesRequest
 */
export interface V1ManagedMongoDbApiListDatabasesRequest {
    /**
     *
     * @type {string}
     * @memberof V1ManagedMongoDbApiListDatabases
     */
    readonly clusterId: string;
}

/**
 * Request parameters for listHosts operation in V1ManagedMongoDbApi.
 * @export
 * @interface V1ManagedMongoDbApiListHostsRequest
 */
export interface V1ManagedMongoDbApiListHostsRequest {
    /**
     *
     * @type {string}
     * @memberof V1ManagedMongoDbApiListHosts
     */
    readonly clusterId: string;
}

/**
 * Request parameters for listUsers operation in V1ManagedMongoDbApi.
 * @export
 * @interface V1ManagedMongoDbApiListUsersRequest
 */
export interface V1ManagedMongoDbApiListUsersRequest {
    /**
     *
     * @type {string}
     * @memberof V1ManagedMongoDbApiListUsers
     */
    readonly clusterId: string;
}

/**
 * Request parameters for updateCluster operation in V1ManagedMongoDbApi.
 * @export
 * @interface V1ManagedMongoDbApiUpdateClusterRequest
 */
export interface V1ManagedMongoDbApiUpdateClusterRequest {
    /**
     *
     * @type {string}
     * @memberof V1ManagedMongoDbApiUpdateCluster
     */
    readonly clusterId: string;

    /**
     *
     * @type {V1MongoUpdateClusterRequest}
     * @memberof V1ManagedMongoDbApiUpdateCluster
     */
    readonly v1MongoUpdateClusterRequest: V1MongoUpdateClusterRequest;
}

/**
 * Request parameters for updateHosts operation in V1ManagedMongoDbApi.
 * @export
 * @interface V1ManagedMongoDbApiUpdateHostsRequest
 */
export interface V1ManagedMongoDbApiUpdateHostsRequest {
    /**
     *
     * @type {UpdateMongoHostsRequest}
     * @memberof V1ManagedMongoDbApiUpdateHosts
     */
    readonly updateMongoHostsRequest: UpdateMongoHostsRequest;
}

/**
 * V1ManagedMongoDbApi - object-oriented interface
 * @export
 * @class V1ManagedMongoDbApi
 * @extends {BaseAPI}
 */
export class V1ManagedMongoDbApi extends BaseAPI {
    /**
     *
     * @summary Create MongoDB cluster
     * @param {V1ManagedMongoDbApiCreateClusterRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ManagedMongoDbApi
     */
    public createCluster(
        requestParameters: V1ManagedMongoDbApiCreateClusterRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return V1ManagedMongoDbApiFp(this.configuration)
            .createCluster(requestParameters.v1CreateMongoClusterRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Create MongoDB database
     * @param {V1ManagedMongoDbApiCreateDatabaseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ManagedMongoDbApi
     */
    public createDatabase(
        requestParameters: V1ManagedMongoDbApiCreateDatabaseRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return V1ManagedMongoDbApiFp(this.configuration)
            .createDatabase(
                requestParameters.clusterId,
                requestParameters.createMongoDatabaseRequest,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Create MongoDB user
     * @param {V1ManagedMongoDbApiCreateUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ManagedMongoDbApi
     */
    public createUser(
        requestParameters: V1ManagedMongoDbApiCreateUserRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return V1ManagedMongoDbApiFp(this.configuration)
            .createUser(requestParameters.clusterId, requestParameters.mongoUserToCreate, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Delete MongoDB cluster
     * @param {V1ManagedMongoDbApiDeleteClusterRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ManagedMongoDbApi
     */
    public deleteCluster(
        requestParameters: V1ManagedMongoDbApiDeleteClusterRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return V1ManagedMongoDbApiFp(this.configuration)
            .deleteCluster(requestParameters.clusterId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Delete MongoDB database
     * @param {V1ManagedMongoDbApiDeleteDatabaseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ManagedMongoDbApi
     */
    public deleteDatabase(
        requestParameters: V1ManagedMongoDbApiDeleteDatabaseRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return V1ManagedMongoDbApiFp(this.configuration)
            .deleteDatabase(requestParameters.clusterId, requestParameters.databaseId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Delete MongoDB user
     * @param {V1ManagedMongoDbApiDeleteUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ManagedMongoDbApi
     */
    public deleteUser(
        requestParameters: V1ManagedMongoDbApiDeleteUserRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return V1ManagedMongoDbApiFp(this.configuration)
            .deleteUser(requestParameters.userId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get MongoDB cluster
     * @param {V1ManagedMongoDbApiGetClusterRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ManagedMongoDbApi
     */
    public getCluster(
        requestParameters: V1ManagedMongoDbApiGetClusterRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return V1ManagedMongoDbApiFp(this.configuration)
            .getCluster(requestParameters.clusterId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get MongoDB user
     * @param {V1ManagedMongoDbApiGetUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ManagedMongoDbApi
     */
    public getUser(
        requestParameters: V1ManagedMongoDbApiGetUserRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return V1ManagedMongoDbApiFp(this.configuration)
            .getUser(requestParameters.userId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get MongoDB clusters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ManagedMongoDbApi
     */
    public listClusters(options?: RawAxiosRequestConfig) {
        return V1ManagedMongoDbApiFp(this.configuration)
            .listClusters(options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary List MongoDB databases
     * @param {V1ManagedMongoDbApiListDatabasesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ManagedMongoDbApi
     */
    public listDatabases(
        requestParameters: V1ManagedMongoDbApiListDatabasesRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return V1ManagedMongoDbApiFp(this.configuration)
            .listDatabases(requestParameters.clusterId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get MongoDB hosts
     * @param {V1ManagedMongoDbApiListHostsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ManagedMongoDbApi
     */
    public listHosts(
        requestParameters: V1ManagedMongoDbApiListHostsRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return V1ManagedMongoDbApiFp(this.configuration)
            .listHosts(requestParameters.clusterId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary List MongoDB users
     * @param {V1ManagedMongoDbApiListUsersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ManagedMongoDbApi
     */
    public listUsers(
        requestParameters: V1ManagedMongoDbApiListUsersRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return V1ManagedMongoDbApiFp(this.configuration)
            .listUsers(requestParameters.clusterId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Update MongoDB cluster
     * @param {V1ManagedMongoDbApiUpdateClusterRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ManagedMongoDbApi
     */
    public updateCluster(
        requestParameters: V1ManagedMongoDbApiUpdateClusterRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return V1ManagedMongoDbApiFp(this.configuration)
            .updateCluster(
                requestParameters.clusterId,
                requestParameters.v1MongoUpdateClusterRequest,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Update MongoDB hosts
     * @param {V1ManagedMongoDbApiUpdateHostsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ManagedMongoDbApi
     */
    public updateHosts(
        requestParameters: V1ManagedMongoDbApiUpdateHostsRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return V1ManagedMongoDbApiFp(this.configuration)
            .updateHosts(requestParameters.updateMongoHostsRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
}

/**
 * V1ProjectsApi - axios parameter creator
 * @export
 */
export const V1ProjectsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Archive project
         * @param {string} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveProject: async (
            projectId: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('archiveProject', 'projectId', projectId);
            const localVarPath = `/api/v1/projects/{projectId}/archive`.replace(
                `{${'projectId'}}`,
                encodeURIComponent(String(projectId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create project
         * @param {V1CreateProjectRequest} v1CreateProjectRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProject: async (
            v1CreateProjectRequest: V1CreateProjectRequest,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'v1CreateProjectRequest' is not null or undefined
            assertParamExists('createProject', 'v1CreateProjectRequest', v1CreateProjectRequest);
            const localVarPath = `/api/v1/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = serializeDataIfNeeded(
                v1CreateProjectRequest,
                localVarRequestOptions,
                configuration,
            );

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get project
         * @param {string} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject: async (
            projectId: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getProject', 'projectId', projectId);
            const localVarPath = `/api/v1/projects/{projectId}`.replace(
                `{${'projectId'}}`,
                encodeURIComponent(String(projectId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get projects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjects: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Unarchive project
         * @param {string} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unarchiveProject: async (
            projectId: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('unarchiveProject', 'projectId', projectId);
            const localVarPath = `/api/v1/projects/{projectId}/unarchive`.replace(
                `{${'projectId'}}`,
                encodeURIComponent(String(projectId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update project
         * @param {string} projectId
         * @param {V1UpdateProjectRequest} v1UpdateProjectRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProject: async (
            projectId: string,
            v1UpdateProjectRequest: V1UpdateProjectRequest,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('updateProject', 'projectId', projectId);
            // verify required parameter 'v1UpdateProjectRequest' is not null or undefined
            assertParamExists('updateProject', 'v1UpdateProjectRequest', v1UpdateProjectRequest);
            const localVarPath = `/api/v1/projects/{projectId}`.replace(
                `{${'projectId'}}`,
                encodeURIComponent(String(projectId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = serializeDataIfNeeded(
                v1UpdateProjectRequest,
                localVarRequestOptions,
                configuration,
            );

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * V1ProjectsApi - functional programming interface
 * @export
 */
export const V1ProjectsApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = V1ProjectsApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Archive project
         * @param {string} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async archiveProject(
            projectId: string,
            options?: RawAxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.archiveProject(
                projectId,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['V1ProjectsApi.archiveProject']?.[localVarOperationServerIndex]
                    ?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Create project
         * @param {V1CreateProjectRequest} v1CreateProjectRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProject(
            v1CreateProjectRequest: V1CreateProjectRequest,
            options?: RawAxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProject(
                v1CreateProjectRequest,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['V1ProjectsApi.createProject']?.[localVarOperationServerIndex]
                    ?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get project
         * @param {string} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProject(
            projectId: string,
            options?: RawAxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1ProjectResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProject(
                projectId,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['V1ProjectsApi.getProject']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get projects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProjects(
            options?: RawAxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1ListProjectsResponse>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProjects(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['V1ProjectsApi.listProjects']?.[localVarOperationServerIndex]
                    ?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Unarchive project
         * @param {string} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unarchiveProject(
            projectId: string,
            options?: RawAxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unarchiveProject(
                projectId,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['V1ProjectsApi.unarchiveProject']?.[localVarOperationServerIndex]
                    ?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Update project
         * @param {string} projectId
         * @param {V1UpdateProjectRequest} v1UpdateProjectRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProject(
            projectId: string,
            v1UpdateProjectRequest: V1UpdateProjectRequest,
            options?: RawAxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProject(
                projectId,
                v1UpdateProjectRequest,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['V1ProjectsApi.updateProject']?.[localVarOperationServerIndex]
                    ?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
    };
};

/**
 * V1ProjectsApi - factory interface
 * @export
 */
export const V1ProjectsApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = V1ProjectsApiFp(configuration);
    return {
        /**
         *
         * @summary Archive project
         * @param {V1ProjectsApiArchiveProjectRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveProject(
            requestParameters: V1ProjectsApiArchiveProjectRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .archiveProject(requestParameters.projectId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Create project
         * @param {V1ProjectsApiCreateProjectRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProject(
            requestParameters: V1ProjectsApiCreateProjectRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .createProject(requestParameters.v1CreateProjectRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get project
         * @param {V1ProjectsApiGetProjectRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject(
            requestParameters: V1ProjectsApiGetProjectRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<V1ProjectResponse> {
            return localVarFp
                .getProject(requestParameters.projectId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get projects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjects(options?: RawAxiosRequestConfig): AxiosPromise<V1ListProjectsResponse> {
            return localVarFp.listProjects(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Unarchive project
         * @param {V1ProjectsApiUnarchiveProjectRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unarchiveProject(
            requestParameters: V1ProjectsApiUnarchiveProjectRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .unarchiveProject(requestParameters.projectId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update project
         * @param {V1ProjectsApiUpdateProjectRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProject(
            requestParameters: V1ProjectsApiUpdateProjectRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .updateProject(
                    requestParameters.projectId,
                    requestParameters.v1UpdateProjectRequest,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for archiveProject operation in V1ProjectsApi.
 * @export
 * @interface V1ProjectsApiArchiveProjectRequest
 */
export interface V1ProjectsApiArchiveProjectRequest {
    /**
     *
     * @type {string}
     * @memberof V1ProjectsApiArchiveProject
     */
    readonly projectId: string;
}

/**
 * Request parameters for createProject operation in V1ProjectsApi.
 * @export
 * @interface V1ProjectsApiCreateProjectRequest
 */
export interface V1ProjectsApiCreateProjectRequest {
    /**
     *
     * @type {V1CreateProjectRequest}
     * @memberof V1ProjectsApiCreateProject
     */
    readonly v1CreateProjectRequest: V1CreateProjectRequest;
}

/**
 * Request parameters for getProject operation in V1ProjectsApi.
 * @export
 * @interface V1ProjectsApiGetProjectRequest
 */
export interface V1ProjectsApiGetProjectRequest {
    /**
     *
     * @type {string}
     * @memberof V1ProjectsApiGetProject
     */
    readonly projectId: string;
}

/**
 * Request parameters for unarchiveProject operation in V1ProjectsApi.
 * @export
 * @interface V1ProjectsApiUnarchiveProjectRequest
 */
export interface V1ProjectsApiUnarchiveProjectRequest {
    /**
     *
     * @type {string}
     * @memberof V1ProjectsApiUnarchiveProject
     */
    readonly projectId: string;
}

/**
 * Request parameters for updateProject operation in V1ProjectsApi.
 * @export
 * @interface V1ProjectsApiUpdateProjectRequest
 */
export interface V1ProjectsApiUpdateProjectRequest {
    /**
     *
     * @type {string}
     * @memberof V1ProjectsApiUpdateProject
     */
    readonly projectId: string;

    /**
     *
     * @type {V1UpdateProjectRequest}
     * @memberof V1ProjectsApiUpdateProject
     */
    readonly v1UpdateProjectRequest: V1UpdateProjectRequest;
}

/**
 * V1ProjectsApi - object-oriented interface
 * @export
 * @class V1ProjectsApi
 * @extends {BaseAPI}
 */
export class V1ProjectsApi extends BaseAPI {
    /**
     *
     * @summary Archive project
     * @param {V1ProjectsApiArchiveProjectRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ProjectsApi
     */
    public archiveProject(
        requestParameters: V1ProjectsApiArchiveProjectRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return V1ProjectsApiFp(this.configuration)
            .archiveProject(requestParameters.projectId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Create project
     * @param {V1ProjectsApiCreateProjectRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ProjectsApi
     */
    public createProject(
        requestParameters: V1ProjectsApiCreateProjectRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return V1ProjectsApiFp(this.configuration)
            .createProject(requestParameters.v1CreateProjectRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get project
     * @param {V1ProjectsApiGetProjectRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ProjectsApi
     */
    public getProject(
        requestParameters: V1ProjectsApiGetProjectRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return V1ProjectsApiFp(this.configuration)
            .getProject(requestParameters.projectId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get projects
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ProjectsApi
     */
    public listProjects(options?: RawAxiosRequestConfig) {
        return V1ProjectsApiFp(this.configuration)
            .listProjects(options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Unarchive project
     * @param {V1ProjectsApiUnarchiveProjectRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ProjectsApi
     */
    public unarchiveProject(
        requestParameters: V1ProjectsApiUnarchiveProjectRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return V1ProjectsApiFp(this.configuration)
            .unarchiveProject(requestParameters.projectId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Update project
     * @param {V1ProjectsApiUpdateProjectRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ProjectsApi
     */
    public updateProject(
        requestParameters: V1ProjectsApiUpdateProjectRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return V1ProjectsApiFp(this.configuration)
            .updateProject(
                requestParameters.projectId,
                requestParameters.v1UpdateProjectRequest,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }
}

/**
 * V1ResourcePresetsApi - axios parameter creator
 * @export
 */
export const V1ResourcePresetsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Create resource preset
         * @param {V1CreateResourcePresetRequest} v1CreateResourcePresetRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createResourcePreset: async (
            v1CreateResourcePresetRequest: V1CreateResourcePresetRequest,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'v1CreateResourcePresetRequest' is not null or undefined
            assertParamExists(
                'createResourcePreset',
                'v1CreateResourcePresetRequest',
                v1CreateResourcePresetRequest,
            );
            const localVarPath = `/api/v1/resource-presets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = serializeDataIfNeeded(
                v1CreateResourcePresetRequest,
                localVarRequestOptions,
                configuration,
            );

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete resource preset
         * @param {string} resourcePresetId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResourcePreset: async (
            resourcePresetId: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'resourcePresetId' is not null or undefined
            assertParamExists('deleteResourcePreset', 'resourcePresetId', resourcePresetId);
            const localVarPath = `/api/v1/resource-presets/{resourcePresetId}`.replace(
                `{${'resourcePresetId'}}`,
                encodeURIComponent(String(resourcePresetId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get resource preset
         * @param {string} resourcePresetId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResourcePreset: async (
            resourcePresetId: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'resourcePresetId' is not null or undefined
            assertParamExists('getResourcePreset', 'resourcePresetId', resourcePresetId);
            const localVarPath = `/api/v1/resource-presets/{resourcePresetId}`.replace(
                `{${'resourcePresetId'}}`,
                encodeURIComponent(String(resourcePresetId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get resource presets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResourcePresets: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/resource-presets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update resource preset
         * @param {string} resourcePresetId
         * @param {V1UpdateResourcePresetRequest} v1UpdateResourcePresetRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResourcePreset: async (
            resourcePresetId: string,
            v1UpdateResourcePresetRequest: V1UpdateResourcePresetRequest,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'resourcePresetId' is not null or undefined
            assertParamExists('updateResourcePreset', 'resourcePresetId', resourcePresetId);
            // verify required parameter 'v1UpdateResourcePresetRequest' is not null or undefined
            assertParamExists(
                'updateResourcePreset',
                'v1UpdateResourcePresetRequest',
                v1UpdateResourcePresetRequest,
            );
            const localVarPath = `/api/v1/resource-presets/{resourcePresetId}`.replace(
                `{${'resourcePresetId'}}`,
                encodeURIComponent(String(resourcePresetId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = serializeDataIfNeeded(
                v1UpdateResourcePresetRequest,
                localVarRequestOptions,
                configuration,
            );

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * V1ResourcePresetsApi - functional programming interface
 * @export
 */
export const V1ResourcePresetsApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = V1ResourcePresetsApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Create resource preset
         * @param {V1CreateResourcePresetRequest} v1CreateResourcePresetRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createResourcePreset(
            v1CreateResourcePresetRequest: V1CreateResourcePresetRequest,
            options?: RawAxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createResourcePreset(
                v1CreateResourcePresetRequest,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['V1ResourcePresetsApi.createResourcePreset']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Delete resource preset
         * @param {string} resourcePresetId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteResourcePreset(
            resourcePresetId: string,
            options?: RawAxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteResourcePreset(
                resourcePresetId,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['V1ResourcePresetsApi.deleteResourcePreset']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get resource preset
         * @param {string} resourcePresetId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getResourcePreset(
            resourcePresetId: string,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1ResourcePresetResponse>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getResourcePreset(
                resourcePresetId,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['V1ResourcePresetsApi.getResourcePreset']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get resource presets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listResourcePresets(
            options?: RawAxiosRequestConfig,
        ): Promise<
            (
                axios?: AxiosInstance,
                basePath?: string,
            ) => AxiosPromise<V1ListResourcePresetsResponse>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listResourcePresets(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['V1ResourcePresetsApi.listResourcePresets']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Update resource preset
         * @param {string} resourcePresetId
         * @param {V1UpdateResourcePresetRequest} v1UpdateResourcePresetRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateResourcePreset(
            resourcePresetId: string,
            v1UpdateResourcePresetRequest: V1UpdateResourcePresetRequest,
            options?: RawAxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateResourcePreset(
                resourcePresetId,
                v1UpdateResourcePresetRequest,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['V1ResourcePresetsApi.updateResourcePreset']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
    };
};

/**
 * V1ResourcePresetsApi - factory interface
 * @export
 */
export const V1ResourcePresetsApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = V1ResourcePresetsApiFp(configuration);
    return {
        /**
         *
         * @summary Create resource preset
         * @param {V1ResourcePresetsApiCreateResourcePresetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createResourcePreset(
            requestParameters: V1ResourcePresetsApiCreateResourcePresetRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .createResourcePreset(requestParameters.v1CreateResourcePresetRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete resource preset
         * @param {V1ResourcePresetsApiDeleteResourcePresetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResourcePreset(
            requestParameters: V1ResourcePresetsApiDeleteResourcePresetRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .deleteResourcePreset(requestParameters.resourcePresetId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get resource preset
         * @param {V1ResourcePresetsApiGetResourcePresetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResourcePreset(
            requestParameters: V1ResourcePresetsApiGetResourcePresetRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<V1ResourcePresetResponse> {
            return localVarFp
                .getResourcePreset(requestParameters.resourcePresetId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get resource presets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResourcePresets(
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<V1ListResourcePresetsResponse> {
            return localVarFp
                .listResourcePresets(options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update resource preset
         * @param {V1ResourcePresetsApiUpdateResourcePresetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResourcePreset(
            requestParameters: V1ResourcePresetsApiUpdateResourcePresetRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .updateResourcePreset(
                    requestParameters.resourcePresetId,
                    requestParameters.v1UpdateResourcePresetRequest,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createResourcePreset operation in V1ResourcePresetsApi.
 * @export
 * @interface V1ResourcePresetsApiCreateResourcePresetRequest
 */
export interface V1ResourcePresetsApiCreateResourcePresetRequest {
    /**
     *
     * @type {V1CreateResourcePresetRequest}
     * @memberof V1ResourcePresetsApiCreateResourcePreset
     */
    readonly v1CreateResourcePresetRequest: V1CreateResourcePresetRequest;
}

/**
 * Request parameters for deleteResourcePreset operation in V1ResourcePresetsApi.
 * @export
 * @interface V1ResourcePresetsApiDeleteResourcePresetRequest
 */
export interface V1ResourcePresetsApiDeleteResourcePresetRequest {
    /**
     *
     * @type {string}
     * @memberof V1ResourcePresetsApiDeleteResourcePreset
     */
    readonly resourcePresetId: string;
}

/**
 * Request parameters for getResourcePreset operation in V1ResourcePresetsApi.
 * @export
 * @interface V1ResourcePresetsApiGetResourcePresetRequest
 */
export interface V1ResourcePresetsApiGetResourcePresetRequest {
    /**
     *
     * @type {string}
     * @memberof V1ResourcePresetsApiGetResourcePreset
     */
    readonly resourcePresetId: string;
}

/**
 * Request parameters for updateResourcePreset operation in V1ResourcePresetsApi.
 * @export
 * @interface V1ResourcePresetsApiUpdateResourcePresetRequest
 */
export interface V1ResourcePresetsApiUpdateResourcePresetRequest {
    /**
     *
     * @type {string}
     * @memberof V1ResourcePresetsApiUpdateResourcePreset
     */
    readonly resourcePresetId: string;

    /**
     *
     * @type {V1UpdateResourcePresetRequest}
     * @memberof V1ResourcePresetsApiUpdateResourcePreset
     */
    readonly v1UpdateResourcePresetRequest: V1UpdateResourcePresetRequest;
}

/**
 * V1ResourcePresetsApi - object-oriented interface
 * @export
 * @class V1ResourcePresetsApi
 * @extends {BaseAPI}
 */
export class V1ResourcePresetsApi extends BaseAPI {
    /**
     *
     * @summary Create resource preset
     * @param {V1ResourcePresetsApiCreateResourcePresetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ResourcePresetsApi
     */
    public createResourcePreset(
        requestParameters: V1ResourcePresetsApiCreateResourcePresetRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return V1ResourcePresetsApiFp(this.configuration)
            .createResourcePreset(requestParameters.v1CreateResourcePresetRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Delete resource preset
     * @param {V1ResourcePresetsApiDeleteResourcePresetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ResourcePresetsApi
     */
    public deleteResourcePreset(
        requestParameters: V1ResourcePresetsApiDeleteResourcePresetRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return V1ResourcePresetsApiFp(this.configuration)
            .deleteResourcePreset(requestParameters.resourcePresetId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get resource preset
     * @param {V1ResourcePresetsApiGetResourcePresetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ResourcePresetsApi
     */
    public getResourcePreset(
        requestParameters: V1ResourcePresetsApiGetResourcePresetRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return V1ResourcePresetsApiFp(this.configuration)
            .getResourcePreset(requestParameters.resourcePresetId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get resource presets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ResourcePresetsApi
     */
    public listResourcePresets(options?: RawAxiosRequestConfig) {
        return V1ResourcePresetsApiFp(this.configuration)
            .listResourcePresets(options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Update resource preset
     * @param {V1ResourcePresetsApiUpdateResourcePresetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ResourcePresetsApi
     */
    public updateResourcePreset(
        requestParameters: V1ResourcePresetsApiUpdateResourcePresetRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return V1ResourcePresetsApiFp(this.configuration)
            .updateResourcePreset(
                requestParameters.resourcePresetId,
                requestParameters.v1UpdateResourcePresetRequest,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }
}

/**
 * V1ZonesApi - axios parameter creator
 * @export
 */
export const V1ZonesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Create zone
         * @param {V1CreateZoneRequest} v1CreateZoneRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createZone: async (
            v1CreateZoneRequest: V1CreateZoneRequest,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'v1CreateZoneRequest' is not null or undefined
            assertParamExists('createZone', 'v1CreateZoneRequest', v1CreateZoneRequest);
            const localVarPath = `/api/v1/zones`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = serializeDataIfNeeded(
                v1CreateZoneRequest,
                localVarRequestOptions,
                configuration,
            );

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete zone
         * @param {string} zoneId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteZone: async (
            zoneId: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'zoneId' is not null or undefined
            assertParamExists('deleteZone', 'zoneId', zoneId);
            const localVarPath = `/api/v1/zones/{zoneId}`.replace(
                `{${'zoneId'}}`,
                encodeURIComponent(String(zoneId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get zone
         * @param {string} zoneId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getZone: async (
            zoneId: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'zoneId' is not null or undefined
            assertParamExists('getZone', 'zoneId', zoneId);
            const localVarPath = `/api/v1/zones/{zoneId}`.replace(
                `{${'zoneId'}}`,
                encodeURIComponent(String(zoneId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get zones
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listZones: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/zones`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update zone
         * @param {string} zoneId
         * @param {V1UpdateZoneRequest} v1UpdateZoneRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateZone: async (
            zoneId: string,
            v1UpdateZoneRequest: V1UpdateZoneRequest,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'zoneId' is not null or undefined
            assertParamExists('updateZone', 'zoneId', zoneId);
            // verify required parameter 'v1UpdateZoneRequest' is not null or undefined
            assertParamExists('updateZone', 'v1UpdateZoneRequest', v1UpdateZoneRequest);
            const localVarPath = `/api/v1/zones/{zoneId}`.replace(
                `{${'zoneId'}}`,
                encodeURIComponent(String(zoneId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = serializeDataIfNeeded(
                v1UpdateZoneRequest,
                localVarRequestOptions,
                configuration,
            );

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * V1ZonesApi - functional programming interface
 * @export
 */
export const V1ZonesApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = V1ZonesApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Create zone
         * @param {V1CreateZoneRequest} v1CreateZoneRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createZone(
            v1CreateZoneRequest: V1CreateZoneRequest,
            options?: RawAxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createZone(
                v1CreateZoneRequest,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['V1ZonesApi.createZone']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Delete zone
         * @param {string} zoneId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteZone(
            zoneId: string,
            options?: RawAxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteZone(zoneId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['V1ZonesApi.deleteZone']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get zone
         * @param {string} zoneId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getZone(
            zoneId: string,
            options?: RawAxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1ZoneResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getZone(zoneId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['V1ZonesApi.getZone']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get zones
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listZones(
            options?: RawAxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1ListZonesResponse>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listZones(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['V1ZonesApi.listZones']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Update zone
         * @param {string} zoneId
         * @param {V1UpdateZoneRequest} v1UpdateZoneRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateZone(
            zoneId: string,
            v1UpdateZoneRequest: V1UpdateZoneRequest,
            options?: RawAxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateZone(
                zoneId,
                v1UpdateZoneRequest,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['V1ZonesApi.updateZone']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
    };
};

/**
 * V1ZonesApi - factory interface
 * @export
 */
export const V1ZonesApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = V1ZonesApiFp(configuration);
    return {
        /**
         *
         * @summary Create zone
         * @param {V1ZonesApiCreateZoneRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createZone(
            requestParameters: V1ZonesApiCreateZoneRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .createZone(requestParameters.v1CreateZoneRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete zone
         * @param {V1ZonesApiDeleteZoneRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteZone(
            requestParameters: V1ZonesApiDeleteZoneRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .deleteZone(requestParameters.zoneId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get zone
         * @param {V1ZonesApiGetZoneRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getZone(
            requestParameters: V1ZonesApiGetZoneRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<V1ZoneResponse> {
            return localVarFp
                .getZone(requestParameters.zoneId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get zones
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listZones(options?: RawAxiosRequestConfig): AxiosPromise<V1ListZonesResponse> {
            return localVarFp.listZones(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update zone
         * @param {V1ZonesApiUpdateZoneRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateZone(
            requestParameters: V1ZonesApiUpdateZoneRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .updateZone(
                    requestParameters.zoneId,
                    requestParameters.v1UpdateZoneRequest,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createZone operation in V1ZonesApi.
 * @export
 * @interface V1ZonesApiCreateZoneRequest
 */
export interface V1ZonesApiCreateZoneRequest {
    /**
     *
     * @type {V1CreateZoneRequest}
     * @memberof V1ZonesApiCreateZone
     */
    readonly v1CreateZoneRequest: V1CreateZoneRequest;
}

/**
 * Request parameters for deleteZone operation in V1ZonesApi.
 * @export
 * @interface V1ZonesApiDeleteZoneRequest
 */
export interface V1ZonesApiDeleteZoneRequest {
    /**
     *
     * @type {string}
     * @memberof V1ZonesApiDeleteZone
     */
    readonly zoneId: string;
}

/**
 * Request parameters for getZone operation in V1ZonesApi.
 * @export
 * @interface V1ZonesApiGetZoneRequest
 */
export interface V1ZonesApiGetZoneRequest {
    /**
     *
     * @type {string}
     * @memberof V1ZonesApiGetZone
     */
    readonly zoneId: string;
}

/**
 * Request parameters for updateZone operation in V1ZonesApi.
 * @export
 * @interface V1ZonesApiUpdateZoneRequest
 */
export interface V1ZonesApiUpdateZoneRequest {
    /**
     *
     * @type {string}
     * @memberof V1ZonesApiUpdateZone
     */
    readonly zoneId: string;

    /**
     *
     * @type {V1UpdateZoneRequest}
     * @memberof V1ZonesApiUpdateZone
     */
    readonly v1UpdateZoneRequest: V1UpdateZoneRequest;
}

/**
 * V1ZonesApi - object-oriented interface
 * @export
 * @class V1ZonesApi
 * @extends {BaseAPI}
 */
export class V1ZonesApi extends BaseAPI {
    /**
     *
     * @summary Create zone
     * @param {V1ZonesApiCreateZoneRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ZonesApi
     */
    public createZone(
        requestParameters: V1ZonesApiCreateZoneRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return V1ZonesApiFp(this.configuration)
            .createZone(requestParameters.v1CreateZoneRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Delete zone
     * @param {V1ZonesApiDeleteZoneRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ZonesApi
     */
    public deleteZone(
        requestParameters: V1ZonesApiDeleteZoneRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return V1ZonesApiFp(this.configuration)
            .deleteZone(requestParameters.zoneId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get zone
     * @param {V1ZonesApiGetZoneRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ZonesApi
     */
    public getZone(requestParameters: V1ZonesApiGetZoneRequest, options?: RawAxiosRequestConfig) {
        return V1ZonesApiFp(this.configuration)
            .getZone(requestParameters.zoneId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get zones
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ZonesApi
     */
    public listZones(options?: RawAxiosRequestConfig) {
        return V1ZonesApiFp(this.configuration)
            .listZones(options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Update zone
     * @param {V1ZonesApiUpdateZoneRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1ZonesApi
     */
    public updateZone(
        requestParameters: V1ZonesApiUpdateZoneRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return V1ZonesApiFp(this.configuration)
            .updateZone(requestParameters.zoneId, requestParameters.v1UpdateZoneRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
