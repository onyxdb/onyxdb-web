/* tslint:disable */
/* eslint-disable */
/**
 * OnyxDB - DBaaS platform in Kubernetes
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type {Configuration} from './configuration';
import type {AxiosInstance, AxiosPromise, RawAxiosRequestConfig} from 'axios';
import globalAxios from 'axios'; // Some imports not used depending on template conditions
// @ts-ignore
import {
    assertParamExists,
    createRequestFunction,
    DUMMY_BASE_URL,
    serializeDataIfNeeded,
    setBearerAuthToObject,
    setSearchParams,
    toPathString,
} from './common';
import type {RequestArgs} from './base'; // @ts-ignore
import {BASE_PATH, BaseAPI, COLLECTION_FORMATS, operationServerMap, RequiredError} from './base';

/**
 *
 * @export
 * @interface AccountBusinessRolesHistoryDTO
 */
export interface AccountBusinessRolesHistoryDTO {
    /**
     *
     * @type {string}
     * @memberof AccountBusinessRolesHistoryDTO
     */
    record_id: string;
    /**
     *
     * @type {string}
     * @memberof AccountBusinessRolesHistoryDTO
     */
    account_id: string;
    /**
     *
     * @type {string}
     * @memberof AccountBusinessRolesHistoryDTO
     */
    business_role_id: string;
    /**
     *
     * @type {string}
     * @memberof AccountBusinessRolesHistoryDTO
     */
    status: string;
    /**
     *
     * @type {string}
     * @memberof AccountBusinessRolesHistoryDTO
     */
    createdAt: string;
}

/**
 *
 * @export
 * @interface AccountDTO
 */
export interface AccountDTO {
    /**
     *
     * @type {string}
     * @memberof AccountDTO
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof AccountDTO
     */
    username: string;
    /**
     *
     * @type {string}
     * @memberof AccountDTO
     */
    password?: string;
    /**
     *
     * @type {string}
     * @memberof AccountDTO
     */
    email: string;
    /**
     *
     * @type {string}
     * @memberof AccountDTO
     */
    firstName?: string;
    /**
     *
     * @type {string}
     * @memberof AccountDTO
     */
    lastName?: string;
    /**
     *
     * @type {{ [key: string]: object; }}
     * @memberof AccountDTO
     */
    data?: {[key: string]: object};
    /**
     *
     * @type {string}
     * @memberof AccountDTO
     */
    createdAt: string;
    /**
     *
     * @type {string}
     * @memberof AccountDTO
     */
    updatedAt: string;
}

/**
 *
 * @export
 * @interface AccountPostDTO
 */
export interface AccountPostDTO {
    /**
     *
     * @type {string}
     * @memberof AccountPostDTO
     */
    id?: string;
    /**
     *
     * @type {string}
     * @memberof AccountPostDTO
     */
    username: string;
    /**
     *
     * @type {string}
     * @memberof AccountPostDTO
     */
    password?: string;
    /**
     *
     * @type {string}
     * @memberof AccountPostDTO
     */
    email: string;
    /**
     *
     * @type {string}
     * @memberof AccountPostDTO
     */
    firstName?: string;
    /**
     *
     * @type {string}
     * @memberof AccountPostDTO
     */
    lastName?: string;
    /**
     *
     * @type {{ [key: string]: object; }}
     * @memberof AccountPostDTO
     */
    data?: {[key: string]: object};
}

/**
 *
 * @export
 * @interface AccountRolesHistoryDTO
 */
export interface AccountRolesHistoryDTO {
    /**
     *
     * @type {string}
     * @memberof AccountRolesHistoryDTO
     */
    record_id: string;
    /**
     *
     * @type {string}
     * @memberof AccountRolesHistoryDTO
     */
    account_id: string;
    /**
     *
     * @type {string}
     * @memberof AccountRolesHistoryDTO
     */
    role_id: string;
    /**
     *
     * @type {string}
     * @memberof AccountRolesHistoryDTO
     */
    status: string;
    /**
     *
     * @type {string}
     * @memberof AccountRolesHistoryDTO
     */
    createdAt: string;
}

/**
 *
 * @export
 * @interface AuthRequestDTO
 */
export interface AuthRequestDTO {
    /**
     *
     * @type {string}
     * @memberof AuthRequestDTO
     */
    username: string;
    /**
     *
     * @type {string}
     * @memberof AuthRequestDTO
     */
    password: string;
}

/**
 *
 * @export
 * @interface BackupStatusDTO
 */
export interface BackupStatusDTO {
    /**
     *
     * @type {string}
     * @memberof BackupStatusDTO
     */
    value: string;
    /**
     *
     * @type {string}
     * @memberof BackupStatusDTO
     */
    displayValue: string;
}

/**
 *
 * @export
 * @interface BackupTypeDTO
 */
export interface BackupTypeDTO {
    /**
     *
     * @type {string}
     * @memberof BackupTypeDTO
     */
    value: string;
    /**
     *
     * @type {string}
     * @memberof BackupTypeDTO
     */
    displayValue: string;
}

/**
 *
 * @export
 * @interface BadRequestResponse
 */
export interface BadRequestResponse {
    /**
     *
     * @type {string}
     * @memberof BadRequestResponse
     */
    message: string;
}

/**
 *
 * @export
 * @interface BusinessRoleDTO
 */
export interface BusinessRoleDTO {
    /**
     *
     * @type {string}
     * @memberof BusinessRoleDTO
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof BusinessRoleDTO
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof BusinessRoleDTO
     */
    shopName: string;
    /**
     *
     * @type {string}
     * @memberof BusinessRoleDTO
     */
    description: string;
    /**
     *
     * @type {string}
     * @memberof BusinessRoleDTO
     */
    parentId?: string;
    /**
     *
     * @type {{ [key: string]: object; }}
     * @memberof BusinessRoleDTO
     */
    data?: {[key: string]: object};
    /**
     *
     * @type {string}
     * @memberof BusinessRoleDTO
     */
    createdAt: string;
    /**
     *
     * @type {string}
     * @memberof BusinessRoleDTO
     */
    updatedAt: string;
}

/**
 *
 * @export
 * @interface BusinessRolePostDTO
 */
export interface BusinessRolePostDTO {
    /**
     *
     * @type {string}
     * @memberof BusinessRolePostDTO
     */
    id?: string;
    /**
     *
     * @type {string}
     * @memberof BusinessRolePostDTO
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof BusinessRolePostDTO
     */
    shopName: string;
    /**
     *
     * @type {string}
     * @memberof BusinessRolePostDTO
     */
    description: string;
    /**
     *
     * @type {string}
     * @memberof BusinessRolePostDTO
     */
    parentId?: string;
    /**
     *
     * @type {{ [key: string]: object; }}
     * @memberof BusinessRolePostDTO
     */
    data?: {[key: string]: object};
}

/**
 *
 * @export
 * @interface CheckPermission200Response
 */
export interface CheckPermission200Response {
    /**
     *
     * @type {boolean}
     * @memberof CheckPermission200Response
     */
    hasAccess?: boolean;
}

/**
 *
 * @export
 * @interface ClusterBackupConfigDTO
 */
export interface ClusterBackupConfigDTO {
    /**
     *
     * @type {boolean}
     * @memberof ClusterBackupConfigDTO
     */
    isEnabled: boolean;
    /**
     *
     * @type {string}
     * @memberof ClusterBackupConfigDTO
     */
    schedule: string;
    /**
     *
     * @type {number}
     * @memberof ClusterBackupConfigDTO
     */
    limit: number;
}

/**
 *
 * @export
 * @interface ClusterResourcesDTO
 */
export interface ClusterResourcesDTO {
    /**
     *
     * @type {string}
     * @memberof ClusterResourcesDTO
     */
    presetId: string;
    /**
     *
     * @type {string}
     * @memberof ClusterResourcesDTO
     */
    storageClass: string;
    /**
     *
     * @type {number}
     * @memberof ClusterResourcesDTO
     */
    storage: number;
}

/**
 *
 * @export
 * @interface ClusterStatusDTO
 */
export interface ClusterStatusDTO {
    /**
     *
     * @type {string}
     * @memberof ClusterStatusDTO
     */
    value: string;
    /**
     *
     * @type {string}
     * @memberof ClusterStatusDTO
     */
    displayValue: string;
}

/**
 *
 * @export
 * @interface CreateMongoClusterRequestDTO
 */
export interface CreateMongoClusterRequestDTO {
    /**
     *
     * @type {string}
     * @memberof CreateMongoClusterRequestDTO
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof CreateMongoClusterRequestDTO
     */
    description: string;
    /**
     *
     * @type {string}
     * @memberof CreateMongoClusterRequestDTO
     */
    projectId: string;
    /**
     *
     * @type {MongoConfigDTO}
     * @memberof CreateMongoClusterRequestDTO
     */
    config: MongoConfigDTO;
    /**
     *
     * @type {MongoInitDatabaseDTO}
     * @memberof CreateMongoClusterRequestDTO
     */
    database: MongoInitDatabaseDTO;
    /**
     *
     * @type {MongoInitUserDTO}
     * @memberof CreateMongoClusterRequestDTO
     */
    user: MongoInitUserDTO;
}

/**
 *
 * @export
 * @interface CreateMongoClusterResponseDTO
 */
export interface CreateMongoClusterResponseDTO {
    /**
     *
     * @type {string}
     * @memberof CreateMongoClusterResponseDTO
     */
    clusterId: string;
    /**
     *
     * @type {string}
     * @memberof CreateMongoClusterResponseDTO
     */
    operationId: string;
}

/**
 *
 * @export
 * @interface CreateMongoDatabaseRequestDTO
 */
export interface CreateMongoDatabaseRequestDTO {
    /**
     *
     * @type {string}
     * @memberof CreateMongoDatabaseRequestDTO
     */
    name: string;
}

/**
 *
 * @export
 * @interface CreateMongoPermissionDTO
 */
export interface CreateMongoPermissionDTO {
    /**
     *
     * @type {string}
     * @memberof CreateMongoPermissionDTO
     */
    databaseName: string;
    /**
     *
     * @type {Array<string>}
     * @memberof CreateMongoPermissionDTO
     */
    roles: Array<string>;
}

/**
 *
 * @export
 * @interface CreateMongoUserRequestDTO
 */
export interface CreateMongoUserRequestDTO {
    /**
     *
     * @type {string}
     * @memberof CreateMongoUserRequestDTO
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof CreateMongoUserRequestDTO
     */
    password: string;
    /**
     *
     * @type {Array<CreateMongoPermissionDTO>}
     * @memberof CreateMongoUserRequestDTO
     */
    permissions: Array<CreateMongoPermissionDTO>;
}

/**
 *
 * @export
 * @interface CreateProjectRequestDTO
 */
export interface CreateProjectRequestDTO {
    /**
     *
     * @type {string}
     * @memberof CreateProjectRequestDTO
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof CreateProjectRequestDTO
     */
    description: string;
    /**
     *
     * @type {string}
     * @memberof CreateProjectRequestDTO
     */
    productId: string;
    /**
     *
     * @type {string}
     * @memberof CreateProjectRequestDTO
     */
    namespace: string;
}

/**
 *
 * @export
 * @interface CreateProjectResponseDTO
 */
export interface CreateProjectResponseDTO {
    /**
     *
     * @type {string}
     * @memberof CreateProjectResponseDTO
     */
    projectId: string;
}

/**
 *
 * @export
 * @interface DomainComponentDTO
 */
export interface DomainComponentDTO {
    /**
     *
     * @type {string}
     * @memberof DomainComponentDTO
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof DomainComponentDTO
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof DomainComponentDTO
     */
    description: string;
    /**
     *
     * @type {string}
     * @memberof DomainComponentDTO
     */
    createdAt: string;
    /**
     *
     * @type {string}
     * @memberof DomainComponentDTO
     */
    updatedAt: string;
}

/**
 *
 * @export
 * @interface DomainComponentPostDTO
 */
export interface DomainComponentPostDTO {
    /**
     *
     * @type {string}
     * @memberof DomainComponentPostDTO
     */
    id?: string;
    /**
     *
     * @type {string}
     * @memberof DomainComponentPostDTO
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof DomainComponentPostDTO
     */
    description: string;
}

/**
 *
 * @export
 * @interface DomainTreeDTO
 */
export interface DomainTreeDTO {
    /**
     *
     * @type {DomainComponentDTO}
     * @memberof DomainTreeDTO
     */
    item: DomainComponentDTO;
    /**
     *
     * @type {Array<OrganizationTreeDTO>}
     * @memberof DomainTreeDTO
     */
    children: Array<OrganizationTreeDTO>;
}

/**
 *
 * @export
 * @interface GetCurrentUser200Response
 */
export interface GetCurrentUser200Response {
    /**
     *
     * @type {AccountDTO}
     * @memberof GetCurrentUser200Response
     */
    account: AccountDTO;
    /**
     *
     * @type {{ [key: string]: { [key: string]: object; }; }}
     * @memberof GetCurrentUser200Response
     */
    permissions: {[key: string]: {[key: string]: object}};
}

/**
 *
 * @export
 * @interface GetProductQuotaUsageReportResponseOA
 */
export interface GetProductQuotaUsageReportResponseOA {
    /**
     *
     * @type {Array<ProductQuotaUsageByResourceOA>}
     * @memberof GetProductQuotaUsageReportResponseOA
     */
    resources: Array<ProductQuotaUsageByResourceOA>;
}

/**
 *
 * @export
 * @interface JwtResponseDTO
 */
export interface JwtResponseDTO {
    /**
     *
     * @type {string}
     * @memberof JwtResponseDTO
     */
    accessToken: string;
    /**
     *
     * @type {string}
     * @memberof JwtResponseDTO
     */
    refreshToken: string;
}

/**
 *
 * @export
 * @interface ListMongoBackupsResponseDTO
 */
export interface ListMongoBackupsResponseDTO {
    /**
     *
     * @type {Array<MongoBackupDTO>}
     * @memberof ListMongoBackupsResponseDTO
     */
    backups: Array<MongoBackupDTO>;
}

/**
 *
 * @export
 * @interface ListMongoClustersResponseDTO
 */
export interface ListMongoClustersResponseDTO {
    /**
     *
     * @type {Array<MongoClusterDTO>}
     * @memberof ListMongoClustersResponseDTO
     */
    clusters: Array<MongoClusterDTO>;
}

/**
 *
 * @export
 * @interface ListMongoDatabasesResponseDTO
 */
export interface ListMongoDatabasesResponseDTO {
    /**
     *
     * @type {Array<MongoDatabaseDTO>}
     * @memberof ListMongoDatabasesResponseDTO
     */
    databases: Array<MongoDatabaseDTO>;
}

/**
 *
 * @export
 * @interface ListMongoRolesResponseDTO
 */
export interface ListMongoRolesResponseDTO {
    /**
     *
     * @type {Array<string>}
     * @memberof ListMongoRolesResponseDTO
     */
    roles: Array<string>;
}

/**
 *
 * @export
 * @interface ListMongoUsersResponseDTO
 */
export interface ListMongoUsersResponseDTO {
    /**
     *
     * @type {Array<MongoUserDTO>}
     * @memberof ListMongoUsersResponseDTO
     */
    users: Array<MongoUserDTO>;
}

/**
 *
 * @export
 * @interface ListMongoVersionsResponseDTO
 */
export interface ListMongoVersionsResponseDTO {
    /**
     *
     * @type {Array<string>}
     * @memberof ListMongoVersionsResponseDTO
     */
    versions: Array<string>;
}

/**
 *
 * @export
 * @interface ListNamespacesResponseDTO
 */
export interface ListNamespacesResponseDTO {
    /**
     *
     * @type {Array<string>}
     * @memberof ListNamespacesResponseDTO
     */
    namespaces: Array<string>;
}

/**
 *
 * @export
 * @interface ListOperationsResponseDTO
 */
export interface ListOperationsResponseDTO {
    /**
     *
     * @type {Array<OperationDTO>}
     * @memberof ListOperationsResponseDTO
     */
    operations: Array<OperationDTO>;
}

/**
 *
 * @export
 * @interface ListProjectsResponseDTO
 */
export interface ListProjectsResponseDTO {
    /**
     *
     * @type {Array<ProjectDTO>}
     * @memberof ListProjectsResponseDTO
     */
    projects: Array<ProjectDTO>;
}

/**
 *
 * @export
 * @interface ListQuotasByProductsResponse
 */
export interface ListQuotasByProductsResponse {
    /**
     *
     * @type {Array<ProductQuotas>}
     * @memberof ListQuotasByProductsResponse
     */
    products: Array<ProductQuotas>;
}

/**
 *
 * @export
 * @interface ListResourcesResponse
 */
export interface ListResourcesResponse {
    /**
     *
     * @type {Array<Resource>}
     * @memberof ListResourcesResponse
     */
    resources: Array<Resource>;
}

/**
 *
 * @export
 * @interface ListStorageClassesResponseDTO
 */
export interface ListStorageClassesResponseDTO {
    /**
     *
     * @type {Array<string>}
     * @memberof ListStorageClassesResponseDTO
     */
    storageClasses: Array<string>;
}

/**
 *
 * @export
 * @interface MongoBackupDTO
 */
export interface MongoBackupDTO {
    /**
     *
     * @type {string}
     * @memberof MongoBackupDTO
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof MongoBackupDTO
     */
    clusterId: string;
    /**
     *
     * @type {BackupTypeDTO}
     * @memberof MongoBackupDTO
     */
    type: BackupTypeDTO;
    /**
     *
     * @type {BackupStatusDTO}
     * @memberof MongoBackupDTO
     */
    status: BackupStatusDTO;
    /**
     *
     * @type {string}
     * @memberof MongoBackupDTO
     */
    startedAt: string;
    /**
     *
     * @type {string}
     * @memberof MongoBackupDTO
     */
    finishedAt: string;
}

/**
 *
 * @export
 * @interface MongoClusterDTO
 */
export interface MongoClusterDTO {
    /**
     *
     * @type {string}
     * @memberof MongoClusterDTO
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof MongoClusterDTO
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof MongoClusterDTO
     */
    description: string;
    /**
     *
     * @type {ClusterStatusDTO}
     * @memberof MongoClusterDTO
     */
    status: ClusterStatusDTO;
    /**
     *
     * @type {string}
     * @memberof MongoClusterDTO
     */
    projectId: string;
    /**
     *
     * @type {string}
     * @memberof MongoClusterDTO
     */
    namespace: string;
    /**
     *
     * @type {MongoConfigDTO}
     * @memberof MongoClusterDTO
     */
    config: MongoConfigDTO;
    /**
     *
     * @type {string}
     * @memberof MongoClusterDTO
     */
    createdAt: string;
    /**
     *
     * @type {string}
     * @memberof MongoClusterDTO
     */
    createdBy: string;
    /**
     *
     * @type {boolean}
     * @memberof MongoClusterDTO
     */
    isDeleted: boolean;
    /**
     *
     * @type {string}
     * @memberof MongoClusterDTO
     */
    deletedAt: string;
    /**
     *
     * @type {string}
     * @memberof MongoClusterDTO
     */
    deletedBy: string;
}

/**
 *
 * @export
 * @interface MongoConfigDTO
 */
export interface MongoConfigDTO {
    /**
     *
     * @type {string}
     * @memberof MongoConfigDTO
     */
    version: string;
    /**
     *
     * @type {ClusterResourcesDTO}
     * @memberof MongoConfigDTO
     */
    resources: ClusterResourcesDTO;
    /**
     *
     * @type {number}
     * @memberof MongoConfigDTO
     */
    replicas: number;
    /**
     *
     * @type {ClusterBackupConfigDTO}
     * @memberof MongoConfigDTO
     */
    backup: ClusterBackupConfigDTO;
}

/**
 *
 * @export
 * @interface MongoDatabaseDTO
 */
export interface MongoDatabaseDTO {
    /**
     *
     * @type {string}
     * @memberof MongoDatabaseDTO
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof MongoDatabaseDTO
     */
    clusterId: string;
    /**
     *
     * @type {string}
     * @memberof MongoDatabaseDTO
     */
    createdAt: string;
    /**
     *
     * @type {string}
     * @memberof MongoDatabaseDTO
     */
    createdBy: string;
    /**
     *
     * @type {boolean}
     * @memberof MongoDatabaseDTO
     */
    isDeleted: boolean;
    /**
     *
     * @type {string}
     * @memberof MongoDatabaseDTO
     */
    deletedAt: string;
    /**
     *
     * @type {string}
     * @memberof MongoDatabaseDTO
     */
    deletedBy: string;
}

/**
 *
 * @export
 * @interface MongoHost
 */
export interface MongoHost {
    /**
     *
     * @type {string}
     * @memberof MongoHost
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof MongoHost
     */
    clusterId: string;
    /**
     *
     * @type {string}
     * @memberof MongoHost
     */
    type: MongoHostTypeEnum;
    /**
     *
     * @type {string}
     * @memberof MongoHost
     */
    status: MongoHostStatusEnum;
    /**
     *
     * @type {string}
     * @memberof MongoHost
     */
    role: MongoHostRoleEnum;
}

export const MongoHostTypeEnum = {
    Unknown: 'unknown',
    Mongod: 'mongod',
} as const;

export type MongoHostTypeEnum = (typeof MongoHostTypeEnum)[keyof typeof MongoHostTypeEnum];
export const MongoHostStatusEnum = {
    Unknown: 'unknown',
    Alive: 'alive',
    Dead: 'dead',
} as const;

export type MongoHostStatusEnum = (typeof MongoHostStatusEnum)[keyof typeof MongoHostStatusEnum];
export const MongoHostRoleEnum = {
    Unknown: 'unknown',
    Primary: 'primary',
    Secondary: 'secondary',
} as const;

export type MongoHostRoleEnum = (typeof MongoHostRoleEnum)[keyof typeof MongoHostRoleEnum];

/**
 *
 * @export
 * @interface MongoInitDatabaseDTO
 */
export interface MongoInitDatabaseDTO {
    /**
     *
     * @type {string}
     * @memberof MongoInitDatabaseDTO
     */
    name: string;
}

/**
 *
 * @export
 * @interface MongoInitUserDTO
 */
export interface MongoInitUserDTO {
    /**
     *
     * @type {string}
     * @memberof MongoInitUserDTO
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof MongoInitUserDTO
     */
    password: string;
}

/**
 *
 * @export
 * @interface MongoPermissionDTO
 */
export interface MongoPermissionDTO {
    /**
     *
     * @type {string}
     * @memberof MongoPermissionDTO
     */
    databaseName: string;
    /**
     *
     * @type {string}
     * @memberof MongoPermissionDTO
     */
    createdAt: string;
    /**
     *
     * @type {string}
     * @memberof MongoPermissionDTO
     */
    createdBy: string;
    /**
     *
     * @type {boolean}
     * @memberof MongoPermissionDTO
     */
    isDeleted: boolean;
    /**
     *
     * @type {string}
     * @memberof MongoPermissionDTO
     */
    deletedAt: string;
    /**
     *
     * @type {string}
     * @memberof MongoPermissionDTO
     */
    deletedBy: string;
    /**
     *
     * @type {Array<string>}
     * @memberof MongoPermissionDTO
     */
    roles: Array<string>;
}

/**
 *
 * @export
 * @interface MongoUserDTO
 */
export interface MongoUserDTO {
    /**
     *
     * @type {string}
     * @memberof MongoUserDTO
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof MongoUserDTO
     */
    clusterId: string;
    /**
     *
     * @type {string}
     * @memberof MongoUserDTO
     */
    createdAt: string;
    /**
     *
     * @type {string}
     * @memberof MongoUserDTO
     */
    createdBy: string;
    /**
     *
     * @type {boolean}
     * @memberof MongoUserDTO
     */
    isDeleted: boolean;
    /**
     *
     * @type {string}
     * @memberof MongoUserDTO
     */
    deletedAt: string;
    /**
     *
     * @type {string}
     * @memberof MongoUserDTO
     */
    deletedBy: string;
    /**
     *
     * @type {Array<MongoPermissionDTO>}
     * @memberof MongoUserDTO
     */
    permissions: Array<MongoPermissionDTO>;
}

/**
 *
 * @export
 * @interface NotFoundResponse
 */
export interface NotFoundResponse {
    /**
     *
     * @type {string}
     * @memberof NotFoundResponse
     */
    message: string;
}

/**
 *
 * @export
 * @interface OperationDTO
 */
export interface OperationDTO {
    /**
     *
     * @type {string}
     * @memberof OperationDTO
     */
    id: string;
    /**
     *
     * @type {OperationTypeDTO}
     * @memberof OperationDTO
     */
    type: OperationTypeDTO;
    /**
     *
     * @type {OperationStatusDTO}
     * @memberof OperationDTO
     */
    status: OperationStatusDTO;
    /**
     *
     * @type {string}
     * @memberof OperationDTO
     */
    createdAt: string;
    /**
     *
     * @type {string}
     * @memberof OperationDTO
     */
    createdBy: string;
    /**
     *
     * @type {string}
     * @memberof OperationDTO
     */
    updatedAt: string;
    /**
     *
     * @type {boolean}
     * @memberof OperationDTO
     */
    isRestartAllowed: boolean;
}

/**
 *
 * @export
 * @interface OperationStatusDTO
 */
export interface OperationStatusDTO {
    /**
     *
     * @type {string}
     * @memberof OperationStatusDTO
     */
    value: string;
    /**
     *
     * @type {string}
     * @memberof OperationStatusDTO
     */
    displayValue: string;
}

/**
 *
 * @export
 * @interface OperationTypeDTO
 */
export interface OperationTypeDTO {
    /**
     *
     * @type {string}
     * @memberof OperationTypeDTO
     */
    value: string;
    /**
     *
     * @type {string}
     * @memberof OperationTypeDTO
     */
    displayValue: string;
}

/**
 *
 * @export
 * @interface OrganizationTreeDTO
 */
export interface OrganizationTreeDTO {
    /**
     *
     * @type {Array<OrganizationTreeDTO>}
     * @memberof OrganizationTreeDTO
     */
    items: Array<OrganizationTreeDTO>;
    /**
     *
     * @type {OrganizationUnitDTO}
     * @memberof OrganizationTreeDTO
     */
    unit: OrganizationUnitDTO;
}

/**
 *
 * @export
 * @interface OrganizationUnitDTO
 */
export interface OrganizationUnitDTO {
    /**
     *
     * @type {string}
     * @memberof OrganizationUnitDTO
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof OrganizationUnitDTO
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof OrganizationUnitDTO
     */
    description: string;
    /**
     *
     * @type {string}
     * @memberof OrganizationUnitDTO
     */
    domainComponentId: string;
    /**
     *
     * @type {string}
     * @memberof OrganizationUnitDTO
     */
    parentId?: string;
    /**
     *
     * @type {string}
     * @memberof OrganizationUnitDTO
     */
    ownerId?: string;
    /**
     *
     * @type {string}
     * @memberof OrganizationUnitDTO
     */
    createdAt: string;
    /**
     *
     * @type {string}
     * @memberof OrganizationUnitDTO
     */
    updatedAt: string;
}

/**
 *
 * @export
 * @interface OrganizationUnitPostDTO
 */
export interface OrganizationUnitPostDTO {
    /**
     *
     * @type {string}
     * @memberof OrganizationUnitPostDTO
     */
    id?: string;
    /**
     *
     * @type {string}
     * @memberof OrganizationUnitPostDTO
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof OrganizationUnitPostDTO
     */
    description: string;
    /**
     *
     * @type {string}
     * @memberof OrganizationUnitPostDTO
     */
    domainComponentId: string;
    /**
     *
     * @type {string}
     * @memberof OrganizationUnitPostDTO
     */
    parentId?: string;
    /**
     *
     * @type {string}
     * @memberof OrganizationUnitPostDTO
     */
    ownerId?: string;
}

/**
 *
 * @export
 * @interface PaginatedAccountResponse
 */
export interface PaginatedAccountResponse {
    /**
     *
     * @type {number}
     * @memberof PaginatedAccountResponse
     */
    totalCount: number;
    /**
     *
     * @type {number}
     * @memberof PaginatedAccountResponse
     */
    startPosition: number;
    /**
     *
     * @type {number}
     * @memberof PaginatedAccountResponse
     */
    endPosition: number;
    /**
     *
     * @type {Array<AccountDTO>}
     * @memberof PaginatedAccountResponse
     */
    data: Array<AccountDTO>;
}

/**
 *
 * @export
 * @interface PaginatedBusinessRoleResponse
 */
export interface PaginatedBusinessRoleResponse {
    /**
     *
     * @type {number}
     * @memberof PaginatedBusinessRoleResponse
     */
    totalCount: number;
    /**
     *
     * @type {number}
     * @memberof PaginatedBusinessRoleResponse
     */
    startPosition: number;
    /**
     *
     * @type {number}
     * @memberof PaginatedBusinessRoleResponse
     */
    endPosition: number;
    /**
     *
     * @type {Array<BusinessRoleDTO>}
     * @memberof PaginatedBusinessRoleResponse
     */
    data: Array<BusinessRoleDTO>;
}

/**
 *
 * @export
 * @interface PaginatedOrganizationUnitResponse
 */
export interface PaginatedOrganizationUnitResponse {
    /**
     *
     * @type {number}
     * @memberof PaginatedOrganizationUnitResponse
     */
    totalCount: number;
    /**
     *
     * @type {number}
     * @memberof PaginatedOrganizationUnitResponse
     */
    startPosition: number;
    /**
     *
     * @type {number}
     * @memberof PaginatedOrganizationUnitResponse
     */
    endPosition: number;
    /**
     *
     * @type {Array<OrganizationUnitDTO>}
     * @memberof PaginatedOrganizationUnitResponse
     */
    data: Array<OrganizationUnitDTO>;
}

/**
 *
 * @export
 * @interface PaginatedProductResponse
 */
export interface PaginatedProductResponse {
    /**
     *
     * @type {number}
     * @memberof PaginatedProductResponse
     */
    totalCount: number;
    /**
     *
     * @type {number}
     * @memberof PaginatedProductResponse
     */
    startPosition: number;
    /**
     *
     * @type {number}
     * @memberof PaginatedProductResponse
     */
    endPosition: number;
    /**
     *
     * @type {Array<ProductDTO>}
     * @memberof PaginatedProductResponse
     */
    data: Array<ProductDTO>;
}

/**
 *
 * @export
 * @interface PaginatedRoleRequestResponse
 */
export interface PaginatedRoleRequestResponse {
    /**
     *
     * @type {number}
     * @memberof PaginatedRoleRequestResponse
     */
    totalCount: number;
    /**
     *
     * @type {number}
     * @memberof PaginatedRoleRequestResponse
     */
    startPosition: number;
    /**
     *
     * @type {number}
     * @memberof PaginatedRoleRequestResponse
     */
    endPosition: number;
    /**
     *
     * @type {Array<RoleRequestFullDTO>}
     * @memberof PaginatedRoleRequestResponse
     */
    data: Array<RoleRequestFullDTO>;
}

/**
 *
 * @export
 * @interface PaginatedRoleResponse
 */
export interface PaginatedRoleResponse {
    /**
     *
     * @type {number}
     * @memberof PaginatedRoleResponse
     */
    totalCount: number;
    /**
     *
     * @type {number}
     * @memberof PaginatedRoleResponse
     */
    startPosition: number;
    /**
     *
     * @type {number}
     * @memberof PaginatedRoleResponse
     */
    endPosition: number;
    /**
     *
     * @type {Array<RoleDTO>}
     * @memberof PaginatedRoleResponse
     */
    data: Array<RoleDTO>;
}

/**
 *
 * @export
 * @interface PermissionDTO
 */
export interface PermissionDTO {
    /**
     *
     * @type {string}
     * @memberof PermissionDTO
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof PermissionDTO
     */
    actionType: string;
    /**
     *
     * @type {string}
     * @memberof PermissionDTO
     */
    resourceType: string;
    /**
     *
     * @type {{ [key: string]: object; }}
     * @memberof PermissionDTO
     */
    data?: {[key: string]: object};
    /**
     *
     * @type {string}
     * @memberof PermissionDTO
     */
    createdAt: string;
    /**
     *
     * @type {string}
     * @memberof PermissionDTO
     */
    updatedAt: string;
}

/**
 *
 * @export
 * @interface PermissionPostDTO
 */
export interface PermissionPostDTO {
    /**
     *
     * @type {string}
     * @memberof PermissionPostDTO
     */
    id?: string;
    /**
     *
     * @type {string}
     * @memberof PermissionPostDTO
     */
    actionType: string;
    /**
     *
     * @type {string}
     * @memberof PermissionPostDTO
     */
    resourceType: string;
    /**
     *
     * @type {{ [key: string]: object; }}
     * @memberof PermissionPostDTO
     */
    data?: {[key: string]: object};
}

/**
 *
 * @export
 * @interface ProductDTO
 */
export interface ProductDTO {
    /**
     *
     * @type {string}
     * @memberof ProductDTO
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof ProductDTO
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof ProductDTO
     */
    description: string;
    /**
     *
     * @type {string}
     * @memberof ProductDTO
     */
    parentId?: string;
    /**
     *
     * @type {string}
     * @memberof ProductDTO
     */
    ownerId?: string;
    /**
     *
     * @type {{ [key: string]: object; }}
     * @memberof ProductDTO
     */
    data?: {[key: string]: object};
    /**
     *
     * @type {string}
     * @memberof ProductDTO
     */
    createdAt: string;
    /**
     *
     * @type {string}
     * @memberof ProductDTO
     */
    updatedAt: string;
}

/**
 *
 * @export
 * @interface ProductPostDTO
 */
export interface ProductPostDTO {
    /**
     *
     * @type {string}
     * @memberof ProductPostDTO
     */
    id?: string;
    /**
     *
     * @type {string}
     * @memberof ProductPostDTO
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof ProductPostDTO
     */
    description: string;
    /**
     *
     * @type {string}
     * @memberof ProductPostDTO
     */
    parentId?: string;
    /**
     *
     * @type {string}
     * @memberof ProductPostDTO
     */
    ownerId?: string;
    /**
     *
     * @type {{ [key: string]: object; }}
     * @memberof ProductPostDTO
     */
    data?: {[key: string]: object};
}

/**
 *
 * @export
 * @interface ProductQuotaUsageByResourceOA
 */
export interface ProductQuotaUsageByResourceOA {
    /**
     *
     * @type {Resource}
     * @memberof ProductQuotaUsageByResourceOA
     */
    resource: Resource;
    /**
     *
     * @type {Array<ProductQuotaUsageReportItemOA>}
     * @memberof ProductQuotaUsageByResourceOA
     */
    items: Array<ProductQuotaUsageReportItemOA>;
}

/**
 *
 * @export
 * @interface ProductQuotaUsageReportItemOA
 */
export interface ProductQuotaUsageReportItemOA {
    /**
     *
     * @type {string}
     * @memberof ProductQuotaUsageReportItemOA
     */
    productId: string;
    /**
     *
     * @type {string}
     * @memberof ProductQuotaUsageReportItemOA
     */
    quotaProvider: string;
    /**
     *
     * @type {number}
     * @memberof ProductQuotaUsageReportItemOA
     */
    limit: number;
    /**
     *
     * @type {number}
     * @memberof ProductQuotaUsageReportItemOA
     */
    usage: number;
    /**
     *
     * @type {number}
     * @memberof ProductQuotaUsageReportItemOA
     */
    free: number;
    /**
     *
     * @type {number}
     * @memberof ProductQuotaUsageReportItemOA
     */
    timestamp: number;
}

/**
 *
 * @export
 * @interface ProductQuotas
 */
export interface ProductQuotas {
    /**
     *
     * @type {string}
     * @memberof ProductQuotas
     */
    productId: string;
    /**
     *
     * @type {Array<Quota>}
     * @memberof ProductQuotas
     */
    quotas: Array<Quota>;
}

/**
 *
 * @export
 * @interface ProductQuotasToTransfer
 */
export interface ProductQuotasToTransfer {
    /**
     *
     * @type {string}
     * @memberof ProductQuotasToTransfer
     */
    productId: string;
    /**
     *
     * @type {Array<QuotaToTransfer>}
     * @memberof ProductQuotasToTransfer
     */
    quotas: Array<QuotaToTransfer>;
}

/**
 *
 * @export
 * @interface ProductTreeDTO
 */
export interface ProductTreeDTO {
    /**
     *
     * @type {ProductDTO}
     * @memberof ProductTreeDTO
     */
    item: ProductDTO;
    /**
     *
     * @type {Array<ProductTreeDTO>}
     * @memberof ProductTreeDTO
     */
    children?: Array<ProductTreeDTO>;
}

/**
 *
 * @export
 * @interface ProjectDTO
 */
export interface ProjectDTO {
    /**
     *
     * @type {string}
     * @memberof ProjectDTO
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof ProjectDTO
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof ProjectDTO
     */
    description: string;
    /**
     *
     * @type {string}
     * @memberof ProjectDTO
     */
    productId: string;
    /**
     *
     * @type {string}
     * @memberof ProjectDTO
     */
    namespace: string;
    /**
     *
     * @type {string}
     * @memberof ProjectDTO
     */
    createdAt: string;
    /**
     *
     * @type {string}
     * @memberof ProjectDTO
     */
    createdBy: string;
    /**
     *
     * @type {boolean}
     * @memberof ProjectDTO
     */
    isDeleted: boolean;
    /**
     *
     * @type {string}
     * @memberof ProjectDTO
     */
    deletedAt: string;
    /**
     *
     * @type {string}
     * @memberof ProjectDTO
     */
    deletedBy: string;
}

/**
 *
 * @export
 * @interface Quota
 */
export interface Quota {
    /**
     *
     * @type {Resource}
     * @memberof Quota
     */
    resource: Resource;
    /**
     *
     * @type {number}
     * @memberof Quota
     */
    limit: number;
    /**
     *
     * @type {number}
     * @memberof Quota
     */
    usage: number;
    /**
     *
     * @type {number}
     * @memberof Quota
     */
    free: number;
}

/**
 *
 * @export
 * @interface QuotaToTransfer
 */
export interface QuotaToTransfer {
    /**
     *
     * @type {string}
     * @memberof QuotaToTransfer
     */
    resourceId: string;
    /**
     *
     * @type {number}
     * @memberof QuotaToTransfer
     */
    limit: number;
}

/**
 *
 * @export
 * @interface RefreshTokenDTO
 */
export interface RefreshTokenDTO {
    /**
     *
     * @type {string}
     * @memberof RefreshTokenDTO
     */
    refreshToken: string;
}

/**
 *
 * @export
 * @interface Resource
 */
export interface Resource {
    /**
     *
     * @type {string}
     * @memberof Resource
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof Resource
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof Resource
     */
    description: string;
    /**
     *
     * @type {string}
     * @memberof Resource
     */
    type: ResourceTypeEnum;
    /**
     *
     * @type {string}
     * @memberof Resource
     */
    unit: ResourceUnitEnum;
}

export const ResourceTypeEnum = {
    Vcpu: 'vcpu',
    Ram: 'ram',
} as const;

export type ResourceTypeEnum = (typeof ResourceTypeEnum)[keyof typeof ResourceTypeEnum];
export const ResourceUnitEnum = {
    Cores: 'cores',
    Bytes: 'bytes',
} as const;

export type ResourceUnitEnum = (typeof ResourceUnitEnum)[keyof typeof ResourceUnitEnum];

/**
 *
 * @export
 * @interface RoleDTO
 */
export interface RoleDTO {
    /**
     *
     * @type {string}
     * @memberof RoleDTO
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof RoleDTO
     */
    roleType: string;
    /**
     *
     * @type {string}
     * @memberof RoleDTO
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof RoleDTO
     */
    shopName: string;
    /**
     *
     * @type {boolean}
     * @memberof RoleDTO
     */
    isShopHidden: boolean;
    /**
     *
     * @type {string}
     * @memberof RoleDTO
     */
    description: string;
    /**
     *
     * @type {string}
     * @memberof RoleDTO
     */
    entity: string;
    /**
     *
     * @type {string}
     * @memberof RoleDTO
     */
    productId?: string;
    /**
     *
     * @type {string}
     * @memberof RoleDTO
     */
    orgUnitId?: string;
    /**
     *
     * @type {string}
     * @memberof RoleDTO
     */
    createdAt: string;
    /**
     *
     * @type {string}
     * @memberof RoleDTO
     */
    updatedAt: string;
}

/**
 *
 * @export
 * @interface RoleHistoryDTO
 */
export interface RoleHistoryDTO {
    /**
     *
     * @type {string}
     * @memberof RoleHistoryDTO
     */
    record_id: string;
    /**
     *
     * @type {string}
     * @memberof RoleHistoryDTO
     */
    role_id: string;
    /**
     *
     * @type {string}
     * @memberof RoleHistoryDTO
     */
    difference: string;
    /**
     *
     * @type {string}
     * @memberof RoleHistoryDTO
     */
    createdAt: string;
}

/**
 *
 * @export
 * @interface RolePostDTO
 */
export interface RolePostDTO {
    /**
     *
     * @type {string}
     * @memberof RolePostDTO
     */
    id?: string;
    /**
     *
     * @type {string}
     * @memberof RolePostDTO
     */
    roleType: string;
    /**
     *
     * @type {string}
     * @memberof RolePostDTO
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof RolePostDTO
     */
    shopName: string;
    /**
     *
     * @type {boolean}
     * @memberof RolePostDTO
     */
    isShopHidden: boolean;
    /**
     *
     * @type {string}
     * @memberof RolePostDTO
     */
    description: string;
    /**
     *
     * @type {string}
     * @memberof RolePostDTO
     */
    entity: string;
    /**
     *
     * @type {string}
     * @memberof RolePostDTO
     */
    productId?: string;
    /**
     *
     * @type {string}
     * @memberof RolePostDTO
     */
    orgUnitId?: string;
}

/**
 *
 * @export
 * @interface RoleRequestDTO
 */
export interface RoleRequestDTO {
    /**
     *
     * @type {string}
     * @memberof RoleRequestDTO
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof RoleRequestDTO
     */
    roleId: string;
    /**
     *
     * @type {string}
     * @memberof RoleRequestDTO
     */
    accountId: string;
    /**
     *
     * @type {string}
     * @memberof RoleRequestDTO
     */
    ownerId?: string;
    /**
     *
     * @type {string}
     * @memberof RoleRequestDTO
     */
    reason: string;
    /**
     *
     * @type {string}
     * @memberof RoleRequestDTO
     */
    status: RoleRequestDTOStatusEnum;
    /**
     *
     * @type {string}
     * @memberof RoleRequestDTO
     */
    createdAt: string;
    /**
     *
     * @type {string}
     * @memberof RoleRequestDTO
     */
    resolvedAt?: string;
}

export const RoleRequestDTOStatusEnum = {
    Waiting: 'WAITING',
    Approved: 'APPROVED',
    Declined: 'DECLINED',
} as const;

export type RoleRequestDTOStatusEnum =
    (typeof RoleRequestDTOStatusEnum)[keyof typeof RoleRequestDTOStatusEnum];

/**
 *
 * @export
 * @interface RoleRequestFullDTO
 */
export interface RoleRequestFullDTO {
    /**
     *
     * @type {string}
     * @memberof RoleRequestFullDTO
     */
    id: string;
    /**
     *
     * @type {RoleDTO}
     * @memberof RoleRequestFullDTO
     */
    role?: RoleDTO;
    /**
     *
     * @type {AccountDTO}
     * @memberof RoleRequestFullDTO
     */
    account?: AccountDTO;
    /**
     *
     * @type {AccountDTO}
     * @memberof RoleRequestFullDTO
     */
    owner?: AccountDTO;
    /**
     *
     * @type {string}
     * @memberof RoleRequestFullDTO
     */
    reason: string;
    /**
     *
     * @type {string}
     * @memberof RoleRequestFullDTO
     */
    status: RoleRequestFullDTOStatusEnum;
    /**
     *
     * @type {string}
     * @memberof RoleRequestFullDTO
     */
    createdAt: string;
    /**
     *
     * @type {string}
     * @memberof RoleRequestFullDTO
     */
    resolvedAt?: string;
}

export const RoleRequestFullDTOStatusEnum = {
    Waiting: 'WAITING',
    Approved: 'APPROVED',
    Declined: 'DECLINED',
} as const;

export type RoleRequestFullDTOStatusEnum =
    (typeof RoleRequestFullDTOStatusEnum)[keyof typeof RoleRequestFullDTOStatusEnum];

/**
 *
 * @export
 * @interface RoleRequestPostDTO
 */
export interface RoleRequestPostDTO {
    /**
     *
     * @type {string}
     * @memberof RoleRequestPostDTO
     */
    id?: string;
    /**
     *
     * @type {string}
     * @memberof RoleRequestPostDTO
     */
    roleId: string;
    /**
     *
     * @type {string}
     * @memberof RoleRequestPostDTO
     */
    accountId: string;
    /**
     *
     * @type {string}
     * @memberof RoleRequestPostDTO
     */
    ownerId?: string;
    /**
     *
     * @type {string}
     * @memberof RoleRequestPostDTO
     */
    reason: string;
    /**
     *
     * @type {string}
     * @memberof RoleRequestPostDTO
     */
    status: RoleRequestPostDTOStatusEnum;
}

export const RoleRequestPostDTOStatusEnum = {
    Waiting: 'WAITING',
    Approved: 'APPROVED',
    Declined: 'DECLINED',
} as const;

export type RoleRequestPostDTOStatusEnum =
    (typeof RoleRequestPostDTOStatusEnum)[keyof typeof RoleRequestPostDTOStatusEnum];

/**
 *
 * @export
 * @interface RoleWithPermissionsDTO
 */
export interface RoleWithPermissionsDTO {
    /**
     *
     * @type {RoleDTO}
     * @memberof RoleWithPermissionsDTO
     */
    role: RoleDTO;
    /**
     *
     * @type {Array<PermissionDTO>}
     * @memberof RoleWithPermissionsDTO
     */
    permissions: Array<PermissionDTO>;
}

/**
 *
 * @export
 * @interface RoleWithPermissionsPostDTO
 */
export interface RoleWithPermissionsPostDTO {
    /**
     *
     * @type {RolePostDTO}
     * @memberof RoleWithPermissionsPostDTO
     */
    role: RolePostDTO;
    /**
     *
     * @type {Array<PermissionPostDTO>}
     * @memberof RoleWithPermissionsPostDTO
     */
    permissions: Array<PermissionPostDTO>;
}

/**
 *
 * @export
 * @interface ScheduledOperationDTO
 */
export interface ScheduledOperationDTO {
    /**
     *
     * @type {string}
     * @memberof ScheduledOperationDTO
     */
    operationId: string;
}

/**
 *
 * @export
 * @interface SimulateMongoDBQuotasUsageRequest
 */
export interface SimulateMongoDBQuotasUsageRequest {
    /**
     *
     * @type {string}
     * @memberof SimulateMongoDBQuotasUsageRequest
     */
    projectId: string;
    /**
     *
     * @type {MongoConfigDTO}
     * @memberof SimulateMongoDBQuotasUsageRequest
     */
    config: MongoConfigDTO;
}

/**
 *
 * @export
 * @interface SimulateMongoDBQuotasUsageResponse
 */
export interface SimulateMongoDBQuotasUsageResponse {
    /**
     *
     * @type {Array<Quota>}
     * @memberof SimulateMongoDBQuotasUsageResponse
     */
    quotas: Array<Quota>;
}

/**
 *
 * @export
 * @interface SimulateTransferQuotasBetweenProductsResponse
 */
export interface SimulateTransferQuotasBetweenProductsResponse {
    /**
     *
     * @type {ProductQuotas}
     * @memberof SimulateTransferQuotasBetweenProductsResponse
     */
    srcProduct: ProductQuotas;
    /**
     *
     * @type {ProductQuotas}
     * @memberof SimulateTransferQuotasBetweenProductsResponse
     */
    dstProduct: ProductQuotas;
}

/**
 *
 * @export
 * @interface TransferQuotasBetweenProductsRequest
 */
export interface TransferQuotasBetweenProductsRequest {
    /**
     *
     * @type {string}
     * @memberof TransferQuotasBetweenProductsRequest
     */
    srcProductId: string;
    /**
     *
     * @type {string}
     * @memberof TransferQuotasBetweenProductsRequest
     */
    dstProductId: string;
    /**
     *
     * @type {Array<QuotaToTransfer>}
     * @memberof TransferQuotasBetweenProductsRequest
     */
    quotas: Array<QuotaToTransfer>;
}

/**
 *
 * @export
 * @interface UnauthorizedResponse
 */
export interface UnauthorizedResponse {
    /**
     *
     * @type {string}
     * @memberof UnauthorizedResponse
     */
    message: string;
}

/**
 *
 * @export
 * @interface UpdateClusterResourcesDTO
 */
export interface UpdateClusterResourcesDTO {
    /**
     *
     * @type {string}
     * @memberof UpdateClusterResourcesDTO
     */
    presetId: string;
}

/**
 *
 * @export
 * @interface UpdateMongoClusterRequestDTO
 */
export interface UpdateMongoClusterRequestDTO {
    /**
     *
     * @type {string}
     * @memberof UpdateMongoClusterRequestDTO
     */
    description: string;
    /**
     *
     * @type {UpdateMongoConfigDTO}
     * @memberof UpdateMongoClusterRequestDTO
     */
    config: UpdateMongoConfigDTO;
}

/**
 *
 * @export
 * @interface UpdateMongoConfigDTO
 */
export interface UpdateMongoConfigDTO {
    /**
     *
     * @type {string}
     * @memberof UpdateMongoConfigDTO
     */
    version: string;
    /**
     *
     * @type {UpdateClusterResourcesDTO}
     * @memberof UpdateMongoConfigDTO
     */
    resources: UpdateClusterResourcesDTO;
    /**
     *
     * @type {number}
     * @memberof UpdateMongoConfigDTO
     */
    replicas: number;
    /**
     *
     * @type {ClusterBackupConfigDTO}
     * @memberof UpdateMongoConfigDTO
     */
    backup: ClusterBackupConfigDTO;
}

/**
 *
 * @export
 * @interface UpdateMongoHostsRequest
 */
export interface UpdateMongoHostsRequest {
    /**
     *
     * @type {Array<MongoHost>}
     * @memberof UpdateMongoHostsRequest
     */
    hosts?: Array<MongoHost>;
}

/**
 *
 * @export
 * @interface UpdateProjectRequestDTO
 */
export interface UpdateProjectRequestDTO {
    /**
     *
     * @type {string}
     * @memberof UpdateProjectRequestDTO
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof UpdateProjectRequestDTO
     */
    description: string;
    /**
     *
     * @type {string}
     * @memberof UpdateProjectRequestDTO
     */
    productId: string;
    /**
     *
     * @type {string}
     * @memberof UpdateProjectRequestDTO
     */
    namespace: string;
}

/**
 *
 * @export
 * @interface UploadQuotasToProductsRequest
 */
export interface UploadQuotasToProductsRequest {
    /**
     *
     * @type {Array<ProductQuotasToTransfer>}
     * @memberof UploadQuotasToProductsRequest
     */
    products: Array<ProductQuotasToTransfer>;
}

/**
 *
 * @export
 * @interface V1CreateResourcePresetRequest
 */
export interface V1CreateResourcePresetRequest {
    /**
     *
     * @type {string}
     * @memberof V1CreateResourcePresetRequest
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof V1CreateResourcePresetRequest
     */
    type: V1CreateResourcePresetRequestTypeEnum;
    /**
     *
     * @type {number}
     * @memberof V1CreateResourcePresetRequest
     */
    vcpu: number;
    /**
     *
     * @type {number}
     * @memberof V1CreateResourcePresetRequest
     */
    ram: number;
}

export const V1CreateResourcePresetRequestTypeEnum = {
    CpuOptimized: 'cpu_optimized',
    Standard: 'standard',
    RamOptimized: 'ram_optimized',
} as const;

export type V1CreateResourcePresetRequestTypeEnum =
    (typeof V1CreateResourcePresetRequestTypeEnum)[keyof typeof V1CreateResourcePresetRequestTypeEnum];

/**
 *
 * @export
 * @interface V1ListResourcePresetsResponse
 */
export interface V1ListResourcePresetsResponse {
    /**
     *
     * @type {Array<V1ResourcePresetResponse>}
     * @memberof V1ListResourcePresetsResponse
     */
    resourcePresets: Array<V1ResourcePresetResponse>;
}

/**
 *
 * @export
 * @interface V1ResourcePresetResponse
 */
export interface V1ResourcePresetResponse {
    /**
     *
     * @type {string}
     * @memberof V1ResourcePresetResponse
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof V1ResourcePresetResponse
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof V1ResourcePresetResponse
     */
    type: V1ResourcePresetResponseTypeEnum;
    /**
     *
     * @type {number}
     * @memberof V1ResourcePresetResponse
     */
    vcpu: number;
    /**
     *
     * @type {number}
     * @memberof V1ResourcePresetResponse
     */
    ram: number;
}

export const V1ResourcePresetResponseTypeEnum = {
    CpuOptimized: 'cpu_optimized',
    Standard: 'standard',
    RamOptimized: 'ram_optimized',
} as const;

export type V1ResourcePresetResponseTypeEnum =
    (typeof V1ResourcePresetResponseTypeEnum)[keyof typeof V1ResourcePresetResponseTypeEnum];

/**
 *
 * @export
 * @interface V1UpdateResourcePresetRequest
 */
export interface V1UpdateResourcePresetRequest {
    /**
     *
     * @type {string}
     * @memberof V1UpdateResourcePresetRequest
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof V1UpdateResourcePresetRequest
     */
    type: V1UpdateResourcePresetRequestTypeEnum;
    /**
     *
     * @type {number}
     * @memberof V1UpdateResourcePresetRequest
     */
    vcpu: number;
    /**
     *
     * @type {number}
     * @memberof V1UpdateResourcePresetRequest
     */
    ram: number;
}

export const V1UpdateResourcePresetRequestTypeEnum = {
    CpuOptimized: 'cpu_optimized',
    Standard: 'standard',
    RamOptimized: 'ram_optimized',
} as const;

export type V1UpdateResourcePresetRequestTypeEnum =
    (typeof V1UpdateResourcePresetRequestTypeEnum)[keyof typeof V1UpdateResourcePresetRequestTypeEnum];

/**
 * AccountsApi - axios parameter creator
 * @export
 */
export const AccountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Add business role to account link
         * @param {string} accountId
         * @param {string} businessRoleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addBusinessRoleToAccount: async (
            accountId: string,
            businessRoleId: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('addBusinessRoleToAccount', 'accountId', accountId);
            // verify required parameter 'businessRoleId' is not null or undefined
            assertParamExists('addBusinessRoleToAccount', 'businessRoleId', businessRoleId);
            const localVarPath = `/api/v1/accounts/{accountId}/business-roles/{businessRoleId}`
                .replace(`{${'accountId'}}`, encodeURIComponent(String(accountId)))
                .replace(`{${'businessRoleId'}}`, encodeURIComponent(String(businessRoleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Add role to account link
         * @param {string} accountId
         * @param {string} roleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addRoleToAccount: async (
            accountId: string,
            roleId: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('addRoleToAccount', 'accountId', accountId);
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('addRoleToAccount', 'roleId', roleId);
            const localVarPath = `/api/v1/accounts/{accountId}/roles/{roleId}`
                .replace(`{${'accountId'}}`, encodeURIComponent(String(accountId)))
                .replace(`{${'roleId'}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create a new account
         * @param {AccountPostDTO} accountPostDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccount: async (
            accountPostDTO: AccountPostDTO,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'accountPostDTO' is not null or undefined
            assertParamExists('createAccount', 'accountPostDTO', accountPostDTO);
            const localVarPath = `/api/v1/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = serializeDataIfNeeded(
                accountPostDTO,
                localVarRequestOptions,
                configuration,
            );

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete an account by ID
         * @param {string} accountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccount: async (
            accountId: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('deleteAccount', 'accountId', accountId);
            const localVarPath = `/api/v1/accounts/{accountId}`.replace(
                `{${'accountId'}}`,
                encodeURIComponent(String(accountId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get account business roles
         * @param {string} accountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountBusinessRoles: async (
            accountId: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getAccountBusinessRoles', 'accountId', accountId);
            const localVarPath = `/api/v1/accounts/{accountId}/business-roles`.replace(
                `{${'accountId'}}`,
                encodeURIComponent(String(accountId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get account business roles History
         * @param {string} accountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountBusinessRolesHistory: async (
            accountId: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getAccountBusinessRolesHistory', 'accountId', accountId);
            const localVarPath = `/api/v1/accounts/{accountId}/business-roles-history`.replace(
                `{${'accountId'}}`,
                encodeURIComponent(String(accountId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get an account by ID
         * @param {string} accountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountById: async (
            accountId: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getAccountById', 'accountId', accountId);
            const localVarPath = `/api/v1/accounts/{accountId}`.replace(
                `{${'accountId'}}`,
                encodeURIComponent(String(accountId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get account organization-units
         * @param {string} accountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountOrganizationUnits: async (
            accountId: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getAccountOrganizationUnits', 'accountId', accountId);
            const localVarPath = `/api/v1/accounts/{accountId}/organization-units`.replace(
                `{${'accountId'}}`,
                encodeURIComponent(String(accountId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all account Permissions
         * @param {string} accountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountPermission: async (
            accountId: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getAccountPermission', 'accountId', accountId);
            const localVarPath = `/api/v1/accounts/{accountId}/permissions`.replace(
                `{${'accountId'}}`,
                encodeURIComponent(String(accountId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all account Permissions in bits
         * @param {string} accountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountPermissionBits: async (
            accountId: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getAccountPermissionBits', 'accountId', accountId);
            const localVarPath = `/api/v1/accounts/{accountId}/permissions-bits`.replace(
                `{${'accountId'}}`,
                encodeURIComponent(String(accountId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get account roles
         * @param {string} accountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountRoles: async (
            accountId: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getAccountRoles', 'accountId', accountId);
            const localVarPath = `/api/v1/accounts/{accountId}/roles`.replace(
                `{${'accountId'}}`,
                encodeURIComponent(String(accountId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get account roles History
         * @param {string} accountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountRolesHistory: async (
            accountId: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getAccountRolesHistory', 'accountId', accountId);
            const localVarPath = `/api/v1/accounts/{accountId}/roles-history`.replace(
                `{${'accountId'}}`,
                encodeURIComponent(String(accountId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all accounts
         * @param {string} [search]
         * @param {number} [limit]
         * @param {number} [offset]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAccounts: async (
            search?: string,
            limit?: number,
            offset?: number,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Remove Business Role from Account
         * @param {string} accountId
         * @param {string} businessRoleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeBusinessRoleFromAccount: async (
            accountId: string,
            businessRoleId: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('removeBusinessRoleFromAccount', 'accountId', accountId);
            // verify required parameter 'businessRoleId' is not null or undefined
            assertParamExists('removeBusinessRoleFromAccount', 'businessRoleId', businessRoleId);
            const localVarPath = `/api/v1/accounts/{accountId}/business-roles/{businessRoleId}`
                .replace(`{${'accountId'}}`, encodeURIComponent(String(accountId)))
                .replace(`{${'businessRoleId'}}`, encodeURIComponent(String(businessRoleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Remove Role from Account
         * @param {string} accountId
         * @param {string} roleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeRoleFromAccount: async (
            accountId: string,
            roleId: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('removeRoleFromAccount', 'accountId', accountId);
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('removeRoleFromAccount', 'roleId', roleId);
            const localVarPath = `/api/v1/accounts/{accountId}/roles/{roleId}`
                .replace(`{${'accountId'}}`, encodeURIComponent(String(accountId)))
                .replace(`{${'roleId'}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update an account by ID
         * @param {string} accountId
         * @param {AccountPostDTO} accountPostDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccount: async (
            accountId: string,
            accountPostDTO: AccountPostDTO,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('updateAccount', 'accountId', accountId);
            // verify required parameter 'accountPostDTO' is not null or undefined
            assertParamExists('updateAccount', 'accountPostDTO', accountPostDTO);
            const localVarPath = `/api/v1/accounts/{accountId}`.replace(
                `{${'accountId'}}`,
                encodeURIComponent(String(accountId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = serializeDataIfNeeded(
                accountPostDTO,
                localVarRequestOptions,
                configuration,
            );

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * AccountsApi - functional programming interface
 * @export
 */
export const AccountsApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountsApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Add business role to account link
         * @param {string} accountId
         * @param {string} businessRoleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addBusinessRoleToAccount(
            accountId: string,
            businessRoleId: string,
            options?: RawAxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addBusinessRoleToAccount(
                accountId,
                businessRoleId,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['AccountsApi.addBusinessRoleToAccount']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Add role to account link
         * @param {string} accountId
         * @param {string} roleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addRoleToAccount(
            accountId: string,
            roleId: string,
            options?: RawAxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addRoleToAccount(
                accountId,
                roleId,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['AccountsApi.addRoleToAccount']?.[localVarOperationServerIndex]
                    ?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Create a new account
         * @param {AccountPostDTO} accountPostDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAccount(
            accountPostDTO: AccountPostDTO,
            options?: RawAxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAccount(
                accountPostDTO,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['AccountsApi.createAccount']?.[localVarOperationServerIndex]
                    ?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Delete an account by ID
         * @param {string} accountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAccount(
            accountId: string,
            options?: RawAxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAccount(
                accountId,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['AccountsApi.deleteAccount']?.[localVarOperationServerIndex]
                    ?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get account business roles
         * @param {string} accountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountBusinessRoles(
            accountId: string,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BusinessRoleDTO>>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountBusinessRoles(
                accountId,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['AccountsApi.getAccountBusinessRoles']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get account business roles History
         * @param {string} accountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountBusinessRolesHistory(
            accountId: string,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (
                axios?: AxiosInstance,
                basePath?: string,
            ) => AxiosPromise<Array<AccountBusinessRolesHistoryDTO>>
        > {
            const localVarAxiosArgs =
                await localVarAxiosParamCreator.getAccountBusinessRolesHistory(accountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['AccountsApi.getAccountBusinessRolesHistory']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get an account by ID
         * @param {string} accountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountById(
            accountId: string,
            options?: RawAxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountById(
                accountId,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['AccountsApi.getAccountById']?.[localVarOperationServerIndex]
                    ?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get account organization-units
         * @param {string} accountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountOrganizationUnits(
            accountId: string,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationUnitDTO>>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountOrganizationUnits(
                accountId,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['AccountsApi.getAccountOrganizationUnits']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get all account Permissions
         * @param {string} accountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountPermission(
            accountId: string,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (
                axios?: AxiosInstance,
                basePath?: string,
            ) => AxiosPromise<Array<RoleWithPermissionsDTO>>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountPermission(
                accountId,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['AccountsApi.getAccountPermission']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get all account Permissions in bits
         * @param {string} accountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountPermissionBits(
            accountId: string,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (
                axios?: AxiosInstance,
                basePath?: string,
            ) => AxiosPromise<{
                [key: string]: {[key: string]: object};
            }>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountPermissionBits(
                accountId,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['AccountsApi.getAccountPermissionBits']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get account roles
         * @param {string} accountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountRoles(
            accountId: string,
            options?: RawAxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoleDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountRoles(
                accountId,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['AccountsApi.getAccountRoles']?.[localVarOperationServerIndex]
                    ?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get account roles History
         * @param {string} accountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountRolesHistory(
            accountId: string,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (
                axios?: AxiosInstance,
                basePath?: string,
            ) => AxiosPromise<Array<AccountRolesHistoryDTO>>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountRolesHistory(
                accountId,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['AccountsApi.getAccountRolesHistory']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get all accounts
         * @param {string} [search]
         * @param {number} [limit]
         * @param {number} [offset]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllAccounts(
            search?: string,
            limit?: number,
            offset?: number,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedAccountResponse>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllAccounts(
                search,
                limit,
                offset,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['AccountsApi.getAllAccounts']?.[localVarOperationServerIndex]
                    ?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Remove Business Role from Account
         * @param {string} accountId
         * @param {string} businessRoleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeBusinessRoleFromAccount(
            accountId: string,
            businessRoleId: string,
            options?: RawAxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeBusinessRoleFromAccount(
                accountId,
                businessRoleId,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['AccountsApi.removeBusinessRoleFromAccount']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Remove Role from Account
         * @param {string} accountId
         * @param {string} roleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeRoleFromAccount(
            accountId: string,
            roleId: string,
            options?: RawAxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeRoleFromAccount(
                accountId,
                roleId,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['AccountsApi.removeRoleFromAccount']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Update an account by ID
         * @param {string} accountId
         * @param {AccountPostDTO} accountPostDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAccount(
            accountId: string,
            accountPostDTO: AccountPostDTO,
            options?: RawAxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAccount(
                accountId,
                accountPostDTO,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['AccountsApi.updateAccount']?.[localVarOperationServerIndex]
                    ?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
    };
};

/**
 * AccountsApi - factory interface
 * @export
 */
export const AccountsApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = AccountsApiFp(configuration);
    return {
        /**
         *
         * @summary Add business role to account link
         * @param {AccountsApiAddBusinessRoleToAccountRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addBusinessRoleToAccount(
            requestParameters: AccountsApiAddBusinessRoleToAccountRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .addBusinessRoleToAccount(
                    requestParameters.accountId,
                    requestParameters.businessRoleId,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Add role to account link
         * @param {AccountsApiAddRoleToAccountRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addRoleToAccount(
            requestParameters: AccountsApiAddRoleToAccountRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .addRoleToAccount(requestParameters.accountId, requestParameters.roleId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Create a new account
         * @param {AccountsApiCreateAccountRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccount(
            requestParameters: AccountsApiCreateAccountRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<AccountDTO> {
            return localVarFp
                .createAccount(requestParameters.accountPostDTO, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete an account by ID
         * @param {AccountsApiDeleteAccountRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccount(
            requestParameters: AccountsApiDeleteAccountRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .deleteAccount(requestParameters.accountId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get account business roles
         * @param {AccountsApiGetAccountBusinessRolesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountBusinessRoles(
            requestParameters: AccountsApiGetAccountBusinessRolesRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<Array<BusinessRoleDTO>> {
            return localVarFp
                .getAccountBusinessRoles(requestParameters.accountId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get account business roles History
         * @param {AccountsApiGetAccountBusinessRolesHistoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountBusinessRolesHistory(
            requestParameters: AccountsApiGetAccountBusinessRolesHistoryRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<Array<AccountBusinessRolesHistoryDTO>> {
            return localVarFp
                .getAccountBusinessRolesHistory(requestParameters.accountId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get an account by ID
         * @param {AccountsApiGetAccountByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountById(
            requestParameters: AccountsApiGetAccountByIdRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<AccountDTO> {
            return localVarFp
                .getAccountById(requestParameters.accountId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get account organization-units
         * @param {AccountsApiGetAccountOrganizationUnitsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountOrganizationUnits(
            requestParameters: AccountsApiGetAccountOrganizationUnitsRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<Array<OrganizationUnitDTO>> {
            return localVarFp
                .getAccountOrganizationUnits(requestParameters.accountId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get all account Permissions
         * @param {AccountsApiGetAccountPermissionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountPermission(
            requestParameters: AccountsApiGetAccountPermissionRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<Array<RoleWithPermissionsDTO>> {
            return localVarFp
                .getAccountPermission(requestParameters.accountId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get all account Permissions in bits
         * @param {AccountsApiGetAccountPermissionBitsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountPermissionBits(
            requestParameters: AccountsApiGetAccountPermissionBitsRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<{
            [key: string]: {[key: string]: object};
        }> {
            return localVarFp
                .getAccountPermissionBits(requestParameters.accountId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get account roles
         * @param {AccountsApiGetAccountRolesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountRoles(
            requestParameters: AccountsApiGetAccountRolesRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<Array<RoleDTO>> {
            return localVarFp
                .getAccountRoles(requestParameters.accountId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get account roles History
         * @param {AccountsApiGetAccountRolesHistoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountRolesHistory(
            requestParameters: AccountsApiGetAccountRolesHistoryRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<Array<AccountRolesHistoryDTO>> {
            return localVarFp
                .getAccountRolesHistory(requestParameters.accountId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get all accounts
         * @param {AccountsApiGetAllAccountsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAccounts(
            requestParameters: AccountsApiGetAllAccountsRequest = {},
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<PaginatedAccountResponse> {
            return localVarFp
                .getAllAccounts(
                    requestParameters.search,
                    requestParameters.limit,
                    requestParameters.offset,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Remove Business Role from Account
         * @param {AccountsApiRemoveBusinessRoleFromAccountRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeBusinessRoleFromAccount(
            requestParameters: AccountsApiRemoveBusinessRoleFromAccountRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .removeBusinessRoleFromAccount(
                    requestParameters.accountId,
                    requestParameters.businessRoleId,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Remove Role from Account
         * @param {AccountsApiRemoveRoleFromAccountRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeRoleFromAccount(
            requestParameters: AccountsApiRemoveRoleFromAccountRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .removeRoleFromAccount(
                    requestParameters.accountId,
                    requestParameters.roleId,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update an account by ID
         * @param {AccountsApiUpdateAccountRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccount(
            requestParameters: AccountsApiUpdateAccountRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<AccountDTO> {
            return localVarFp
                .updateAccount(
                    requestParameters.accountId,
                    requestParameters.accountPostDTO,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addBusinessRoleToAccount operation in AccountsApi.
 * @export
 * @interface AccountsApiAddBusinessRoleToAccountRequest
 */
export interface AccountsApiAddBusinessRoleToAccountRequest {
    /**
     *
     * @type {string}
     * @memberof AccountsApiAddBusinessRoleToAccount
     */
    readonly accountId: string;

    /**
     *
     * @type {string}
     * @memberof AccountsApiAddBusinessRoleToAccount
     */
    readonly businessRoleId: string;
}

/**
 * Request parameters for addRoleToAccount operation in AccountsApi.
 * @export
 * @interface AccountsApiAddRoleToAccountRequest
 */
export interface AccountsApiAddRoleToAccountRequest {
    /**
     *
     * @type {string}
     * @memberof AccountsApiAddRoleToAccount
     */
    readonly accountId: string;

    /**
     *
     * @type {string}
     * @memberof AccountsApiAddRoleToAccount
     */
    readonly roleId: string;
}

/**
 * Request parameters for createAccount operation in AccountsApi.
 * @export
 * @interface AccountsApiCreateAccountRequest
 */
export interface AccountsApiCreateAccountRequest {
    /**
     *
     * @type {AccountPostDTO}
     * @memberof AccountsApiCreateAccount
     */
    readonly accountPostDTO: AccountPostDTO;
}

/**
 * Request parameters for deleteAccount operation in AccountsApi.
 * @export
 * @interface AccountsApiDeleteAccountRequest
 */
export interface AccountsApiDeleteAccountRequest {
    /**
     *
     * @type {string}
     * @memberof AccountsApiDeleteAccount
     */
    readonly accountId: string;
}

/**
 * Request parameters for getAccountBusinessRoles operation in AccountsApi.
 * @export
 * @interface AccountsApiGetAccountBusinessRolesRequest
 */
export interface AccountsApiGetAccountBusinessRolesRequest {
    /**
     *
     * @type {string}
     * @memberof AccountsApiGetAccountBusinessRoles
     */
    readonly accountId: string;
}

/**
 * Request parameters for getAccountBusinessRolesHistory operation in AccountsApi.
 * @export
 * @interface AccountsApiGetAccountBusinessRolesHistoryRequest
 */
export interface AccountsApiGetAccountBusinessRolesHistoryRequest {
    /**
     *
     * @type {string}
     * @memberof AccountsApiGetAccountBusinessRolesHistory
     */
    readonly accountId: string;
}

/**
 * Request parameters for getAccountById operation in AccountsApi.
 * @export
 * @interface AccountsApiGetAccountByIdRequest
 */
export interface AccountsApiGetAccountByIdRequest {
    /**
     *
     * @type {string}
     * @memberof AccountsApiGetAccountById
     */
    readonly accountId: string;
}

/**
 * Request parameters for getAccountOrganizationUnits operation in AccountsApi.
 * @export
 * @interface AccountsApiGetAccountOrganizationUnitsRequest
 */
export interface AccountsApiGetAccountOrganizationUnitsRequest {
    /**
     *
     * @type {string}
     * @memberof AccountsApiGetAccountOrganizationUnits
     */
    readonly accountId: string;
}

/**
 * Request parameters for getAccountPermission operation in AccountsApi.
 * @export
 * @interface AccountsApiGetAccountPermissionRequest
 */
export interface AccountsApiGetAccountPermissionRequest {
    /**
     *
     * @type {string}
     * @memberof AccountsApiGetAccountPermission
     */
    readonly accountId: string;
}

/**
 * Request parameters for getAccountPermissionBits operation in AccountsApi.
 * @export
 * @interface AccountsApiGetAccountPermissionBitsRequest
 */
export interface AccountsApiGetAccountPermissionBitsRequest {
    /**
     *
     * @type {string}
     * @memberof AccountsApiGetAccountPermissionBits
     */
    readonly accountId: string;
}

/**
 * Request parameters for getAccountRoles operation in AccountsApi.
 * @export
 * @interface AccountsApiGetAccountRolesRequest
 */
export interface AccountsApiGetAccountRolesRequest {
    /**
     *
     * @type {string}
     * @memberof AccountsApiGetAccountRoles
     */
    readonly accountId: string;
}

/**
 * Request parameters for getAccountRolesHistory operation in AccountsApi.
 * @export
 * @interface AccountsApiGetAccountRolesHistoryRequest
 */
export interface AccountsApiGetAccountRolesHistoryRequest {
    /**
     *
     * @type {string}
     * @memberof AccountsApiGetAccountRolesHistory
     */
    readonly accountId: string;
}

/**
 * Request parameters for getAllAccounts operation in AccountsApi.
 * @export
 * @interface AccountsApiGetAllAccountsRequest
 */
export interface AccountsApiGetAllAccountsRequest {
    /**
     *
     * @type {string}
     * @memberof AccountsApiGetAllAccounts
     */
    readonly search?: string;

    /**
     *
     * @type {number}
     * @memberof AccountsApiGetAllAccounts
     */
    readonly limit?: number;

    /**
     *
     * @type {number}
     * @memberof AccountsApiGetAllAccounts
     */
    readonly offset?: number;
}

/**
 * Request parameters for removeBusinessRoleFromAccount operation in AccountsApi.
 * @export
 * @interface AccountsApiRemoveBusinessRoleFromAccountRequest
 */
export interface AccountsApiRemoveBusinessRoleFromAccountRequest {
    /**
     *
     * @type {string}
     * @memberof AccountsApiRemoveBusinessRoleFromAccount
     */
    readonly accountId: string;

    /**
     *
     * @type {string}
     * @memberof AccountsApiRemoveBusinessRoleFromAccount
     */
    readonly businessRoleId: string;
}

/**
 * Request parameters for removeRoleFromAccount operation in AccountsApi.
 * @export
 * @interface AccountsApiRemoveRoleFromAccountRequest
 */
export interface AccountsApiRemoveRoleFromAccountRequest {
    /**
     *
     * @type {string}
     * @memberof AccountsApiRemoveRoleFromAccount
     */
    readonly accountId: string;

    /**
     *
     * @type {string}
     * @memberof AccountsApiRemoveRoleFromAccount
     */
    readonly roleId: string;
}

/**
 * Request parameters for updateAccount operation in AccountsApi.
 * @export
 * @interface AccountsApiUpdateAccountRequest
 */
export interface AccountsApiUpdateAccountRequest {
    /**
     *
     * @type {string}
     * @memberof AccountsApiUpdateAccount
     */
    readonly accountId: string;

    /**
     *
     * @type {AccountPostDTO}
     * @memberof AccountsApiUpdateAccount
     */
    readonly accountPostDTO: AccountPostDTO;
}

/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
export class AccountsApi extends BaseAPI {
    /**
     *
     * @summary Add business role to account link
     * @param {AccountsApiAddBusinessRoleToAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public addBusinessRoleToAccount(
        requestParameters: AccountsApiAddBusinessRoleToAccountRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return AccountsApiFp(this.configuration)
            .addBusinessRoleToAccount(
                requestParameters.accountId,
                requestParameters.businessRoleId,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Add role to account link
     * @param {AccountsApiAddRoleToAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public addRoleToAccount(
        requestParameters: AccountsApiAddRoleToAccountRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return AccountsApiFp(this.configuration)
            .addRoleToAccount(requestParameters.accountId, requestParameters.roleId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Create a new account
     * @param {AccountsApiCreateAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public createAccount(
        requestParameters: AccountsApiCreateAccountRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return AccountsApiFp(this.configuration)
            .createAccount(requestParameters.accountPostDTO, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Delete an account by ID
     * @param {AccountsApiDeleteAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public deleteAccount(
        requestParameters: AccountsApiDeleteAccountRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return AccountsApiFp(this.configuration)
            .deleteAccount(requestParameters.accountId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get account business roles
     * @param {AccountsApiGetAccountBusinessRolesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAccountBusinessRoles(
        requestParameters: AccountsApiGetAccountBusinessRolesRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return AccountsApiFp(this.configuration)
            .getAccountBusinessRoles(requestParameters.accountId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get account business roles History
     * @param {AccountsApiGetAccountBusinessRolesHistoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAccountBusinessRolesHistory(
        requestParameters: AccountsApiGetAccountBusinessRolesHistoryRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return AccountsApiFp(this.configuration)
            .getAccountBusinessRolesHistory(requestParameters.accountId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get an account by ID
     * @param {AccountsApiGetAccountByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAccountById(
        requestParameters: AccountsApiGetAccountByIdRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return AccountsApiFp(this.configuration)
            .getAccountById(requestParameters.accountId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get account organization-units
     * @param {AccountsApiGetAccountOrganizationUnitsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAccountOrganizationUnits(
        requestParameters: AccountsApiGetAccountOrganizationUnitsRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return AccountsApiFp(this.configuration)
            .getAccountOrganizationUnits(requestParameters.accountId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get all account Permissions
     * @param {AccountsApiGetAccountPermissionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAccountPermission(
        requestParameters: AccountsApiGetAccountPermissionRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return AccountsApiFp(this.configuration)
            .getAccountPermission(requestParameters.accountId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get all account Permissions in bits
     * @param {AccountsApiGetAccountPermissionBitsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAccountPermissionBits(
        requestParameters: AccountsApiGetAccountPermissionBitsRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return AccountsApiFp(this.configuration)
            .getAccountPermissionBits(requestParameters.accountId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get account roles
     * @param {AccountsApiGetAccountRolesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAccountRoles(
        requestParameters: AccountsApiGetAccountRolesRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return AccountsApiFp(this.configuration)
            .getAccountRoles(requestParameters.accountId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get account roles History
     * @param {AccountsApiGetAccountRolesHistoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAccountRolesHistory(
        requestParameters: AccountsApiGetAccountRolesHistoryRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return AccountsApiFp(this.configuration)
            .getAccountRolesHistory(requestParameters.accountId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get all accounts
     * @param {AccountsApiGetAllAccountsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAllAccounts(
        requestParameters: AccountsApiGetAllAccountsRequest = {},
        options?: RawAxiosRequestConfig,
    ) {
        return AccountsApiFp(this.configuration)
            .getAllAccounts(
                requestParameters.search,
                requestParameters.limit,
                requestParameters.offset,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Remove Business Role from Account
     * @param {AccountsApiRemoveBusinessRoleFromAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public removeBusinessRoleFromAccount(
        requestParameters: AccountsApiRemoveBusinessRoleFromAccountRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return AccountsApiFp(this.configuration)
            .removeBusinessRoleFromAccount(
                requestParameters.accountId,
                requestParameters.businessRoleId,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Remove Role from Account
     * @param {AccountsApiRemoveRoleFromAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public removeRoleFromAccount(
        requestParameters: AccountsApiRemoveRoleFromAccountRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return AccountsApiFp(this.configuration)
            .removeRoleFromAccount(requestParameters.accountId, requestParameters.roleId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Update an account by ID
     * @param {AccountsApiUpdateAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public updateAccount(
        requestParameters: AccountsApiUpdateAccountRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return AccountsApiFp(this.configuration)
            .updateAccount(requestParameters.accountId, requestParameters.accountPostDTO, options)
            .then((request) => request(this.axios, this.basePath));
    }
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Обновление access токена
         * @param {AuthRequestDTO} authRequestDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateServiceToken: async (
            authRequestDTO: AuthRequestDTO,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'authRequestDTO' is not null or undefined
            assertParamExists('generateServiceToken', 'authRequestDTO', authRequestDTO);
            const localVarPath = `/api/v1/auth/service-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = serializeDataIfNeeded(
                authRequestDTO,
                localVarRequestOptions,
                configuration,
            );

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Получение информации о текущем пользователе
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/auth/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Аутентификация пользователя
         * @param {AuthRequestDTO} authRequestDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (
            authRequestDTO: AuthRequestDTO,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'authRequestDTO' is not null or undefined
            assertParamExists('login', 'authRequestDTO', authRequestDTO);
            const localVarPath = `/api/v1/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = serializeDataIfNeeded(
                authRequestDTO,
                localVarRequestOptions,
                configuration,
            );

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Выход пользователя из системы
         * @param {RefreshTokenDTO} refreshTokenDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout: async (
            refreshTokenDTO: RefreshTokenDTO,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'refreshTokenDTO' is not null or undefined
            assertParamExists('logout', 'refreshTokenDTO', refreshTokenDTO);
            const localVarPath = `/api/v1/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = serializeDataIfNeeded(
                refreshTokenDTO,
                localVarRequestOptions,
                configuration,
            );

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Обновление access токена
         * @param {RefreshTokenDTO} refreshTokenDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken: async (
            refreshTokenDTO: RefreshTokenDTO,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'refreshTokenDTO' is not null or undefined
            assertParamExists('refreshToken', 'refreshTokenDTO', refreshTokenDTO);
            const localVarPath = `/api/v1/auth/refresh-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = serializeDataIfNeeded(
                refreshTokenDTO,
                localVarRequestOptions,
                configuration,
            );

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Обновление access токена
         * @param {AuthRequestDTO} authRequestDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateServiceToken(
            authRequestDTO: AuthRequestDTO,
            options?: RawAxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JwtResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateServiceToken(
                authRequestDTO,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['AuthApi.generateServiceToken']?.[localVarOperationServerIndex]
                    ?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Получение информации о текущем пользователе
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrentUser(
            options?: RawAxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCurrentUser200Response>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentUser(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['AuthApi.getCurrentUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Аутентификация пользователя
         * @param {AuthRequestDTO} authRequestDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(
            authRequestDTO: AuthRequestDTO,
            options?: RawAxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JwtResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(
                authRequestDTO,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['AuthApi.login']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Выход пользователя из системы
         * @param {RefreshTokenDTO} refreshTokenDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logout(
            refreshTokenDTO: RefreshTokenDTO,
            options?: RawAxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logout(
                refreshTokenDTO,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['AuthApi.logout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Обновление access токена
         * @param {RefreshTokenDTO} refreshTokenDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshToken(
            refreshTokenDTO: RefreshTokenDTO,
            options?: RawAxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JwtResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshToken(
                refreshTokenDTO,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['AuthApi.refreshToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
    };
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = AuthApiFp(configuration);
    return {
        /**
         *
         * @summary Обновление access токена
         * @param {AuthApiGenerateServiceTokenRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateServiceToken(
            requestParameters: AuthApiGenerateServiceTokenRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<JwtResponseDTO> {
            return localVarFp
                .generateServiceToken(requestParameters.authRequestDTO, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Получение информации о текущем пользователе
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser(options?: RawAxiosRequestConfig): AxiosPromise<GetCurrentUser200Response> {
            return localVarFp.getCurrentUser(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Аутентификация пользователя
         * @param {AuthApiLoginRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(
            requestParameters: AuthApiLoginRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<JwtResponseDTO> {
            return localVarFp
                .login(requestParameters.authRequestDTO, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Выход пользователя из системы
         * @param {AuthApiLogoutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(
            requestParameters: AuthApiLogoutRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .logout(requestParameters.refreshTokenDTO, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Обновление access токена
         * @param {AuthApiRefreshTokenRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken(
            requestParameters: AuthApiRefreshTokenRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<JwtResponseDTO> {
            return localVarFp
                .refreshToken(requestParameters.refreshTokenDTO, options)
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for generateServiceToken operation in AuthApi.
 * @export
 * @interface AuthApiGenerateServiceTokenRequest
 */
export interface AuthApiGenerateServiceTokenRequest {
    /**
     *
     * @type {AuthRequestDTO}
     * @memberof AuthApiGenerateServiceToken
     */
    readonly authRequestDTO: AuthRequestDTO;
}

/**
 * Request parameters for login operation in AuthApi.
 * @export
 * @interface AuthApiLoginRequest
 */
export interface AuthApiLoginRequest {
    /**
     *
     * @type {AuthRequestDTO}
     * @memberof AuthApiLogin
     */
    readonly authRequestDTO: AuthRequestDTO;
}

/**
 * Request parameters for logout operation in AuthApi.
 * @export
 * @interface AuthApiLogoutRequest
 */
export interface AuthApiLogoutRequest {
    /**
     *
     * @type {RefreshTokenDTO}
     * @memberof AuthApiLogout
     */
    readonly refreshTokenDTO: RefreshTokenDTO;
}

/**
 * Request parameters for refreshToken operation in AuthApi.
 * @export
 * @interface AuthApiRefreshTokenRequest
 */
export interface AuthApiRefreshTokenRequest {
    /**
     *
     * @type {RefreshTokenDTO}
     * @memberof AuthApiRefreshToken
     */
    readonly refreshTokenDTO: RefreshTokenDTO;
}

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     *
     * @summary Обновление access токена
     * @param {AuthApiGenerateServiceTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public generateServiceToken(
        requestParameters: AuthApiGenerateServiceTokenRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return AuthApiFp(this.configuration)
            .generateServiceToken(requestParameters.authRequestDTO, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Получение информации о текущем пользователе
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public getCurrentUser(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration)
            .getCurrentUser(options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Аутентификация пользователя
     * @param {AuthApiLoginRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public login(requestParameters: AuthApiLoginRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration)
            .login(requestParameters.authRequestDTO, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Выход пользователя из системы
     * @param {AuthApiLogoutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public logout(requestParameters: AuthApiLogoutRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration)
            .logout(requestParameters.refreshTokenDTO, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Обновление access токена
     * @param {AuthApiRefreshTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public refreshToken(
        requestParameters: AuthApiRefreshTokenRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return AuthApiFp(this.configuration)
            .refreshToken(requestParameters.refreshTokenDTO, options)
            .then((request) => request(this.axios, this.basePath));
    }
}

/**
 * BillingApi - axios parameter creator
 * @export
 */
export const BillingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Get product quota usage report
         * @param {string} productId
         * @param {string} startDate
         * @param {string} endDate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductQuotaUsageReport: async (
            productId: string,
            startDate: string,
            endDate: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('getProductQuotaUsageReport', 'productId', productId);
            // verify required parameter 'startDate' is not null or undefined
            assertParamExists('getProductQuotaUsageReport', 'startDate', startDate);
            // verify required parameter 'endDate' is not null or undefined
            assertParamExists('getProductQuotaUsageReport', 'endDate', endDate);
            const localVarPath = `/api/billing/product-quota-usage-report`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            if (productId !== undefined) {
                localVarQueryParameter['productId'] = productId;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] =
                    (startDate as any) instanceof Date
                        ? (startDate as any).toISOString().substring(0, 10)
                        : startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] =
                    (endDate as any) instanceof Date
                        ? (endDate as any).toISOString().substring(0, 10)
                        : endDate;
            }

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * BillingApi - functional programming interface
 * @export
 */
export const BillingApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = BillingApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Get product quota usage report
         * @param {string} productId
         * @param {string} startDate
         * @param {string} endDate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductQuotaUsageReport(
            productId: string,
            startDate: string,
            endDate: string,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (
                axios?: AxiosInstance,
                basePath?: string,
            ) => AxiosPromise<GetProductQuotaUsageReportResponseOA>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProductQuotaUsageReport(
                productId,
                startDate,
                endDate,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['BillingApi.getProductQuotaUsageReport']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
    };
};

/**
 * BillingApi - factory interface
 * @export
 */
export const BillingApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = BillingApiFp(configuration);
    return {
        /**
         *
         * @summary Get product quota usage report
         * @param {BillingApiGetProductQuotaUsageReportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductQuotaUsageReport(
            requestParameters: BillingApiGetProductQuotaUsageReportRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<GetProductQuotaUsageReportResponseOA> {
            return localVarFp
                .getProductQuotaUsageReport(
                    requestParameters.productId,
                    requestParameters.startDate,
                    requestParameters.endDate,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getProductQuotaUsageReport operation in BillingApi.
 * @export
 * @interface BillingApiGetProductQuotaUsageReportRequest
 */
export interface BillingApiGetProductQuotaUsageReportRequest {
    /**
     *
     * @type {string}
     * @memberof BillingApiGetProductQuotaUsageReport
     */
    readonly productId: string;

    /**
     *
     * @type {string}
     * @memberof BillingApiGetProductQuotaUsageReport
     */
    readonly startDate: string;

    /**
     *
     * @type {string}
     * @memberof BillingApiGetProductQuotaUsageReport
     */
    readonly endDate: string;
}

/**
 * BillingApi - object-oriented interface
 * @export
 * @class BillingApi
 * @extends {BaseAPI}
 */
export class BillingApi extends BaseAPI {
    /**
     *
     * @summary Get product quota usage report
     * @param {BillingApiGetProductQuotaUsageReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getProductQuotaUsageReport(
        requestParameters: BillingApiGetProductQuotaUsageReportRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return BillingApiFp(this.configuration)
            .getProductQuotaUsageReport(
                requestParameters.productId,
                requestParameters.startDate,
                requestParameters.endDate,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }
}

/**
 * BusinessRolesApi - axios parameter creator
 * @export
 */
export const BusinessRolesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Add role to the business role link
         * @param {string} businessRoleId
         * @param {string} roleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addRoleToBusinessRole: async (
            businessRoleId: string,
            roleId: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'businessRoleId' is not null or undefined
            assertParamExists('addRoleToBusinessRole', 'businessRoleId', businessRoleId);
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('addRoleToBusinessRole', 'roleId', roleId);
            const localVarPath = `/api/v1/business-roles/{businessRoleId}/roles/{roleId}`
                .replace(`{${'businessRoleId'}}`, encodeURIComponent(String(businessRoleId)))
                .replace(`{${'roleId'}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create a new business role
         * @param {BusinessRolePostDTO} businessRolePostDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBusinessRole: async (
            businessRolePostDTO: BusinessRolePostDTO,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'businessRolePostDTO' is not null or undefined
            assertParamExists('createBusinessRole', 'businessRolePostDTO', businessRolePostDTO);
            const localVarPath = `/api/v1/business-roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = serializeDataIfNeeded(
                businessRolePostDTO,
                localVarRequestOptions,
                configuration,
            );

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a business role by ID
         * @param {string} businessRoleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBusinessRole: async (
            businessRoleId: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'businessRoleId' is not null or undefined
            assertParamExists('deleteBusinessRole', 'businessRoleId', businessRoleId);
            const localVarPath = `/api/v1/business-roles/{businessRoleId}`.replace(
                `{${'businessRoleId'}}`,
                encodeURIComponent(String(businessRoleId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all business roles
         * @param {string} [search]
         * @param {number} [limit]
         * @param {number} [offset]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllBusinessRoles: async (
            search?: string,
            limit?: number,
            offset?: number,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/business-roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a business role by ID
         * @param {string} businessRoleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessRoleById: async (
            businessRoleId: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'businessRoleId' is not null or undefined
            assertParamExists('getBusinessRoleById', 'businessRoleId', businessRoleId);
            const localVarPath = `/api/v1/business-roles/{businessRoleId}`.replace(
                `{${'businessRoleId'}}`,
                encodeURIComponent(String(businessRoleId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a business role children business roles
         * @param {string} businessRoleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessRoleChildrenBRs: async (
            businessRoleId: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'businessRoleId' is not null or undefined
            assertParamExists('getBusinessRoleChildrenBRs', 'businessRoleId', businessRoleId);
            const localVarPath = `/api/v1/business-roles/{businessRoleId}/children`.replace(
                `{${'businessRoleId'}}`,
                encodeURIComponent(String(businessRoleId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a business role parents business roles
         * @param {string} businessRoleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessRoleParentsBRs: async (
            businessRoleId: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'businessRoleId' is not null or undefined
            assertParamExists('getBusinessRoleParentsBRs', 'businessRoleId', businessRoleId);
            const localVarPath = `/api/v1/business-roles/{businessRoleId}/parents`.replace(
                `{${'businessRoleId'}}`,
                encodeURIComponent(String(businessRoleId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get business role roles
         * @param {string} businessRoleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRolesByBusinessRoleId: async (
            businessRoleId: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'businessRoleId' is not null or undefined
            assertParamExists('getRolesByBusinessRoleId', 'businessRoleId', businessRoleId);
            const localVarPath = `/api/v1/business-roles/{businessRoleId}/roles`.replace(
                `{${'businessRoleId'}}`,
                encodeURIComponent(String(businessRoleId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete role to the business role link
         * @param {string} businessRoleId
         * @param {string} roleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeRoleFromBusinessRole: async (
            businessRoleId: string,
            roleId: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'businessRoleId' is not null or undefined
            assertParamExists('removeRoleFromBusinessRole', 'businessRoleId', businessRoleId);
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('removeRoleFromBusinessRole', 'roleId', roleId);
            const localVarPath = `/api/v1/business-roles/{businessRoleId}/roles/{roleId}`
                .replace(`{${'businessRoleId'}}`, encodeURIComponent(String(businessRoleId)))
                .replace(`{${'roleId'}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update a business role by ID
         * @param {string} businessRoleId
         * @param {BusinessRolePostDTO} businessRolePostDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBusinessRole: async (
            businessRoleId: string,
            businessRolePostDTO: BusinessRolePostDTO,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'businessRoleId' is not null or undefined
            assertParamExists('updateBusinessRole', 'businessRoleId', businessRoleId);
            // verify required parameter 'businessRolePostDTO' is not null or undefined
            assertParamExists('updateBusinessRole', 'businessRolePostDTO', businessRolePostDTO);
            const localVarPath = `/api/v1/business-roles/{businessRoleId}`.replace(
                `{${'businessRoleId'}}`,
                encodeURIComponent(String(businessRoleId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = serializeDataIfNeeded(
                businessRolePostDTO,
                localVarRequestOptions,
                configuration,
            );

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * BusinessRolesApi - functional programming interface
 * @export
 */
export const BusinessRolesApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = BusinessRolesApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Add role to the business role link
         * @param {string} businessRoleId
         * @param {string} roleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addRoleToBusinessRole(
            businessRoleId: string,
            roleId: string,
            options?: RawAxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addRoleToBusinessRole(
                businessRoleId,
                roleId,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['BusinessRolesApi.addRoleToBusinessRole']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Create a new business role
         * @param {BusinessRolePostDTO} businessRolePostDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBusinessRole(
            businessRolePostDTO: BusinessRolePostDTO,
            options?: RawAxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BusinessRoleDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBusinessRole(
                businessRolePostDTO,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['BusinessRolesApi.createBusinessRole']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Delete a business role by ID
         * @param {string} businessRoleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBusinessRole(
            businessRoleId: string,
            options?: RawAxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBusinessRole(
                businessRoleId,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['BusinessRolesApi.deleteBusinessRole']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get all business roles
         * @param {string} [search]
         * @param {number} [limit]
         * @param {number} [offset]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllBusinessRoles(
            search?: string,
            limit?: number,
            offset?: number,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (
                axios?: AxiosInstance,
                basePath?: string,
            ) => AxiosPromise<PaginatedBusinessRoleResponse>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllBusinessRoles(
                search,
                limit,
                offset,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['BusinessRolesApi.getAllBusinessRoles']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get a business role by ID
         * @param {string} businessRoleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBusinessRoleById(
            businessRoleId: string,
            options?: RawAxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BusinessRoleDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBusinessRoleById(
                businessRoleId,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['BusinessRolesApi.getBusinessRoleById']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get a business role children business roles
         * @param {string} businessRoleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBusinessRoleChildrenBRs(
            businessRoleId: string,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BusinessRoleDTO>>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBusinessRoleChildrenBRs(
                businessRoleId,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['BusinessRolesApi.getBusinessRoleChildrenBRs']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get a business role parents business roles
         * @param {string} businessRoleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBusinessRoleParentsBRs(
            businessRoleId: string,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BusinessRoleDTO>>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBusinessRoleParentsBRs(
                businessRoleId,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['BusinessRolesApi.getBusinessRoleParentsBRs']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get business role roles
         * @param {string} businessRoleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRolesByBusinessRoleId(
            businessRoleId: string,
            options?: RawAxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoleDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRolesByBusinessRoleId(
                businessRoleId,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['BusinessRolesApi.getRolesByBusinessRoleId']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Delete role to the business role link
         * @param {string} businessRoleId
         * @param {string} roleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeRoleFromBusinessRole(
            businessRoleId: string,
            roleId: string,
            options?: RawAxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeRoleFromBusinessRole(
                businessRoleId,
                roleId,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['BusinessRolesApi.removeRoleFromBusinessRole']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Update a business role by ID
         * @param {string} businessRoleId
         * @param {BusinessRolePostDTO} businessRolePostDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBusinessRole(
            businessRoleId: string,
            businessRolePostDTO: BusinessRolePostDTO,
            options?: RawAxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BusinessRoleDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateBusinessRole(
                businessRoleId,
                businessRolePostDTO,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['BusinessRolesApi.updateBusinessRole']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
    };
};

/**
 * BusinessRolesApi - factory interface
 * @export
 */
export const BusinessRolesApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = BusinessRolesApiFp(configuration);
    return {
        /**
         *
         * @summary Add role to the business role link
         * @param {BusinessRolesApiAddRoleToBusinessRoleRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addRoleToBusinessRole(
            requestParameters: BusinessRolesApiAddRoleToBusinessRoleRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .addRoleToBusinessRole(
                    requestParameters.businessRoleId,
                    requestParameters.roleId,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Create a new business role
         * @param {BusinessRolesApiCreateBusinessRoleRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBusinessRole(
            requestParameters: BusinessRolesApiCreateBusinessRoleRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<BusinessRoleDTO> {
            return localVarFp
                .createBusinessRole(requestParameters.businessRolePostDTO, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a business role by ID
         * @param {BusinessRolesApiDeleteBusinessRoleRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBusinessRole(
            requestParameters: BusinessRolesApiDeleteBusinessRoleRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .deleteBusinessRole(requestParameters.businessRoleId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get all business roles
         * @param {BusinessRolesApiGetAllBusinessRolesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllBusinessRoles(
            requestParameters: BusinessRolesApiGetAllBusinessRolesRequest = {},
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<PaginatedBusinessRoleResponse> {
            return localVarFp
                .getAllBusinessRoles(
                    requestParameters.search,
                    requestParameters.limit,
                    requestParameters.offset,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a business role by ID
         * @param {BusinessRolesApiGetBusinessRoleByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessRoleById(
            requestParameters: BusinessRolesApiGetBusinessRoleByIdRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<BusinessRoleDTO> {
            return localVarFp
                .getBusinessRoleById(requestParameters.businessRoleId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a business role children business roles
         * @param {BusinessRolesApiGetBusinessRoleChildrenBRsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessRoleChildrenBRs(
            requestParameters: BusinessRolesApiGetBusinessRoleChildrenBRsRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<Array<BusinessRoleDTO>> {
            return localVarFp
                .getBusinessRoleChildrenBRs(requestParameters.businessRoleId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a business role parents business roles
         * @param {BusinessRolesApiGetBusinessRoleParentsBRsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessRoleParentsBRs(
            requestParameters: BusinessRolesApiGetBusinessRoleParentsBRsRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<Array<BusinessRoleDTO>> {
            return localVarFp
                .getBusinessRoleParentsBRs(requestParameters.businessRoleId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get business role roles
         * @param {BusinessRolesApiGetRolesByBusinessRoleIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRolesByBusinessRoleId(
            requestParameters: BusinessRolesApiGetRolesByBusinessRoleIdRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<Array<RoleDTO>> {
            return localVarFp
                .getRolesByBusinessRoleId(requestParameters.businessRoleId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete role to the business role link
         * @param {BusinessRolesApiRemoveRoleFromBusinessRoleRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeRoleFromBusinessRole(
            requestParameters: BusinessRolesApiRemoveRoleFromBusinessRoleRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .removeRoleFromBusinessRole(
                    requestParameters.businessRoleId,
                    requestParameters.roleId,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update a business role by ID
         * @param {BusinessRolesApiUpdateBusinessRoleRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBusinessRole(
            requestParameters: BusinessRolesApiUpdateBusinessRoleRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<BusinessRoleDTO> {
            return localVarFp
                .updateBusinessRole(
                    requestParameters.businessRoleId,
                    requestParameters.businessRolePostDTO,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addRoleToBusinessRole operation in BusinessRolesApi.
 * @export
 * @interface BusinessRolesApiAddRoleToBusinessRoleRequest
 */
export interface BusinessRolesApiAddRoleToBusinessRoleRequest {
    /**
     *
     * @type {string}
     * @memberof BusinessRolesApiAddRoleToBusinessRole
     */
    readonly businessRoleId: string;

    /**
     *
     * @type {string}
     * @memberof BusinessRolesApiAddRoleToBusinessRole
     */
    readonly roleId: string;
}

/**
 * Request parameters for createBusinessRole operation in BusinessRolesApi.
 * @export
 * @interface BusinessRolesApiCreateBusinessRoleRequest
 */
export interface BusinessRolesApiCreateBusinessRoleRequest {
    /**
     *
     * @type {BusinessRolePostDTO}
     * @memberof BusinessRolesApiCreateBusinessRole
     */
    readonly businessRolePostDTO: BusinessRolePostDTO;
}

/**
 * Request parameters for deleteBusinessRole operation in BusinessRolesApi.
 * @export
 * @interface BusinessRolesApiDeleteBusinessRoleRequest
 */
export interface BusinessRolesApiDeleteBusinessRoleRequest {
    /**
     *
     * @type {string}
     * @memberof BusinessRolesApiDeleteBusinessRole
     */
    readonly businessRoleId: string;
}

/**
 * Request parameters for getAllBusinessRoles operation in BusinessRolesApi.
 * @export
 * @interface BusinessRolesApiGetAllBusinessRolesRequest
 */
export interface BusinessRolesApiGetAllBusinessRolesRequest {
    /**
     *
     * @type {string}
     * @memberof BusinessRolesApiGetAllBusinessRoles
     */
    readonly search?: string;

    /**
     *
     * @type {number}
     * @memberof BusinessRolesApiGetAllBusinessRoles
     */
    readonly limit?: number;

    /**
     *
     * @type {number}
     * @memberof BusinessRolesApiGetAllBusinessRoles
     */
    readonly offset?: number;
}

/**
 * Request parameters for getBusinessRoleById operation in BusinessRolesApi.
 * @export
 * @interface BusinessRolesApiGetBusinessRoleByIdRequest
 */
export interface BusinessRolesApiGetBusinessRoleByIdRequest {
    /**
     *
     * @type {string}
     * @memberof BusinessRolesApiGetBusinessRoleById
     */
    readonly businessRoleId: string;
}

/**
 * Request parameters for getBusinessRoleChildrenBRs operation in BusinessRolesApi.
 * @export
 * @interface BusinessRolesApiGetBusinessRoleChildrenBRsRequest
 */
export interface BusinessRolesApiGetBusinessRoleChildrenBRsRequest {
    /**
     *
     * @type {string}
     * @memberof BusinessRolesApiGetBusinessRoleChildrenBRs
     */
    readonly businessRoleId: string;
}

/**
 * Request parameters for getBusinessRoleParentsBRs operation in BusinessRolesApi.
 * @export
 * @interface BusinessRolesApiGetBusinessRoleParentsBRsRequest
 */
export interface BusinessRolesApiGetBusinessRoleParentsBRsRequest {
    /**
     *
     * @type {string}
     * @memberof BusinessRolesApiGetBusinessRoleParentsBRs
     */
    readonly businessRoleId: string;
}

/**
 * Request parameters for getRolesByBusinessRoleId operation in BusinessRolesApi.
 * @export
 * @interface BusinessRolesApiGetRolesByBusinessRoleIdRequest
 */
export interface BusinessRolesApiGetRolesByBusinessRoleIdRequest {
    /**
     *
     * @type {string}
     * @memberof BusinessRolesApiGetRolesByBusinessRoleId
     */
    readonly businessRoleId: string;
}

/**
 * Request parameters for removeRoleFromBusinessRole operation in BusinessRolesApi.
 * @export
 * @interface BusinessRolesApiRemoveRoleFromBusinessRoleRequest
 */
export interface BusinessRolesApiRemoveRoleFromBusinessRoleRequest {
    /**
     *
     * @type {string}
     * @memberof BusinessRolesApiRemoveRoleFromBusinessRole
     */
    readonly businessRoleId: string;

    /**
     *
     * @type {string}
     * @memberof BusinessRolesApiRemoveRoleFromBusinessRole
     */
    readonly roleId: string;
}

/**
 * Request parameters for updateBusinessRole operation in BusinessRolesApi.
 * @export
 * @interface BusinessRolesApiUpdateBusinessRoleRequest
 */
export interface BusinessRolesApiUpdateBusinessRoleRequest {
    /**
     *
     * @type {string}
     * @memberof BusinessRolesApiUpdateBusinessRole
     */
    readonly businessRoleId: string;

    /**
     *
     * @type {BusinessRolePostDTO}
     * @memberof BusinessRolesApiUpdateBusinessRole
     */
    readonly businessRolePostDTO: BusinessRolePostDTO;
}

/**
 * BusinessRolesApi - object-oriented interface
 * @export
 * @class BusinessRolesApi
 * @extends {BaseAPI}
 */
export class BusinessRolesApi extends BaseAPI {
    /**
     *
     * @summary Add role to the business role link
     * @param {BusinessRolesApiAddRoleToBusinessRoleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessRolesApi
     */
    public addRoleToBusinessRole(
        requestParameters: BusinessRolesApiAddRoleToBusinessRoleRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return BusinessRolesApiFp(this.configuration)
            .addRoleToBusinessRole(
                requestParameters.businessRoleId,
                requestParameters.roleId,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Create a new business role
     * @param {BusinessRolesApiCreateBusinessRoleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessRolesApi
     */
    public createBusinessRole(
        requestParameters: BusinessRolesApiCreateBusinessRoleRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return BusinessRolesApiFp(this.configuration)
            .createBusinessRole(requestParameters.businessRolePostDTO, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Delete a business role by ID
     * @param {BusinessRolesApiDeleteBusinessRoleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessRolesApi
     */
    public deleteBusinessRole(
        requestParameters: BusinessRolesApiDeleteBusinessRoleRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return BusinessRolesApiFp(this.configuration)
            .deleteBusinessRole(requestParameters.businessRoleId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get all business roles
     * @param {BusinessRolesApiGetAllBusinessRolesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessRolesApi
     */
    public getAllBusinessRoles(
        requestParameters: BusinessRolesApiGetAllBusinessRolesRequest = {},
        options?: RawAxiosRequestConfig,
    ) {
        return BusinessRolesApiFp(this.configuration)
            .getAllBusinessRoles(
                requestParameters.search,
                requestParameters.limit,
                requestParameters.offset,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get a business role by ID
     * @param {BusinessRolesApiGetBusinessRoleByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessRolesApi
     */
    public getBusinessRoleById(
        requestParameters: BusinessRolesApiGetBusinessRoleByIdRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return BusinessRolesApiFp(this.configuration)
            .getBusinessRoleById(requestParameters.businessRoleId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get a business role children business roles
     * @param {BusinessRolesApiGetBusinessRoleChildrenBRsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessRolesApi
     */
    public getBusinessRoleChildrenBRs(
        requestParameters: BusinessRolesApiGetBusinessRoleChildrenBRsRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return BusinessRolesApiFp(this.configuration)
            .getBusinessRoleChildrenBRs(requestParameters.businessRoleId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get a business role parents business roles
     * @param {BusinessRolesApiGetBusinessRoleParentsBRsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessRolesApi
     */
    public getBusinessRoleParentsBRs(
        requestParameters: BusinessRolesApiGetBusinessRoleParentsBRsRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return BusinessRolesApiFp(this.configuration)
            .getBusinessRoleParentsBRs(requestParameters.businessRoleId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get business role roles
     * @param {BusinessRolesApiGetRolesByBusinessRoleIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessRolesApi
     */
    public getRolesByBusinessRoleId(
        requestParameters: BusinessRolesApiGetRolesByBusinessRoleIdRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return BusinessRolesApiFp(this.configuration)
            .getRolesByBusinessRoleId(requestParameters.businessRoleId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Delete role to the business role link
     * @param {BusinessRolesApiRemoveRoleFromBusinessRoleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessRolesApi
     */
    public removeRoleFromBusinessRole(
        requestParameters: BusinessRolesApiRemoveRoleFromBusinessRoleRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return BusinessRolesApiFp(this.configuration)
            .removeRoleFromBusinessRole(
                requestParameters.businessRoleId,
                requestParameters.roleId,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Update a business role by ID
     * @param {BusinessRolesApiUpdateBusinessRoleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessRolesApi
     */
    public updateBusinessRole(
        requestParameters: BusinessRolesApiUpdateBusinessRoleRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return BusinessRolesApiFp(this.configuration)
            .updateBusinessRole(
                requestParameters.businessRoleId,
                requestParameters.businessRolePostDTO,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }
}

/**
 * DomainComponentsApi - axios parameter creator
 * @export
 */
export const DomainComponentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Create a new domain component
         * @param {DomainComponentPostDTO} domainComponentPostDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDomainComponent: async (
            domainComponentPostDTO: DomainComponentPostDTO,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'domainComponentPostDTO' is not null or undefined
            assertParamExists(
                'createDomainComponent',
                'domainComponentPostDTO',
                domainComponentPostDTO,
            );
            const localVarPath = `/api/v1/domain-components`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = serializeDataIfNeeded(
                domainComponentPostDTO,
                localVarRequestOptions,
                configuration,
            );

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a domain component by ID
         * @param {string} dcId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDomainComponent: async (
            dcId: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'dcId' is not null or undefined
            assertParamExists('deleteDomainComponent', 'dcId', dcId);
            const localVarPath = `/api/v1/domain-components/{dcId}`.replace(
                `{${'dcId'}}`,
                encodeURIComponent(String(dcId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all domain components
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllDomainComponents: async (
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/domain-components`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a domain component by ID
         * @param {string} dcId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomainComponentById: async (
            dcId: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'dcId' is not null or undefined
            assertParamExists('getDomainComponentById', 'dcId', dcId);
            const localVarPath = `/api/v1/domain-components/{dcId}`.replace(
                `{${'dcId'}}`,
                encodeURIComponent(String(dcId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Getting the root elements of the organization-unit
         * @param {string} dcId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomainComponentRootsOrganizationUnits: async (
            dcId: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'dcId' is not null or undefined
            assertParamExists('getDomainComponentRootsOrganizationUnits', 'dcId', dcId);
            const localVarPath =
                `/api/v1/domain-components/{dcId}/organization-units/roots`.replace(
                    `{${'dcId'}}`,
                    encodeURIComponent(String(dcId)),
                );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a domain component tree
         * @param {string} dcId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomainComponentTree: async (
            dcId: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'dcId' is not null or undefined
            assertParamExists('getDomainComponentTree', 'dcId', dcId);
            const localVarPath = `/api/v1/domain-components/{dcId}/tree`.replace(
                `{${'dcId'}}`,
                encodeURIComponent(String(dcId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update a domain component by ID
         * @param {string} dcId
         * @param {DomainComponentPostDTO} domainComponentPostDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainComponent: async (
            dcId: string,
            domainComponentPostDTO: DomainComponentPostDTO,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'dcId' is not null or undefined
            assertParamExists('updateDomainComponent', 'dcId', dcId);
            // verify required parameter 'domainComponentPostDTO' is not null or undefined
            assertParamExists(
                'updateDomainComponent',
                'domainComponentPostDTO',
                domainComponentPostDTO,
            );
            const localVarPath = `/api/v1/domain-components/{dcId}`.replace(
                `{${'dcId'}}`,
                encodeURIComponent(String(dcId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = serializeDataIfNeeded(
                domainComponentPostDTO,
                localVarRequestOptions,
                configuration,
            );

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * DomainComponentsApi - functional programming interface
 * @export
 */
export const DomainComponentsApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = DomainComponentsApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Create a new domain component
         * @param {DomainComponentPostDTO} domainComponentPostDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDomainComponent(
            domainComponentPostDTO: DomainComponentPostDTO,
            options?: RawAxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DomainComponentDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDomainComponent(
                domainComponentPostDTO,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['DomainComponentsApi.createDomainComponent']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Delete a domain component by ID
         * @param {string} dcId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDomainComponent(
            dcId: string,
            options?: RawAxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDomainComponent(
                dcId,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['DomainComponentsApi.deleteDomainComponent']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get all domain components
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllDomainComponents(
            options?: RawAxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DomainComponentDTO>>
        > {
            const localVarAxiosArgs =
                await localVarAxiosParamCreator.getAllDomainComponents(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['DomainComponentsApi.getAllDomainComponents']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get a domain component by ID
         * @param {string} dcId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDomainComponentById(
            dcId: string,
            options?: RawAxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DomainComponentDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDomainComponentById(
                dcId,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['DomainComponentsApi.getDomainComponentById']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Getting the root elements of the organization-unit
         * @param {string} dcId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDomainComponentRootsOrganizationUnits(
            dcId: string,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationUnitDTO>>
        > {
            const localVarAxiosArgs =
                await localVarAxiosParamCreator.getDomainComponentRootsOrganizationUnits(
                    dcId,
                    options,
                );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap[
                    'DomainComponentsApi.getDomainComponentRootsOrganizationUnits'
                ]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get a domain component tree
         * @param {string} dcId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDomainComponentTree(
            dcId: string,
            options?: RawAxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DomainTreeDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDomainComponentTree(
                dcId,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['DomainComponentsApi.getDomainComponentTree']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Update a domain component by ID
         * @param {string} dcId
         * @param {DomainComponentPostDTO} domainComponentPostDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDomainComponent(
            dcId: string,
            domainComponentPostDTO: DomainComponentPostDTO,
            options?: RawAxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DomainComponentDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDomainComponent(
                dcId,
                domainComponentPostDTO,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['DomainComponentsApi.updateDomainComponent']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
    };
};

/**
 * DomainComponentsApi - factory interface
 * @export
 */
export const DomainComponentsApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = DomainComponentsApiFp(configuration);
    return {
        /**
         *
         * @summary Create a new domain component
         * @param {DomainComponentsApiCreateDomainComponentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDomainComponent(
            requestParameters: DomainComponentsApiCreateDomainComponentRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<DomainComponentDTO> {
            return localVarFp
                .createDomainComponent(requestParameters.domainComponentPostDTO, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a domain component by ID
         * @param {DomainComponentsApiDeleteDomainComponentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDomainComponent(
            requestParameters: DomainComponentsApiDeleteDomainComponentRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .deleteDomainComponent(requestParameters.dcId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get all domain components
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllDomainComponents(
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<Array<DomainComponentDTO>> {
            return localVarFp
                .getAllDomainComponents(options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a domain component by ID
         * @param {DomainComponentsApiGetDomainComponentByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomainComponentById(
            requestParameters: DomainComponentsApiGetDomainComponentByIdRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<DomainComponentDTO> {
            return localVarFp
                .getDomainComponentById(requestParameters.dcId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Getting the root elements of the organization-unit
         * @param {DomainComponentsApiGetDomainComponentRootsOrganizationUnitsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomainComponentRootsOrganizationUnits(
            requestParameters: DomainComponentsApiGetDomainComponentRootsOrganizationUnitsRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<Array<OrganizationUnitDTO>> {
            return localVarFp
                .getDomainComponentRootsOrganizationUnits(requestParameters.dcId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a domain component tree
         * @param {DomainComponentsApiGetDomainComponentTreeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomainComponentTree(
            requestParameters: DomainComponentsApiGetDomainComponentTreeRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<DomainTreeDTO> {
            return localVarFp
                .getDomainComponentTree(requestParameters.dcId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update a domain component by ID
         * @param {DomainComponentsApiUpdateDomainComponentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainComponent(
            requestParameters: DomainComponentsApiUpdateDomainComponentRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<DomainComponentDTO> {
            return localVarFp
                .updateDomainComponent(
                    requestParameters.dcId,
                    requestParameters.domainComponentPostDTO,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createDomainComponent operation in DomainComponentsApi.
 * @export
 * @interface DomainComponentsApiCreateDomainComponentRequest
 */
export interface DomainComponentsApiCreateDomainComponentRequest {
    /**
     *
     * @type {DomainComponentPostDTO}
     * @memberof DomainComponentsApiCreateDomainComponent
     */
    readonly domainComponentPostDTO: DomainComponentPostDTO;
}

/**
 * Request parameters for deleteDomainComponent operation in DomainComponentsApi.
 * @export
 * @interface DomainComponentsApiDeleteDomainComponentRequest
 */
export interface DomainComponentsApiDeleteDomainComponentRequest {
    /**
     *
     * @type {string}
     * @memberof DomainComponentsApiDeleteDomainComponent
     */
    readonly dcId: string;
}

/**
 * Request parameters for getDomainComponentById operation in DomainComponentsApi.
 * @export
 * @interface DomainComponentsApiGetDomainComponentByIdRequest
 */
export interface DomainComponentsApiGetDomainComponentByIdRequest {
    /**
     *
     * @type {string}
     * @memberof DomainComponentsApiGetDomainComponentById
     */
    readonly dcId: string;
}

/**
 * Request parameters for getDomainComponentRootsOrganizationUnits operation in DomainComponentsApi.
 * @export
 * @interface DomainComponentsApiGetDomainComponentRootsOrganizationUnitsRequest
 */
export interface DomainComponentsApiGetDomainComponentRootsOrganizationUnitsRequest {
    /**
     *
     * @type {string}
     * @memberof DomainComponentsApiGetDomainComponentRootsOrganizationUnits
     */
    readonly dcId: string;
}

/**
 * Request parameters for getDomainComponentTree operation in DomainComponentsApi.
 * @export
 * @interface DomainComponentsApiGetDomainComponentTreeRequest
 */
export interface DomainComponentsApiGetDomainComponentTreeRequest {
    /**
     *
     * @type {string}
     * @memberof DomainComponentsApiGetDomainComponentTree
     */
    readonly dcId: string;
}

/**
 * Request parameters for updateDomainComponent operation in DomainComponentsApi.
 * @export
 * @interface DomainComponentsApiUpdateDomainComponentRequest
 */
export interface DomainComponentsApiUpdateDomainComponentRequest {
    /**
     *
     * @type {string}
     * @memberof DomainComponentsApiUpdateDomainComponent
     */
    readonly dcId: string;

    /**
     *
     * @type {DomainComponentPostDTO}
     * @memberof DomainComponentsApiUpdateDomainComponent
     */
    readonly domainComponentPostDTO: DomainComponentPostDTO;
}

/**
 * DomainComponentsApi - object-oriented interface
 * @export
 * @class DomainComponentsApi
 * @extends {BaseAPI}
 */
export class DomainComponentsApi extends BaseAPI {
    /**
     *
     * @summary Create a new domain component
     * @param {DomainComponentsApiCreateDomainComponentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainComponentsApi
     */
    public createDomainComponent(
        requestParameters: DomainComponentsApiCreateDomainComponentRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return DomainComponentsApiFp(this.configuration)
            .createDomainComponent(requestParameters.domainComponentPostDTO, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Delete a domain component by ID
     * @param {DomainComponentsApiDeleteDomainComponentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainComponentsApi
     */
    public deleteDomainComponent(
        requestParameters: DomainComponentsApiDeleteDomainComponentRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return DomainComponentsApiFp(this.configuration)
            .deleteDomainComponent(requestParameters.dcId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get all domain components
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainComponentsApi
     */
    public getAllDomainComponents(options?: RawAxiosRequestConfig) {
        return DomainComponentsApiFp(this.configuration)
            .getAllDomainComponents(options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get a domain component by ID
     * @param {DomainComponentsApiGetDomainComponentByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainComponentsApi
     */
    public getDomainComponentById(
        requestParameters: DomainComponentsApiGetDomainComponentByIdRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return DomainComponentsApiFp(this.configuration)
            .getDomainComponentById(requestParameters.dcId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Getting the root elements of the organization-unit
     * @param {DomainComponentsApiGetDomainComponentRootsOrganizationUnitsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainComponentsApi
     */
    public getDomainComponentRootsOrganizationUnits(
        requestParameters: DomainComponentsApiGetDomainComponentRootsOrganizationUnitsRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return DomainComponentsApiFp(this.configuration)
            .getDomainComponentRootsOrganizationUnits(requestParameters.dcId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get a domain component tree
     * @param {DomainComponentsApiGetDomainComponentTreeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainComponentsApi
     */
    public getDomainComponentTree(
        requestParameters: DomainComponentsApiGetDomainComponentTreeRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return DomainComponentsApiFp(this.configuration)
            .getDomainComponentTree(requestParameters.dcId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Update a domain component by ID
     * @param {DomainComponentsApiUpdateDomainComponentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainComponentsApi
     */
    public updateDomainComponent(
        requestParameters: DomainComponentsApiUpdateDomainComponentRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return DomainComponentsApiFp(this.configuration)
            .updateDomainComponent(
                requestParameters.dcId,
                requestParameters.domainComponentPostDTO,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }
}

/**
 * MDBApi - axios parameter creator
 * @export
 */
export const MDBApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Create MongoDB backup
         * @param {string} clusterId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBackup: async (
            clusterId: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('createBackup', 'clusterId', clusterId);
            const localVarPath = `/api/mdb/mongodb/clusters/{clusterId}/backups`.replace(
                `{${'clusterId'}}`,
                encodeURIComponent(String(clusterId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create MongoDB cluster
         * @param {CreateMongoClusterRequestDTO} createMongoClusterRequestDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCluster: async (
            createMongoClusterRequestDTO: CreateMongoClusterRequestDTO,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'createMongoClusterRequestDTO' is not null or undefined
            assertParamExists(
                'createCluster',
                'createMongoClusterRequestDTO',
                createMongoClusterRequestDTO,
            );
            const localVarPath = `/api/mdb/mongodb/clusters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = serializeDataIfNeeded(
                createMongoClusterRequestDTO,
                localVarRequestOptions,
                configuration,
            );

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create MongoDB database
         * @param {string} clusterId
         * @param {CreateMongoDatabaseRequestDTO} createMongoDatabaseRequestDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDatabase: async (
            clusterId: string,
            createMongoDatabaseRequestDTO: CreateMongoDatabaseRequestDTO,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('createDatabase', 'clusterId', clusterId);
            // verify required parameter 'createMongoDatabaseRequestDTO' is not null or undefined
            assertParamExists(
                'createDatabase',
                'createMongoDatabaseRequestDTO',
                createMongoDatabaseRequestDTO,
            );
            const localVarPath = `/api/mdb/mongodb/clusters/{clusterId}/databases`.replace(
                `{${'clusterId'}}`,
                encodeURIComponent(String(clusterId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = serializeDataIfNeeded(
                createMongoDatabaseRequestDTO,
                localVarRequestOptions,
                configuration,
            );

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create project
         * @param {CreateProjectRequestDTO} createProjectRequestDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProject: async (
            createProjectRequestDTO: CreateProjectRequestDTO,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'createProjectRequestDTO' is not null or undefined
            assertParamExists('createProject', 'createProjectRequestDTO', createProjectRequestDTO);
            const localVarPath = `/api/mdb/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = serializeDataIfNeeded(
                createProjectRequestDTO,
                localVarRequestOptions,
                configuration,
            );

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create resource preset
         * @param {V1CreateResourcePresetRequest} v1CreateResourcePresetRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createResourcePreset: async (
            v1CreateResourcePresetRequest: V1CreateResourcePresetRequest,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'v1CreateResourcePresetRequest' is not null or undefined
            assertParamExists(
                'createResourcePreset',
                'v1CreateResourcePresetRequest',
                v1CreateResourcePresetRequest,
            );
            const localVarPath = `/api/v1/resource-presets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = serializeDataIfNeeded(
                v1CreateResourcePresetRequest,
                localVarRequestOptions,
                configuration,
            );

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create MongoDB user
         * @param {string} clusterId
         * @param {CreateMongoUserRequestDTO} createMongoUserRequestDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: async (
            clusterId: string,
            createMongoUserRequestDTO: CreateMongoUserRequestDTO,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('createUser', 'clusterId', clusterId);
            // verify required parameter 'createMongoUserRequestDTO' is not null or undefined
            assertParamExists('createUser', 'createMongoUserRequestDTO', createMongoUserRequestDTO);
            const localVarPath = `/api/mdb/mongodb/clusters/{clusterId}/users`.replace(
                `{${'clusterId'}}`,
                encodeURIComponent(String(clusterId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = serializeDataIfNeeded(
                createMongoUserRequestDTO,
                localVarRequestOptions,
                configuration,
            );

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete backup of MongoDB cluster
         * @param {string} clusterId
         * @param {string} backupName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBackup: async (
            clusterId: string,
            backupName: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('deleteBackup', 'clusterId', clusterId);
            // verify required parameter 'backupName' is not null or undefined
            assertParamExists('deleteBackup', 'backupName', backupName);
            const localVarPath = `/api/mdb/mongodb/clusters/{clusterId}/backups/{backupName}`
                .replace(`{${'clusterId'}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${'backupName'}}`, encodeURIComponent(String(backupName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete MongoDB cluster
         * @param {string} clusterId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCluster: async (
            clusterId: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('deleteCluster', 'clusterId', clusterId);
            const localVarPath = `/api/mdb/mongodb/clusters/{clusterId}`.replace(
                `{${'clusterId'}}`,
                encodeURIComponent(String(clusterId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete MongoDB database
         * @param {string} clusterId
         * @param {string} databaseName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDatabase: async (
            clusterId: string,
            databaseName: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('deleteDatabase', 'clusterId', clusterId);
            // verify required parameter 'databaseName' is not null or undefined
            assertParamExists('deleteDatabase', 'databaseName', databaseName);
            const localVarPath = `/api/mdb/mongodb/clusters/{clusterId}/databases/{databaseName}`
                .replace(`{${'clusterId'}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${'databaseName'}}`, encodeURIComponent(String(databaseName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete project
         * @param {string} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProject: async (
            projectId: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('deleteProject', 'projectId', projectId);
            const localVarPath = `/api/mdb/projects/{projectId}`.replace(
                `{${'projectId'}}`,
                encodeURIComponent(String(projectId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete resource preset
         * @param {string} resourcePresetId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResourcePreset: async (
            resourcePresetId: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'resourcePresetId' is not null or undefined
            assertParamExists('deleteResourcePreset', 'resourcePresetId', resourcePresetId);
            const localVarPath = `/api/v1/resource-presets/{resourcePresetId}`.replace(
                `{${'resourcePresetId'}}`,
                encodeURIComponent(String(resourcePresetId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete MongoDB user
         * @param {string} clusterId
         * @param {string} userName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (
            clusterId: string,
            userName: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('deleteUser', 'clusterId', clusterId);
            // verify required parameter 'userName' is not null or undefined
            assertParamExists('deleteUser', 'userName', userName);
            const localVarPath = `/api/mdb/mongodb/clusters/{clusterId}/users/{userName}`
                .replace(`{${'clusterId'}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${'userName'}}`, encodeURIComponent(String(userName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get MongoDB cluster
         * @param {string} clusterId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCluster: async (
            clusterId: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('getCluster', 'clusterId', clusterId);
            const localVarPath = `/api/mdb/mongodb/clusters/{clusterId}`.replace(
                `{${'clusterId'}}`,
                encodeURIComponent(String(clusterId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get product quota usage report
         * @param {string} productId
         * @param {string} startDate
         * @param {string} endDate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductQuotaUsageReport: async (
            productId: string,
            startDate: string,
            endDate: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('getProductQuotaUsageReport', 'productId', productId);
            // verify required parameter 'startDate' is not null or undefined
            assertParamExists('getProductQuotaUsageReport', 'startDate', startDate);
            // verify required parameter 'endDate' is not null or undefined
            assertParamExists('getProductQuotaUsageReport', 'endDate', endDate);
            const localVarPath = `/api/billing/product-quota-usage-report`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            if (productId !== undefined) {
                localVarQueryParameter['productId'] = productId;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] =
                    (startDate as any) instanceof Date
                        ? (startDate as any).toISOString().substring(0, 10)
                        : startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] =
                    (endDate as any) instanceof Date
                        ? (endDate as any).toISOString().substring(0, 10)
                        : endDate;
            }

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get project
         * @param {string} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject: async (
            projectId: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getProject', 'projectId', projectId);
            const localVarPath = `/api/mdb/projects/{projectId}`.replace(
                `{${'projectId'}}`,
                encodeURIComponent(String(projectId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get resource preset
         * @param {string} resourcePresetId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResourcePreset: async (
            resourcePresetId: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'resourcePresetId' is not null or undefined
            assertParamExists('getResourcePreset', 'resourcePresetId', resourcePresetId);
            const localVarPath = `/api/v1/resource-presets/{resourcePresetId}`.replace(
                `{${'resourcePresetId'}}`,
                encodeURIComponent(String(resourcePresetId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List MongoDB backups
         * @param {string} clusterId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBackups: async (
            clusterId: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('listBackups', 'clusterId', clusterId);
            const localVarPath = `/api/mdb/mongodb/clusters/{clusterId}/backups`.replace(
                `{${'clusterId'}}`,
                encodeURIComponent(String(clusterId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List MongoDB clusters
         * @param {Array<string>} [projectIds]
         * @param {boolean} [isDeleted]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listClusters: async (
            projectIds?: Array<string>,
            isDeleted?: boolean,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            const localVarPath = `/api/mdb/mongodb/clusters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            if (projectIds) {
                localVarQueryParameter['projectIds'] = projectIds;
            }

            if (isDeleted !== undefined) {
                localVarQueryParameter['isDeleted'] = isDeleted;
            }

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List MongoDB databases
         * @param {string} clusterId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabases: async (
            clusterId: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('listDatabases', 'clusterId', clusterId);
            const localVarPath = `/api/mdb/mongodb/clusters/{clusterId}/databases`.replace(
                `{${'clusterId'}}`,
                encodeURIComponent(String(clusterId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List namespaces
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNamespaces: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/mdb/namespaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List operations
         * @param {string} [clusterId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOperations: async (
            clusterId?: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            const localVarPath = `/api/mdb/operations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            if (clusterId !== undefined) {
                localVarQueryParameter['clusterId'] = clusterId;
            }

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List projects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjects: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/mdb/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List MDB quotas by products
         * @param {Array<string>} [productIds]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQuotasByProducts: async (
            productIds?: Array<string>,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            const localVarPath = `/api/quotas/mdb/by-products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            if (productIds) {
                localVarQueryParameter['productIds'] = productIds;
            }

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get resource presets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResourcePresets: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/resource-presets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List MDB resources
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResources: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/quotas/mdb/resources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List available MongoDB roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoles: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/mdb/mongodb/users/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List storage classes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listStorageClasses: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/mdb/storage-classes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List MongoDB users
         * @param {string} clusterId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers: async (
            clusterId: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('listUsers', 'clusterId', clusterId);
            const localVarPath = `/api/mdb/mongodb/clusters/{clusterId}/users`.replace(
                `{${'clusterId'}}`,
                encodeURIComponent(String(clusterId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List MongoDB versions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVersions: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/mdb/mongodb/versions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Restart operation
         * @param {string} operationId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartOperation: async (
            operationId: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'operationId' is not null or undefined
            assertParamExists('restartOperation', 'operationId', operationId);
            const localVarPath = `/api/mdb/operations/{operationId}/restart`.replace(
                `{${'operationId'}}`,
                encodeURIComponent(String(operationId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Restore MongoDB cluster
         * @param {string} clusterId
         * @param {string} backupName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreCluster: async (
            clusterId: string,
            backupName: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('restoreCluster', 'clusterId', clusterId);
            // verify required parameter 'backupName' is not null or undefined
            assertParamExists('restoreCluster', 'backupName', backupName);
            const localVarPath = `/api/mdb/mongodb/clusters/{clusterId}/restore/{backupName}`
                .replace(`{${'clusterId'}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${'backupName'}}`, encodeURIComponent(String(backupName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Simulate usage of quotas for MongoDB cluster
         * @param {SimulateMongoDBQuotasUsageRequest} simulateMongoDBQuotasUsageRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simulateMongoDbQuotasUsage: async (
            simulateMongoDBQuotasUsageRequest: SimulateMongoDBQuotasUsageRequest,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'simulateMongoDBQuotasUsageRequest' is not null or undefined
            assertParamExists(
                'simulateMongoDbQuotasUsage',
                'simulateMongoDBQuotasUsageRequest',
                simulateMongoDBQuotasUsageRequest,
            );
            const localVarPath = `/api/quotas/mdb/managed-mongodb/simulate-usage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = serializeDataIfNeeded(
                simulateMongoDBQuotasUsageRequest,
                localVarRequestOptions,
                configuration,
            );

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Simulate transfer of MDB quotas between products
         * @param {TransferQuotasBetweenProductsRequest} transferQuotasBetweenProductsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simulateTransferQuotasBetweenProducts: async (
            transferQuotasBetweenProductsRequest: TransferQuotasBetweenProductsRequest,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'transferQuotasBetweenProductsRequest' is not null or undefined
            assertParamExists(
                'simulateTransferQuotasBetweenProducts',
                'transferQuotasBetweenProductsRequest',
                transferQuotasBetweenProductsRequest,
            );
            const localVarPath = `/api/quotas/mdb/simulate-transfer-between-products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = serializeDataIfNeeded(
                transferQuotasBetweenProductsRequest,
                localVarRequestOptions,
                configuration,
            );

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Exchange MDB quotas between products
         * @param {TransferQuotasBetweenProductsRequest} transferQuotasBetweenProductsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transferQuotasBetweenProducts: async (
            transferQuotasBetweenProductsRequest: TransferQuotasBetweenProductsRequest,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'transferQuotasBetweenProductsRequest' is not null or undefined
            assertParamExists(
                'transferQuotasBetweenProducts',
                'transferQuotasBetweenProductsRequest',
                transferQuotasBetweenProductsRequest,
            );
            const localVarPath = `/api/quotas/mdb/transfer-between-products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = serializeDataIfNeeded(
                transferQuotasBetweenProductsRequest,
                localVarRequestOptions,
                configuration,
            );

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update MongoDB cluster
         * @param {string} clusterId
         * @param {UpdateMongoClusterRequestDTO} updateMongoClusterRequestDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCluster: async (
            clusterId: string,
            updateMongoClusterRequestDTO: UpdateMongoClusterRequestDTO,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('updateCluster', 'clusterId', clusterId);
            // verify required parameter 'updateMongoClusterRequestDTO' is not null or undefined
            assertParamExists(
                'updateCluster',
                'updateMongoClusterRequestDTO',
                updateMongoClusterRequestDTO,
            );
            const localVarPath = `/api/mdb/mongodb/clusters/{clusterId}`.replace(
                `{${'clusterId'}}`,
                encodeURIComponent(String(clusterId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = serializeDataIfNeeded(
                updateMongoClusterRequestDTO,
                localVarRequestOptions,
                configuration,
            );

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update MongoDB hosts
         * @param {UpdateMongoHostsRequest} updateMongoHostsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHosts: async (
            updateMongoHostsRequest: UpdateMongoHostsRequest,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'updateMongoHostsRequest' is not null or undefined
            assertParamExists('updateHosts', 'updateMongoHostsRequest', updateMongoHostsRequest);
            const localVarPath = `/api/managed-mongodb/v1/internal/hosts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = serializeDataIfNeeded(
                updateMongoHostsRequest,
                localVarRequestOptions,
                configuration,
            );

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update project
         * @param {string} projectId
         * @param {UpdateProjectRequestDTO} updateProjectRequestDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProject: async (
            projectId: string,
            updateProjectRequestDTO: UpdateProjectRequestDTO,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('updateProject', 'projectId', projectId);
            // verify required parameter 'updateProjectRequestDTO' is not null or undefined
            assertParamExists('updateProject', 'updateProjectRequestDTO', updateProjectRequestDTO);
            const localVarPath = `/api/mdb/projects/{projectId}`.replace(
                `{${'projectId'}}`,
                encodeURIComponent(String(projectId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = serializeDataIfNeeded(
                updateProjectRequestDTO,
                localVarRequestOptions,
                configuration,
            );

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update resource preset
         * @param {string} resourcePresetId
         * @param {V1UpdateResourcePresetRequest} v1UpdateResourcePresetRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResourcePreset: async (
            resourcePresetId: string,
            v1UpdateResourcePresetRequest: V1UpdateResourcePresetRequest,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'resourcePresetId' is not null or undefined
            assertParamExists('updateResourcePreset', 'resourcePresetId', resourcePresetId);
            // verify required parameter 'v1UpdateResourcePresetRequest' is not null or undefined
            assertParamExists(
                'updateResourcePreset',
                'v1UpdateResourcePresetRequest',
                v1UpdateResourcePresetRequest,
            );
            const localVarPath = `/api/v1/resource-presets/{resourcePresetId}`.replace(
                `{${'resourcePresetId'}}`,
                encodeURIComponent(String(resourcePresetId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = serializeDataIfNeeded(
                v1UpdateResourcePresetRequest,
                localVarRequestOptions,
                configuration,
            );

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Upload MDB quotas to multiple products
         * @param {UploadQuotasToProductsRequest} uploadQuotasToProductsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadQuotasToProducts: async (
            uploadQuotasToProductsRequest: UploadQuotasToProductsRequest,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'uploadQuotasToProductsRequest' is not null or undefined
            assertParamExists(
                'uploadQuotasToProducts',
                'uploadQuotasToProductsRequest',
                uploadQuotasToProductsRequest,
            );
            const localVarPath = `/api/quotas/mdb/upload-to-products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = serializeDataIfNeeded(
                uploadQuotasToProductsRequest,
                localVarRequestOptions,
                configuration,
            );

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * MDBApi - functional programming interface
 * @export
 */
export const MDBApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = MDBApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Create MongoDB backup
         * @param {string} clusterId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBackup(
            clusterId: string,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduledOperationDTO>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBackup(
                clusterId,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['MDBApi.createBackup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Create MongoDB cluster
         * @param {CreateMongoClusterRequestDTO} createMongoClusterRequestDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCluster(
            createMongoClusterRequestDTO: CreateMongoClusterRequestDTO,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (
                axios?: AxiosInstance,
                basePath?: string,
            ) => AxiosPromise<CreateMongoClusterResponseDTO>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCluster(
                createMongoClusterRequestDTO,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['MDBApi.createCluster']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Create MongoDB database
         * @param {string} clusterId
         * @param {CreateMongoDatabaseRequestDTO} createMongoDatabaseRequestDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDatabase(
            clusterId: string,
            createMongoDatabaseRequestDTO: CreateMongoDatabaseRequestDTO,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduledOperationDTO>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDatabase(
                clusterId,
                createMongoDatabaseRequestDTO,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['MDBApi.createDatabase']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Create project
         * @param {CreateProjectRequestDTO} createProjectRequestDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProject(
            createProjectRequestDTO: CreateProjectRequestDTO,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateProjectResponseDTO>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProject(
                createProjectRequestDTO,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['MDBApi.createProject']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Create resource preset
         * @param {V1CreateResourcePresetRequest} v1CreateResourcePresetRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createResourcePreset(
            v1CreateResourcePresetRequest: V1CreateResourcePresetRequest,
            options?: RawAxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createResourcePreset(
                v1CreateResourcePresetRequest,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['MDBApi.createResourcePreset']?.[localVarOperationServerIndex]
                    ?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Create MongoDB user
         * @param {string} clusterId
         * @param {CreateMongoUserRequestDTO} createMongoUserRequestDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUser(
            clusterId: string,
            createMongoUserRequestDTO: CreateMongoUserRequestDTO,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduledOperationDTO>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(
                clusterId,
                createMongoUserRequestDTO,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['MDBApi.createUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Delete backup of MongoDB cluster
         * @param {string} clusterId
         * @param {string} backupName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBackup(
            clusterId: string,
            backupName: string,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduledOperationDTO>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBackup(
                clusterId,
                backupName,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['MDBApi.deleteBackup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Delete MongoDB cluster
         * @param {string} clusterId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCluster(
            clusterId: string,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduledOperationDTO>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCluster(
                clusterId,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['MDBApi.deleteCluster']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Delete MongoDB database
         * @param {string} clusterId
         * @param {string} databaseName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDatabase(
            clusterId: string,
            databaseName: string,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduledOperationDTO>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDatabase(
                clusterId,
                databaseName,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['MDBApi.deleteDatabase']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Delete project
         * @param {string} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProject(
            projectId: string,
            options?: RawAxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProject(
                projectId,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['MDBApi.deleteProject']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Delete resource preset
         * @param {string} resourcePresetId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteResourcePreset(
            resourcePresetId: string,
            options?: RawAxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteResourcePreset(
                resourcePresetId,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['MDBApi.deleteResourcePreset']?.[localVarOperationServerIndex]
                    ?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Delete MongoDB user
         * @param {string} clusterId
         * @param {string} userName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(
            clusterId: string,
            userName: string,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduledOperationDTO>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(
                clusterId,
                userName,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['MDBApi.deleteUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get MongoDB cluster
         * @param {string} clusterId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCluster(
            clusterId: string,
            options?: RawAxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MongoClusterDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCluster(
                clusterId,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['MDBApi.getCluster']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get product quota usage report
         * @param {string} productId
         * @param {string} startDate
         * @param {string} endDate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductQuotaUsageReport(
            productId: string,
            startDate: string,
            endDate: string,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (
                axios?: AxiosInstance,
                basePath?: string,
            ) => AxiosPromise<GetProductQuotaUsageReportResponseOA>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProductQuotaUsageReport(
                productId,
                startDate,
                endDate,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['MDBApi.getProductQuotaUsageReport']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get project
         * @param {string} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProject(
            projectId: string,
            options?: RawAxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProject(
                projectId,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['MDBApi.getProject']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get resource preset
         * @param {string} resourcePresetId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getResourcePreset(
            resourcePresetId: string,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1ResourcePresetResponse>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getResourcePreset(
                resourcePresetId,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['MDBApi.getResourcePreset']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary List MongoDB backups
         * @param {string} clusterId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBackups(
            clusterId: string,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListMongoBackupsResponseDTO>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBackups(
                clusterId,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['MDBApi.listBackups']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary List MongoDB clusters
         * @param {Array<string>} [projectIds]
         * @param {boolean} [isDeleted]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listClusters(
            projectIds?: Array<string>,
            isDeleted?: boolean,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListMongoClustersResponseDTO>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listClusters(
                projectIds,
                isDeleted,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['MDBApi.listClusters']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary List MongoDB databases
         * @param {string} clusterId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDatabases(
            clusterId: string,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (
                axios?: AxiosInstance,
                basePath?: string,
            ) => AxiosPromise<ListMongoDatabasesResponseDTO>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDatabases(
                clusterId,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['MDBApi.listDatabases']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary List namespaces
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listNamespaces(
            options?: RawAxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListNamespacesResponseDTO>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listNamespaces(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['MDBApi.listNamespaces']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary List operations
         * @param {string} [clusterId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOperations(
            clusterId?: string,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListOperationsResponseDTO>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOperations(
                clusterId,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['MDBApi.listOperations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary List projects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProjects(
            options?: RawAxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListProjectsResponseDTO>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProjects(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['MDBApi.listProjects']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary List MDB quotas by products
         * @param {Array<string>} [productIds]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listQuotasByProducts(
            productIds?: Array<string>,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListQuotasByProductsResponse>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listQuotasByProducts(
                productIds,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['MDBApi.listQuotasByProducts']?.[localVarOperationServerIndex]
                    ?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get resource presets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listResourcePresets(
            options?: RawAxiosRequestConfig,
        ): Promise<
            (
                axios?: AxiosInstance,
                basePath?: string,
            ) => AxiosPromise<V1ListResourcePresetsResponse>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listResourcePresets(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['MDBApi.listResourcePresets']?.[localVarOperationServerIndex]
                    ?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary List MDB resources
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listResources(
            options?: RawAxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListResourcesResponse>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listResources(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['MDBApi.listResources']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary List available MongoDB roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRoles(
            options?: RawAxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListMongoRolesResponseDTO>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRoles(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['MDBApi.listRoles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary List storage classes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listStorageClasses(
            options?: RawAxiosRequestConfig,
        ): Promise<
            (
                axios?: AxiosInstance,
                basePath?: string,
            ) => AxiosPromise<ListStorageClassesResponseDTO>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listStorageClasses(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['MDBApi.listStorageClasses']?.[localVarOperationServerIndex]
                    ?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary List MongoDB users
         * @param {string} clusterId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUsers(
            clusterId: string,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListMongoUsersResponseDTO>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUsers(clusterId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['MDBApi.listUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary List MongoDB versions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listVersions(
            options?: RawAxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListMongoVersionsResponseDTO>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listVersions(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['MDBApi.listVersions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Restart operation
         * @param {string} operationId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restartOperation(
            operationId: string,
            options?: RawAxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restartOperation(
                operationId,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['MDBApi.restartOperation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Restore MongoDB cluster
         * @param {string} clusterId
         * @param {string} backupName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restoreCluster(
            clusterId: string,
            backupName: string,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduledOperationDTO>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restoreCluster(
                clusterId,
                backupName,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['MDBApi.restoreCluster']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Simulate usage of quotas for MongoDB cluster
         * @param {SimulateMongoDBQuotasUsageRequest} simulateMongoDBQuotasUsageRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async simulateMongoDbQuotasUsage(
            simulateMongoDBQuotasUsageRequest: SimulateMongoDBQuotasUsageRequest,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (
                axios?: AxiosInstance,
                basePath?: string,
            ) => AxiosPromise<SimulateMongoDBQuotasUsageResponse>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.simulateMongoDbQuotasUsage(
                simulateMongoDBQuotasUsageRequest,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['MDBApi.simulateMongoDbQuotasUsage']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Simulate transfer of MDB quotas between products
         * @param {TransferQuotasBetweenProductsRequest} transferQuotasBetweenProductsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async simulateTransferQuotasBetweenProducts(
            transferQuotasBetweenProductsRequest: TransferQuotasBetweenProductsRequest,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (
                axios?: AxiosInstance,
                basePath?: string,
            ) => AxiosPromise<SimulateTransferQuotasBetweenProductsResponse>
        > {
            const localVarAxiosArgs =
                await localVarAxiosParamCreator.simulateTransferQuotasBetweenProducts(
                    transferQuotasBetweenProductsRequest,
                    options,
                );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['MDBApi.simulateTransferQuotasBetweenProducts']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Exchange MDB quotas between products
         * @param {TransferQuotasBetweenProductsRequest} transferQuotasBetweenProductsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transferQuotasBetweenProducts(
            transferQuotasBetweenProductsRequest: TransferQuotasBetweenProductsRequest,
            options?: RawAxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transferQuotasBetweenProducts(
                transferQuotasBetweenProductsRequest,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['MDBApi.transferQuotasBetweenProducts']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Update MongoDB cluster
         * @param {string} clusterId
         * @param {UpdateMongoClusterRequestDTO} updateMongoClusterRequestDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCluster(
            clusterId: string,
            updateMongoClusterRequestDTO: UpdateMongoClusterRequestDTO,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduledOperationDTO>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCluster(
                clusterId,
                updateMongoClusterRequestDTO,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['MDBApi.updateCluster']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Update MongoDB hosts
         * @param {UpdateMongoHostsRequest} updateMongoHostsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateHosts(
            updateMongoHostsRequest: UpdateMongoHostsRequest,
            options?: RawAxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateHosts(
                updateMongoHostsRequest,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['MDBApi.updateHosts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Update project
         * @param {string} projectId
         * @param {UpdateProjectRequestDTO} updateProjectRequestDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProject(
            projectId: string,
            updateProjectRequestDTO: UpdateProjectRequestDTO,
            options?: RawAxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProject(
                projectId,
                updateProjectRequestDTO,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['MDBApi.updateProject']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Update resource preset
         * @param {string} resourcePresetId
         * @param {V1UpdateResourcePresetRequest} v1UpdateResourcePresetRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateResourcePreset(
            resourcePresetId: string,
            v1UpdateResourcePresetRequest: V1UpdateResourcePresetRequest,
            options?: RawAxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateResourcePreset(
                resourcePresetId,
                v1UpdateResourcePresetRequest,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['MDBApi.updateResourcePreset']?.[localVarOperationServerIndex]
                    ?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Upload MDB quotas to multiple products
         * @param {UploadQuotasToProductsRequest} uploadQuotasToProductsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadQuotasToProducts(
            uploadQuotasToProductsRequest: UploadQuotasToProductsRequest,
            options?: RawAxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadQuotasToProducts(
                uploadQuotasToProductsRequest,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['MDBApi.uploadQuotasToProducts']?.[localVarOperationServerIndex]
                    ?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
    };
};

/**
 * MDBApi - factory interface
 * @export
 */
export const MDBApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = MDBApiFp(configuration);
    return {
        /**
         *
         * @summary Create MongoDB backup
         * @param {MDBApiCreateBackupRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBackup(
            requestParameters: MDBApiCreateBackupRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<ScheduledOperationDTO> {
            return localVarFp
                .createBackup(requestParameters.clusterId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Create MongoDB cluster
         * @param {MDBApiCreateClusterRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCluster(
            requestParameters: MDBApiCreateClusterRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<CreateMongoClusterResponseDTO> {
            return localVarFp
                .createCluster(requestParameters.createMongoClusterRequestDTO, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Create MongoDB database
         * @param {MDBApiCreateDatabaseRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDatabase(
            requestParameters: MDBApiCreateDatabaseRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<ScheduledOperationDTO> {
            return localVarFp
                .createDatabase(
                    requestParameters.clusterId,
                    requestParameters.createMongoDatabaseRequestDTO,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Create project
         * @param {MDBApiCreateProjectRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProject(
            requestParameters: MDBApiCreateProjectRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<CreateProjectResponseDTO> {
            return localVarFp
                .createProject(requestParameters.createProjectRequestDTO, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Create resource preset
         * @param {MDBApiCreateResourcePresetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createResourcePreset(
            requestParameters: MDBApiCreateResourcePresetRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .createResourcePreset(requestParameters.v1CreateResourcePresetRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Create MongoDB user
         * @param {MDBApiCreateUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(
            requestParameters: MDBApiCreateUserRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<ScheduledOperationDTO> {
            return localVarFp
                .createUser(
                    requestParameters.clusterId,
                    requestParameters.createMongoUserRequestDTO,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete backup of MongoDB cluster
         * @param {MDBApiDeleteBackupRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBackup(
            requestParameters: MDBApiDeleteBackupRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<ScheduledOperationDTO> {
            return localVarFp
                .deleteBackup(requestParameters.clusterId, requestParameters.backupName, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete MongoDB cluster
         * @param {MDBApiDeleteClusterRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCluster(
            requestParameters: MDBApiDeleteClusterRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<ScheduledOperationDTO> {
            return localVarFp
                .deleteCluster(requestParameters.clusterId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete MongoDB database
         * @param {MDBApiDeleteDatabaseRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDatabase(
            requestParameters: MDBApiDeleteDatabaseRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<ScheduledOperationDTO> {
            return localVarFp
                .deleteDatabase(
                    requestParameters.clusterId,
                    requestParameters.databaseName,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete project
         * @param {MDBApiDeleteProjectRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProject(
            requestParameters: MDBApiDeleteProjectRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .deleteProject(requestParameters.projectId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete resource preset
         * @param {MDBApiDeleteResourcePresetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResourcePreset(
            requestParameters: MDBApiDeleteResourcePresetRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .deleteResourcePreset(requestParameters.resourcePresetId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete MongoDB user
         * @param {MDBApiDeleteUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(
            requestParameters: MDBApiDeleteUserRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<ScheduledOperationDTO> {
            return localVarFp
                .deleteUser(requestParameters.clusterId, requestParameters.userName, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get MongoDB cluster
         * @param {MDBApiGetClusterRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCluster(
            requestParameters: MDBApiGetClusterRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<MongoClusterDTO> {
            return localVarFp
                .getCluster(requestParameters.clusterId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get product quota usage report
         * @param {MDBApiGetProductQuotaUsageReportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductQuotaUsageReport(
            requestParameters: MDBApiGetProductQuotaUsageReportRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<GetProductQuotaUsageReportResponseOA> {
            return localVarFp
                .getProductQuotaUsageReport(
                    requestParameters.productId,
                    requestParameters.startDate,
                    requestParameters.endDate,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get project
         * @param {MDBApiGetProjectRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject(
            requestParameters: MDBApiGetProjectRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<ProjectDTO> {
            return localVarFp
                .getProject(requestParameters.projectId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get resource preset
         * @param {MDBApiGetResourcePresetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResourcePreset(
            requestParameters: MDBApiGetResourcePresetRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<V1ResourcePresetResponse> {
            return localVarFp
                .getResourcePreset(requestParameters.resourcePresetId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List MongoDB backups
         * @param {MDBApiListBackupsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBackups(
            requestParameters: MDBApiListBackupsRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<ListMongoBackupsResponseDTO> {
            return localVarFp
                .listBackups(requestParameters.clusterId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List MongoDB clusters
         * @param {MDBApiListClustersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listClusters(
            requestParameters: MDBApiListClustersRequest = {},
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<ListMongoClustersResponseDTO> {
            return localVarFp
                .listClusters(requestParameters.projectIds, requestParameters.isDeleted, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List MongoDB databases
         * @param {MDBApiListDatabasesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabases(
            requestParameters: MDBApiListDatabasesRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<ListMongoDatabasesResponseDTO> {
            return localVarFp
                .listDatabases(requestParameters.clusterId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List namespaces
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNamespaces(options?: RawAxiosRequestConfig): AxiosPromise<ListNamespacesResponseDTO> {
            return localVarFp.listNamespaces(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List operations
         * @param {MDBApiListOperationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOperations(
            requestParameters: MDBApiListOperationsRequest = {},
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<ListOperationsResponseDTO> {
            return localVarFp
                .listOperations(requestParameters.clusterId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List projects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjects(options?: RawAxiosRequestConfig): AxiosPromise<ListProjectsResponseDTO> {
            return localVarFp.listProjects(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List MDB quotas by products
         * @param {MDBApiListQuotasByProductsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQuotasByProducts(
            requestParameters: MDBApiListQuotasByProductsRequest = {},
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<ListQuotasByProductsResponse> {
            return localVarFp
                .listQuotasByProducts(requestParameters.productIds, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get resource presets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResourcePresets(
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<V1ListResourcePresetsResponse> {
            return localVarFp
                .listResourcePresets(options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List MDB resources
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResources(options?: RawAxiosRequestConfig): AxiosPromise<ListResourcesResponse> {
            return localVarFp.listResources(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List available MongoDB roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoles(options?: RawAxiosRequestConfig): AxiosPromise<ListMongoRolesResponseDTO> {
            return localVarFp.listRoles(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List storage classes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listStorageClasses(
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<ListStorageClassesResponseDTO> {
            return localVarFp
                .listStorageClasses(options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List MongoDB users
         * @param {MDBApiListUsersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers(
            requestParameters: MDBApiListUsersRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<ListMongoUsersResponseDTO> {
            return localVarFp
                .listUsers(requestParameters.clusterId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List MongoDB versions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVersions(options?: RawAxiosRequestConfig): AxiosPromise<ListMongoVersionsResponseDTO> {
            return localVarFp.listVersions(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Restart operation
         * @param {MDBApiRestartOperationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartOperation(
            requestParameters: MDBApiRestartOperationRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .restartOperation(requestParameters.operationId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Restore MongoDB cluster
         * @param {MDBApiRestoreClusterRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreCluster(
            requestParameters: MDBApiRestoreClusterRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<ScheduledOperationDTO> {
            return localVarFp
                .restoreCluster(requestParameters.clusterId, requestParameters.backupName, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Simulate usage of quotas for MongoDB cluster
         * @param {MDBApiSimulateMongoDbQuotasUsageRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simulateMongoDbQuotasUsage(
            requestParameters: MDBApiSimulateMongoDbQuotasUsageRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<SimulateMongoDBQuotasUsageResponse> {
            return localVarFp
                .simulateMongoDbQuotasUsage(
                    requestParameters.simulateMongoDBQuotasUsageRequest,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Simulate transfer of MDB quotas between products
         * @param {MDBApiSimulateTransferQuotasBetweenProductsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simulateTransferQuotasBetweenProducts(
            requestParameters: MDBApiSimulateTransferQuotasBetweenProductsRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<SimulateTransferQuotasBetweenProductsResponse> {
            return localVarFp
                .simulateTransferQuotasBetweenProducts(
                    requestParameters.transferQuotasBetweenProductsRequest,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Exchange MDB quotas between products
         * @param {MDBApiTransferQuotasBetweenProductsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transferQuotasBetweenProducts(
            requestParameters: MDBApiTransferQuotasBetweenProductsRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .transferQuotasBetweenProducts(
                    requestParameters.transferQuotasBetweenProductsRequest,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update MongoDB cluster
         * @param {MDBApiUpdateClusterRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCluster(
            requestParameters: MDBApiUpdateClusterRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<ScheduledOperationDTO> {
            return localVarFp
                .updateCluster(
                    requestParameters.clusterId,
                    requestParameters.updateMongoClusterRequestDTO,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update MongoDB hosts
         * @param {MDBApiUpdateHostsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHosts(
            requestParameters: MDBApiUpdateHostsRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .updateHosts(requestParameters.updateMongoHostsRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update project
         * @param {MDBApiUpdateProjectRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProject(
            requestParameters: MDBApiUpdateProjectRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .updateProject(
                    requestParameters.projectId,
                    requestParameters.updateProjectRequestDTO,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update resource preset
         * @param {MDBApiUpdateResourcePresetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResourcePreset(
            requestParameters: MDBApiUpdateResourcePresetRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .updateResourcePreset(
                    requestParameters.resourcePresetId,
                    requestParameters.v1UpdateResourcePresetRequest,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Upload MDB quotas to multiple products
         * @param {MDBApiUploadQuotasToProductsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadQuotasToProducts(
            requestParameters: MDBApiUploadQuotasToProductsRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .uploadQuotasToProducts(requestParameters.uploadQuotasToProductsRequest, options)
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createBackup operation in MDBApi.
 * @export
 * @interface MDBApiCreateBackupRequest
 */
export interface MDBApiCreateBackupRequest {
    /**
     *
     * @type {string}
     * @memberof MDBApiCreateBackup
     */
    readonly clusterId: string;
}

/**
 * Request parameters for createCluster operation in MDBApi.
 * @export
 * @interface MDBApiCreateClusterRequest
 */
export interface MDBApiCreateClusterRequest {
    /**
     *
     * @type {CreateMongoClusterRequestDTO}
     * @memberof MDBApiCreateCluster
     */
    readonly createMongoClusterRequestDTO: CreateMongoClusterRequestDTO;
}

/**
 * Request parameters for createDatabase operation in MDBApi.
 * @export
 * @interface MDBApiCreateDatabaseRequest
 */
export interface MDBApiCreateDatabaseRequest {
    /**
     *
     * @type {string}
     * @memberof MDBApiCreateDatabase
     */
    readonly clusterId: string;

    /**
     *
     * @type {CreateMongoDatabaseRequestDTO}
     * @memberof MDBApiCreateDatabase
     */
    readonly createMongoDatabaseRequestDTO: CreateMongoDatabaseRequestDTO;
}

/**
 * Request parameters for createProject operation in MDBApi.
 * @export
 * @interface MDBApiCreateProjectRequest
 */
export interface MDBApiCreateProjectRequest {
    /**
     *
     * @type {CreateProjectRequestDTO}
     * @memberof MDBApiCreateProject
     */
    readonly createProjectRequestDTO: CreateProjectRequestDTO;
}

/**
 * Request parameters for createResourcePreset operation in MDBApi.
 * @export
 * @interface MDBApiCreateResourcePresetRequest
 */
export interface MDBApiCreateResourcePresetRequest {
    /**
     *
     * @type {V1CreateResourcePresetRequest}
     * @memberof MDBApiCreateResourcePreset
     */
    readonly v1CreateResourcePresetRequest: V1CreateResourcePresetRequest;
}

/**
 * Request parameters for createUser operation in MDBApi.
 * @export
 * @interface MDBApiCreateUserRequest
 */
export interface MDBApiCreateUserRequest {
    /**
     *
     * @type {string}
     * @memberof MDBApiCreateUser
     */
    readonly clusterId: string;

    /**
     *
     * @type {CreateMongoUserRequestDTO}
     * @memberof MDBApiCreateUser
     */
    readonly createMongoUserRequestDTO: CreateMongoUserRequestDTO;
}

/**
 * Request parameters for deleteBackup operation in MDBApi.
 * @export
 * @interface MDBApiDeleteBackupRequest
 */
export interface MDBApiDeleteBackupRequest {
    /**
     *
     * @type {string}
     * @memberof MDBApiDeleteBackup
     */
    readonly clusterId: string;

    /**
     *
     * @type {string}
     * @memberof MDBApiDeleteBackup
     */
    readonly backupName: string;
}

/**
 * Request parameters for deleteCluster operation in MDBApi.
 * @export
 * @interface MDBApiDeleteClusterRequest
 */
export interface MDBApiDeleteClusterRequest {
    /**
     *
     * @type {string}
     * @memberof MDBApiDeleteCluster
     */
    readonly clusterId: string;
}

/**
 * Request parameters for deleteDatabase operation in MDBApi.
 * @export
 * @interface MDBApiDeleteDatabaseRequest
 */
export interface MDBApiDeleteDatabaseRequest {
    /**
     *
     * @type {string}
     * @memberof MDBApiDeleteDatabase
     */
    readonly clusterId: string;

    /**
     *
     * @type {string}
     * @memberof MDBApiDeleteDatabase
     */
    readonly databaseName: string;
}

/**
 * Request parameters for deleteProject operation in MDBApi.
 * @export
 * @interface MDBApiDeleteProjectRequest
 */
export interface MDBApiDeleteProjectRequest {
    /**
     *
     * @type {string}
     * @memberof MDBApiDeleteProject
     */
    readonly projectId: string;
}

/**
 * Request parameters for deleteResourcePreset operation in MDBApi.
 * @export
 * @interface MDBApiDeleteResourcePresetRequest
 */
export interface MDBApiDeleteResourcePresetRequest {
    /**
     *
     * @type {string}
     * @memberof MDBApiDeleteResourcePreset
     */
    readonly resourcePresetId: string;
}

/**
 * Request parameters for deleteUser operation in MDBApi.
 * @export
 * @interface MDBApiDeleteUserRequest
 */
export interface MDBApiDeleteUserRequest {
    /**
     *
     * @type {string}
     * @memberof MDBApiDeleteUser
     */
    readonly clusterId: string;

    /**
     *
     * @type {string}
     * @memberof MDBApiDeleteUser
     */
    readonly userName: string;
}

/**
 * Request parameters for getCluster operation in MDBApi.
 * @export
 * @interface MDBApiGetClusterRequest
 */
export interface MDBApiGetClusterRequest {
    /**
     *
     * @type {string}
     * @memberof MDBApiGetCluster
     */
    readonly clusterId: string;
}

/**
 * Request parameters for getProductQuotaUsageReport operation in MDBApi.
 * @export
 * @interface MDBApiGetProductQuotaUsageReportRequest
 */
export interface MDBApiGetProductQuotaUsageReportRequest {
    /**
     *
     * @type {string}
     * @memberof MDBApiGetProductQuotaUsageReport
     */
    readonly productId: string;

    /**
     *
     * @type {string}
     * @memberof MDBApiGetProductQuotaUsageReport
     */
    readonly startDate: string;

    /**
     *
     * @type {string}
     * @memberof MDBApiGetProductQuotaUsageReport
     */
    readonly endDate: string;
}

/**
 * Request parameters for getProject operation in MDBApi.
 * @export
 * @interface MDBApiGetProjectRequest
 */
export interface MDBApiGetProjectRequest {
    /**
     *
     * @type {string}
     * @memberof MDBApiGetProject
     */
    readonly projectId: string;
}

/**
 * Request parameters for getResourcePreset operation in MDBApi.
 * @export
 * @interface MDBApiGetResourcePresetRequest
 */
export interface MDBApiGetResourcePresetRequest {
    /**
     *
     * @type {string}
     * @memberof MDBApiGetResourcePreset
     */
    readonly resourcePresetId: string;
}

/**
 * Request parameters for listBackups operation in MDBApi.
 * @export
 * @interface MDBApiListBackupsRequest
 */
export interface MDBApiListBackupsRequest {
    /**
     *
     * @type {string}
     * @memberof MDBApiListBackups
     */
    readonly clusterId: string;
}

/**
 * Request parameters for listClusters operation in MDBApi.
 * @export
 * @interface MDBApiListClustersRequest
 */
export interface MDBApiListClustersRequest {
    /**
     *
     * @type {Array<string>}
     * @memberof MDBApiListClusters
     */
    readonly projectIds?: Array<string>;

    /**
     *
     * @type {boolean}
     * @memberof MDBApiListClusters
     */
    readonly isDeleted?: boolean;
}

/**
 * Request parameters for listDatabases operation in MDBApi.
 * @export
 * @interface MDBApiListDatabasesRequest
 */
export interface MDBApiListDatabasesRequest {
    /**
     *
     * @type {string}
     * @memberof MDBApiListDatabases
     */
    readonly clusterId: string;
}

/**
 * Request parameters for listOperations operation in MDBApi.
 * @export
 * @interface MDBApiListOperationsRequest
 */
export interface MDBApiListOperationsRequest {
    /**
     *
     * @type {string}
     * @memberof MDBApiListOperations
     */
    readonly clusterId?: string;
}

/**
 * Request parameters for listQuotasByProducts operation in MDBApi.
 * @export
 * @interface MDBApiListQuotasByProductsRequest
 */
export interface MDBApiListQuotasByProductsRequest {
    /**
     *
     * @type {Array<string>}
     * @memberof MDBApiListQuotasByProducts
     */
    readonly productIds?: Array<string>;
}

/**
 * Request parameters for listUsers operation in MDBApi.
 * @export
 * @interface MDBApiListUsersRequest
 */
export interface MDBApiListUsersRequest {
    /**
     *
     * @type {string}
     * @memberof MDBApiListUsers
     */
    readonly clusterId: string;
}

/**
 * Request parameters for restartOperation operation in MDBApi.
 * @export
 * @interface MDBApiRestartOperationRequest
 */
export interface MDBApiRestartOperationRequest {
    /**
     *
     * @type {string}
     * @memberof MDBApiRestartOperation
     */
    readonly operationId: string;
}

/**
 * Request parameters for restoreCluster operation in MDBApi.
 * @export
 * @interface MDBApiRestoreClusterRequest
 */
export interface MDBApiRestoreClusterRequest {
    /**
     *
     * @type {string}
     * @memberof MDBApiRestoreCluster
     */
    readonly clusterId: string;

    /**
     *
     * @type {string}
     * @memberof MDBApiRestoreCluster
     */
    readonly backupName: string;
}

/**
 * Request parameters for simulateMongoDbQuotasUsage operation in MDBApi.
 * @export
 * @interface MDBApiSimulateMongoDbQuotasUsageRequest
 */
export interface MDBApiSimulateMongoDbQuotasUsageRequest {
    /**
     *
     * @type {SimulateMongoDBQuotasUsageRequest}
     * @memberof MDBApiSimulateMongoDbQuotasUsage
     */
    readonly simulateMongoDBQuotasUsageRequest: SimulateMongoDBQuotasUsageRequest;
}

/**
 * Request parameters for simulateTransferQuotasBetweenProducts operation in MDBApi.
 * @export
 * @interface MDBApiSimulateTransferQuotasBetweenProductsRequest
 */
export interface MDBApiSimulateTransferQuotasBetweenProductsRequest {
    /**
     *
     * @type {TransferQuotasBetweenProductsRequest}
     * @memberof MDBApiSimulateTransferQuotasBetweenProducts
     */
    readonly transferQuotasBetweenProductsRequest: TransferQuotasBetweenProductsRequest;
}

/**
 * Request parameters for transferQuotasBetweenProducts operation in MDBApi.
 * @export
 * @interface MDBApiTransferQuotasBetweenProductsRequest
 */
export interface MDBApiTransferQuotasBetweenProductsRequest {
    /**
     *
     * @type {TransferQuotasBetweenProductsRequest}
     * @memberof MDBApiTransferQuotasBetweenProducts
     */
    readonly transferQuotasBetweenProductsRequest: TransferQuotasBetweenProductsRequest;
}

/**
 * Request parameters for updateCluster operation in MDBApi.
 * @export
 * @interface MDBApiUpdateClusterRequest
 */
export interface MDBApiUpdateClusterRequest {
    /**
     *
     * @type {string}
     * @memberof MDBApiUpdateCluster
     */
    readonly clusterId: string;

    /**
     *
     * @type {UpdateMongoClusterRequestDTO}
     * @memberof MDBApiUpdateCluster
     */
    readonly updateMongoClusterRequestDTO: UpdateMongoClusterRequestDTO;
}

/**
 * Request parameters for updateHosts operation in MDBApi.
 * @export
 * @interface MDBApiUpdateHostsRequest
 */
export interface MDBApiUpdateHostsRequest {
    /**
     *
     * @type {UpdateMongoHostsRequest}
     * @memberof MDBApiUpdateHosts
     */
    readonly updateMongoHostsRequest: UpdateMongoHostsRequest;
}

/**
 * Request parameters for updateProject operation in MDBApi.
 * @export
 * @interface MDBApiUpdateProjectRequest
 */
export interface MDBApiUpdateProjectRequest {
    /**
     *
     * @type {string}
     * @memberof MDBApiUpdateProject
     */
    readonly projectId: string;

    /**
     *
     * @type {UpdateProjectRequestDTO}
     * @memberof MDBApiUpdateProject
     */
    readonly updateProjectRequestDTO: UpdateProjectRequestDTO;
}

/**
 * Request parameters for updateResourcePreset operation in MDBApi.
 * @export
 * @interface MDBApiUpdateResourcePresetRequest
 */
export interface MDBApiUpdateResourcePresetRequest {
    /**
     *
     * @type {string}
     * @memberof MDBApiUpdateResourcePreset
     */
    readonly resourcePresetId: string;

    /**
     *
     * @type {V1UpdateResourcePresetRequest}
     * @memberof MDBApiUpdateResourcePreset
     */
    readonly v1UpdateResourcePresetRequest: V1UpdateResourcePresetRequest;
}

/**
 * Request parameters for uploadQuotasToProducts operation in MDBApi.
 * @export
 * @interface MDBApiUploadQuotasToProductsRequest
 */
export interface MDBApiUploadQuotasToProductsRequest {
    /**
     *
     * @type {UploadQuotasToProductsRequest}
     * @memberof MDBApiUploadQuotasToProducts
     */
    readonly uploadQuotasToProductsRequest: UploadQuotasToProductsRequest;
}

/**
 * MDBApi - object-oriented interface
 * @export
 * @class MDBApi
 * @extends {BaseAPI}
 */
export class MDBApi extends BaseAPI {
    /**
     *
     * @summary Create MongoDB backup
     * @param {MDBApiCreateBackupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MDBApi
     */
    public createBackup(
        requestParameters: MDBApiCreateBackupRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return MDBApiFp(this.configuration)
            .createBackup(requestParameters.clusterId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Create MongoDB cluster
     * @param {MDBApiCreateClusterRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MDBApi
     */
    public createCluster(
        requestParameters: MDBApiCreateClusterRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return MDBApiFp(this.configuration)
            .createCluster(requestParameters.createMongoClusterRequestDTO, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Create MongoDB database
     * @param {MDBApiCreateDatabaseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MDBApi
     */
    public createDatabase(
        requestParameters: MDBApiCreateDatabaseRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return MDBApiFp(this.configuration)
            .createDatabase(
                requestParameters.clusterId,
                requestParameters.createMongoDatabaseRequestDTO,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Create project
     * @param {MDBApiCreateProjectRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MDBApi
     */
    public createProject(
        requestParameters: MDBApiCreateProjectRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return MDBApiFp(this.configuration)
            .createProject(requestParameters.createProjectRequestDTO, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Create resource preset
     * @param {MDBApiCreateResourcePresetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MDBApi
     */
    public createResourcePreset(
        requestParameters: MDBApiCreateResourcePresetRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return MDBApiFp(this.configuration)
            .createResourcePreset(requestParameters.v1CreateResourcePresetRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Create MongoDB user
     * @param {MDBApiCreateUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MDBApi
     */
    public createUser(requestParameters: MDBApiCreateUserRequest, options?: RawAxiosRequestConfig) {
        return MDBApiFp(this.configuration)
            .createUser(
                requestParameters.clusterId,
                requestParameters.createMongoUserRequestDTO,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Delete backup of MongoDB cluster
     * @param {MDBApiDeleteBackupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MDBApi
     */
    public deleteBackup(
        requestParameters: MDBApiDeleteBackupRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return MDBApiFp(this.configuration)
            .deleteBackup(requestParameters.clusterId, requestParameters.backupName, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Delete MongoDB cluster
     * @param {MDBApiDeleteClusterRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MDBApi
     */
    public deleteCluster(
        requestParameters: MDBApiDeleteClusterRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return MDBApiFp(this.configuration)
            .deleteCluster(requestParameters.clusterId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Delete MongoDB database
     * @param {MDBApiDeleteDatabaseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MDBApi
     */
    public deleteDatabase(
        requestParameters: MDBApiDeleteDatabaseRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return MDBApiFp(this.configuration)
            .deleteDatabase(requestParameters.clusterId, requestParameters.databaseName, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Delete project
     * @param {MDBApiDeleteProjectRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MDBApi
     */
    public deleteProject(
        requestParameters: MDBApiDeleteProjectRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return MDBApiFp(this.configuration)
            .deleteProject(requestParameters.projectId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Delete resource preset
     * @param {MDBApiDeleteResourcePresetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MDBApi
     */
    public deleteResourcePreset(
        requestParameters: MDBApiDeleteResourcePresetRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return MDBApiFp(this.configuration)
            .deleteResourcePreset(requestParameters.resourcePresetId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Delete MongoDB user
     * @param {MDBApiDeleteUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MDBApi
     */
    public deleteUser(requestParameters: MDBApiDeleteUserRequest, options?: RawAxiosRequestConfig) {
        return MDBApiFp(this.configuration)
            .deleteUser(requestParameters.clusterId, requestParameters.userName, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get MongoDB cluster
     * @param {MDBApiGetClusterRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MDBApi
     */
    public getCluster(requestParameters: MDBApiGetClusterRequest, options?: RawAxiosRequestConfig) {
        return MDBApiFp(this.configuration)
            .getCluster(requestParameters.clusterId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get product quota usage report
     * @param {MDBApiGetProductQuotaUsageReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MDBApi
     */
    public getProductQuotaUsageReport(
        requestParameters: MDBApiGetProductQuotaUsageReportRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return MDBApiFp(this.configuration)
            .getProductQuotaUsageReport(
                requestParameters.productId,
                requestParameters.startDate,
                requestParameters.endDate,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get project
     * @param {MDBApiGetProjectRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MDBApi
     */
    public getProject(requestParameters: MDBApiGetProjectRequest, options?: RawAxiosRequestConfig) {
        return MDBApiFp(this.configuration)
            .getProject(requestParameters.projectId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get resource preset
     * @param {MDBApiGetResourcePresetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MDBApi
     */
    public getResourcePreset(
        requestParameters: MDBApiGetResourcePresetRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return MDBApiFp(this.configuration)
            .getResourcePreset(requestParameters.resourcePresetId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary List MongoDB backups
     * @param {MDBApiListBackupsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MDBApi
     */
    public listBackups(
        requestParameters: MDBApiListBackupsRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return MDBApiFp(this.configuration)
            .listBackups(requestParameters.clusterId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary List MongoDB clusters
     * @param {MDBApiListClustersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MDBApi
     */
    public listClusters(
        requestParameters: MDBApiListClustersRequest = {},
        options?: RawAxiosRequestConfig,
    ) {
        return MDBApiFp(this.configuration)
            .listClusters(requestParameters.projectIds, requestParameters.isDeleted, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary List MongoDB databases
     * @param {MDBApiListDatabasesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MDBApi
     */
    public listDatabases(
        requestParameters: MDBApiListDatabasesRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return MDBApiFp(this.configuration)
            .listDatabases(requestParameters.clusterId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary List namespaces
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MDBApi
     */
    public listNamespaces(options?: RawAxiosRequestConfig) {
        return MDBApiFp(this.configuration)
            .listNamespaces(options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary List operations
     * @param {MDBApiListOperationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MDBApi
     */
    public listOperations(
        requestParameters: MDBApiListOperationsRequest = {},
        options?: RawAxiosRequestConfig,
    ) {
        return MDBApiFp(this.configuration)
            .listOperations(requestParameters.clusterId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary List projects
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MDBApi
     */
    public listProjects(options?: RawAxiosRequestConfig) {
        return MDBApiFp(this.configuration)
            .listProjects(options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary List MDB quotas by products
     * @param {MDBApiListQuotasByProductsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MDBApi
     */
    public listQuotasByProducts(
        requestParameters: MDBApiListQuotasByProductsRequest = {},
        options?: RawAxiosRequestConfig,
    ) {
        return MDBApiFp(this.configuration)
            .listQuotasByProducts(requestParameters.productIds, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get resource presets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MDBApi
     */
    public listResourcePresets(options?: RawAxiosRequestConfig) {
        return MDBApiFp(this.configuration)
            .listResourcePresets(options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary List MDB resources
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MDBApi
     */
    public listResources(options?: RawAxiosRequestConfig) {
        return MDBApiFp(this.configuration)
            .listResources(options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary List available MongoDB roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MDBApi
     */
    public listRoles(options?: RawAxiosRequestConfig) {
        return MDBApiFp(this.configuration)
            .listRoles(options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary List storage classes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MDBApi
     */
    public listStorageClasses(options?: RawAxiosRequestConfig) {
        return MDBApiFp(this.configuration)
            .listStorageClasses(options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary List MongoDB users
     * @param {MDBApiListUsersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MDBApi
     */
    public listUsers(requestParameters: MDBApiListUsersRequest, options?: RawAxiosRequestConfig) {
        return MDBApiFp(this.configuration)
            .listUsers(requestParameters.clusterId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary List MongoDB versions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MDBApi
     */
    public listVersions(options?: RawAxiosRequestConfig) {
        return MDBApiFp(this.configuration)
            .listVersions(options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Restart operation
     * @param {MDBApiRestartOperationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MDBApi
     */
    public restartOperation(
        requestParameters: MDBApiRestartOperationRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return MDBApiFp(this.configuration)
            .restartOperation(requestParameters.operationId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Restore MongoDB cluster
     * @param {MDBApiRestoreClusterRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MDBApi
     */
    public restoreCluster(
        requestParameters: MDBApiRestoreClusterRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return MDBApiFp(this.configuration)
            .restoreCluster(requestParameters.clusterId, requestParameters.backupName, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Simulate usage of quotas for MongoDB cluster
     * @param {MDBApiSimulateMongoDbQuotasUsageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MDBApi
     */
    public simulateMongoDbQuotasUsage(
        requestParameters: MDBApiSimulateMongoDbQuotasUsageRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return MDBApiFp(this.configuration)
            .simulateMongoDbQuotasUsage(
                requestParameters.simulateMongoDBQuotasUsageRequest,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Simulate transfer of MDB quotas between products
     * @param {MDBApiSimulateTransferQuotasBetweenProductsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MDBApi
     */
    public simulateTransferQuotasBetweenProducts(
        requestParameters: MDBApiSimulateTransferQuotasBetweenProductsRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return MDBApiFp(this.configuration)
            .simulateTransferQuotasBetweenProducts(
                requestParameters.transferQuotasBetweenProductsRequest,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Exchange MDB quotas between products
     * @param {MDBApiTransferQuotasBetweenProductsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MDBApi
     */
    public transferQuotasBetweenProducts(
        requestParameters: MDBApiTransferQuotasBetweenProductsRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return MDBApiFp(this.configuration)
            .transferQuotasBetweenProducts(
                requestParameters.transferQuotasBetweenProductsRequest,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Update MongoDB cluster
     * @param {MDBApiUpdateClusterRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MDBApi
     */
    public updateCluster(
        requestParameters: MDBApiUpdateClusterRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return MDBApiFp(this.configuration)
            .updateCluster(
                requestParameters.clusterId,
                requestParameters.updateMongoClusterRequestDTO,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Update MongoDB hosts
     * @param {MDBApiUpdateHostsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MDBApi
     */
    public updateHosts(
        requestParameters: MDBApiUpdateHostsRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return MDBApiFp(this.configuration)
            .updateHosts(requestParameters.updateMongoHostsRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Update project
     * @param {MDBApiUpdateProjectRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MDBApi
     */
    public updateProject(
        requestParameters: MDBApiUpdateProjectRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return MDBApiFp(this.configuration)
            .updateProject(
                requestParameters.projectId,
                requestParameters.updateProjectRequestDTO,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Update resource preset
     * @param {MDBApiUpdateResourcePresetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MDBApi
     */
    public updateResourcePreset(
        requestParameters: MDBApiUpdateResourcePresetRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return MDBApiFp(this.configuration)
            .updateResourcePreset(
                requestParameters.resourcePresetId,
                requestParameters.v1UpdateResourcePresetRequest,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Upload MDB quotas to multiple products
     * @param {MDBApiUploadQuotasToProductsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MDBApi
     */
    public uploadQuotasToProducts(
        requestParameters: MDBApiUploadQuotasToProductsRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return MDBApiFp(this.configuration)
            .uploadQuotasToProducts(requestParameters.uploadQuotasToProductsRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
}

/**
 * MDBCommonApi - axios parameter creator
 * @export
 */
export const MDBCommonApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary List namespaces
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNamespaces: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/mdb/namespaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List storage classes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listStorageClasses: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/mdb/storage-classes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * MDBCommonApi - functional programming interface
 * @export
 */
export const MDBCommonApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = MDBCommonApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary List namespaces
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listNamespaces(
            options?: RawAxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListNamespacesResponseDTO>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listNamespaces(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['MDBCommonApi.listNamespaces']?.[localVarOperationServerIndex]
                    ?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary List storage classes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listStorageClasses(
            options?: RawAxiosRequestConfig,
        ): Promise<
            (
                axios?: AxiosInstance,
                basePath?: string,
            ) => AxiosPromise<ListStorageClassesResponseDTO>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listStorageClasses(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['MDBCommonApi.listStorageClasses']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
    };
};

/**
 * MDBCommonApi - factory interface
 * @export
 */
export const MDBCommonApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = MDBCommonApiFp(configuration);
    return {
        /**
         *
         * @summary List namespaces
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNamespaces(options?: RawAxiosRequestConfig): AxiosPromise<ListNamespacesResponseDTO> {
            return localVarFp.listNamespaces(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List storage classes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listStorageClasses(
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<ListStorageClassesResponseDTO> {
            return localVarFp
                .listStorageClasses(options)
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * MDBCommonApi - object-oriented interface
 * @export
 * @class MDBCommonApi
 * @extends {BaseAPI}
 */
export class MDBCommonApi extends BaseAPI {
    /**
     *
     * @summary List namespaces
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MDBCommonApi
     */
    public listNamespaces(options?: RawAxiosRequestConfig) {
        return MDBCommonApiFp(this.configuration)
            .listNamespaces(options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary List storage classes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MDBCommonApi
     */
    public listStorageClasses(options?: RawAxiosRequestConfig) {
        return MDBCommonApiFp(this.configuration)
            .listStorageClasses(options)
            .then((request) => request(this.axios, this.basePath));
    }
}

/**
 * MDBQuotasApi - axios parameter creator
 * @export
 */
export const MDBQuotasApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary List MDB quotas by products
         * @param {Array<string>} [productIds]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQuotasByProducts: async (
            productIds?: Array<string>,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            const localVarPath = `/api/quotas/mdb/by-products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            if (productIds) {
                localVarQueryParameter['productIds'] = productIds;
            }

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List MDB resources
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResources: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/quotas/mdb/resources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Simulate usage of quotas for MongoDB cluster
         * @param {SimulateMongoDBQuotasUsageRequest} simulateMongoDBQuotasUsageRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simulateMongoDbQuotasUsage: async (
            simulateMongoDBQuotasUsageRequest: SimulateMongoDBQuotasUsageRequest,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'simulateMongoDBQuotasUsageRequest' is not null or undefined
            assertParamExists(
                'simulateMongoDbQuotasUsage',
                'simulateMongoDBQuotasUsageRequest',
                simulateMongoDBQuotasUsageRequest,
            );
            const localVarPath = `/api/quotas/mdb/managed-mongodb/simulate-usage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = serializeDataIfNeeded(
                simulateMongoDBQuotasUsageRequest,
                localVarRequestOptions,
                configuration,
            );

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Simulate transfer of MDB quotas between products
         * @param {TransferQuotasBetweenProductsRequest} transferQuotasBetweenProductsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simulateTransferQuotasBetweenProducts: async (
            transferQuotasBetweenProductsRequest: TransferQuotasBetweenProductsRequest,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'transferQuotasBetweenProductsRequest' is not null or undefined
            assertParamExists(
                'simulateTransferQuotasBetweenProducts',
                'transferQuotasBetweenProductsRequest',
                transferQuotasBetweenProductsRequest,
            );
            const localVarPath = `/api/quotas/mdb/simulate-transfer-between-products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = serializeDataIfNeeded(
                transferQuotasBetweenProductsRequest,
                localVarRequestOptions,
                configuration,
            );

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Exchange MDB quotas between products
         * @param {TransferQuotasBetweenProductsRequest} transferQuotasBetweenProductsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transferQuotasBetweenProducts: async (
            transferQuotasBetweenProductsRequest: TransferQuotasBetweenProductsRequest,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'transferQuotasBetweenProductsRequest' is not null or undefined
            assertParamExists(
                'transferQuotasBetweenProducts',
                'transferQuotasBetweenProductsRequest',
                transferQuotasBetweenProductsRequest,
            );
            const localVarPath = `/api/quotas/mdb/transfer-between-products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = serializeDataIfNeeded(
                transferQuotasBetweenProductsRequest,
                localVarRequestOptions,
                configuration,
            );

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Upload MDB quotas to multiple products
         * @param {UploadQuotasToProductsRequest} uploadQuotasToProductsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadQuotasToProducts: async (
            uploadQuotasToProductsRequest: UploadQuotasToProductsRequest,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'uploadQuotasToProductsRequest' is not null or undefined
            assertParamExists(
                'uploadQuotasToProducts',
                'uploadQuotasToProductsRequest',
                uploadQuotasToProductsRequest,
            );
            const localVarPath = `/api/quotas/mdb/upload-to-products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = serializeDataIfNeeded(
                uploadQuotasToProductsRequest,
                localVarRequestOptions,
                configuration,
            );

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * MDBQuotasApi - functional programming interface
 * @export
 */
export const MDBQuotasApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = MDBQuotasApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary List MDB quotas by products
         * @param {Array<string>} [productIds]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listQuotasByProducts(
            productIds?: Array<string>,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListQuotasByProductsResponse>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listQuotasByProducts(
                productIds,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['MDBQuotasApi.listQuotasByProducts']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary List MDB resources
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listResources(
            options?: RawAxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListResourcesResponse>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listResources(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['MDBQuotasApi.listResources']?.[localVarOperationServerIndex]
                    ?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Simulate usage of quotas for MongoDB cluster
         * @param {SimulateMongoDBQuotasUsageRequest} simulateMongoDBQuotasUsageRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async simulateMongoDbQuotasUsage(
            simulateMongoDBQuotasUsageRequest: SimulateMongoDBQuotasUsageRequest,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (
                axios?: AxiosInstance,
                basePath?: string,
            ) => AxiosPromise<SimulateMongoDBQuotasUsageResponse>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.simulateMongoDbQuotasUsage(
                simulateMongoDBQuotasUsageRequest,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['MDBQuotasApi.simulateMongoDbQuotasUsage']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Simulate transfer of MDB quotas between products
         * @param {TransferQuotasBetweenProductsRequest} transferQuotasBetweenProductsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async simulateTransferQuotasBetweenProducts(
            transferQuotasBetweenProductsRequest: TransferQuotasBetweenProductsRequest,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (
                axios?: AxiosInstance,
                basePath?: string,
            ) => AxiosPromise<SimulateTransferQuotasBetweenProductsResponse>
        > {
            const localVarAxiosArgs =
                await localVarAxiosParamCreator.simulateTransferQuotasBetweenProducts(
                    transferQuotasBetweenProductsRequest,
                    options,
                );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['MDBQuotasApi.simulateTransferQuotasBetweenProducts']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Exchange MDB quotas between products
         * @param {TransferQuotasBetweenProductsRequest} transferQuotasBetweenProductsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transferQuotasBetweenProducts(
            transferQuotasBetweenProductsRequest: TransferQuotasBetweenProductsRequest,
            options?: RawAxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transferQuotasBetweenProducts(
                transferQuotasBetweenProductsRequest,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['MDBQuotasApi.transferQuotasBetweenProducts']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Upload MDB quotas to multiple products
         * @param {UploadQuotasToProductsRequest} uploadQuotasToProductsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadQuotasToProducts(
            uploadQuotasToProductsRequest: UploadQuotasToProductsRequest,
            options?: RawAxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadQuotasToProducts(
                uploadQuotasToProductsRequest,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['MDBQuotasApi.uploadQuotasToProducts']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
    };
};

/**
 * MDBQuotasApi - factory interface
 * @export
 */
export const MDBQuotasApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = MDBQuotasApiFp(configuration);
    return {
        /**
         *
         * @summary List MDB quotas by products
         * @param {MDBQuotasApiListQuotasByProductsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQuotasByProducts(
            requestParameters: MDBQuotasApiListQuotasByProductsRequest = {},
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<ListQuotasByProductsResponse> {
            return localVarFp
                .listQuotasByProducts(requestParameters.productIds, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List MDB resources
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResources(options?: RawAxiosRequestConfig): AxiosPromise<ListResourcesResponse> {
            return localVarFp.listResources(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Simulate usage of quotas for MongoDB cluster
         * @param {MDBQuotasApiSimulateMongoDbQuotasUsageRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simulateMongoDbQuotasUsage(
            requestParameters: MDBQuotasApiSimulateMongoDbQuotasUsageRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<SimulateMongoDBQuotasUsageResponse> {
            return localVarFp
                .simulateMongoDbQuotasUsage(
                    requestParameters.simulateMongoDBQuotasUsageRequest,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Simulate transfer of MDB quotas between products
         * @param {MDBQuotasApiSimulateTransferQuotasBetweenProductsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simulateTransferQuotasBetweenProducts(
            requestParameters: MDBQuotasApiSimulateTransferQuotasBetweenProductsRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<SimulateTransferQuotasBetweenProductsResponse> {
            return localVarFp
                .simulateTransferQuotasBetweenProducts(
                    requestParameters.transferQuotasBetweenProductsRequest,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Exchange MDB quotas between products
         * @param {MDBQuotasApiTransferQuotasBetweenProductsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transferQuotasBetweenProducts(
            requestParameters: MDBQuotasApiTransferQuotasBetweenProductsRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .transferQuotasBetweenProducts(
                    requestParameters.transferQuotasBetweenProductsRequest,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Upload MDB quotas to multiple products
         * @param {MDBQuotasApiUploadQuotasToProductsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadQuotasToProducts(
            requestParameters: MDBQuotasApiUploadQuotasToProductsRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .uploadQuotasToProducts(requestParameters.uploadQuotasToProductsRequest, options)
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for listQuotasByProducts operation in MDBQuotasApi.
 * @export
 * @interface MDBQuotasApiListQuotasByProductsRequest
 */
export interface MDBQuotasApiListQuotasByProductsRequest {
    /**
     *
     * @type {Array<string>}
     * @memberof MDBQuotasApiListQuotasByProducts
     */
    readonly productIds?: Array<string>;
}

/**
 * Request parameters for simulateMongoDbQuotasUsage operation in MDBQuotasApi.
 * @export
 * @interface MDBQuotasApiSimulateMongoDbQuotasUsageRequest
 */
export interface MDBQuotasApiSimulateMongoDbQuotasUsageRequest {
    /**
     *
     * @type {SimulateMongoDBQuotasUsageRequest}
     * @memberof MDBQuotasApiSimulateMongoDbQuotasUsage
     */
    readonly simulateMongoDBQuotasUsageRequest: SimulateMongoDBQuotasUsageRequest;
}

/**
 * Request parameters for simulateTransferQuotasBetweenProducts operation in MDBQuotasApi.
 * @export
 * @interface MDBQuotasApiSimulateTransferQuotasBetweenProductsRequest
 */
export interface MDBQuotasApiSimulateTransferQuotasBetweenProductsRequest {
    /**
     *
     * @type {TransferQuotasBetweenProductsRequest}
     * @memberof MDBQuotasApiSimulateTransferQuotasBetweenProducts
     */
    readonly transferQuotasBetweenProductsRequest: TransferQuotasBetweenProductsRequest;
}

/**
 * Request parameters for transferQuotasBetweenProducts operation in MDBQuotasApi.
 * @export
 * @interface MDBQuotasApiTransferQuotasBetweenProductsRequest
 */
export interface MDBQuotasApiTransferQuotasBetweenProductsRequest {
    /**
     *
     * @type {TransferQuotasBetweenProductsRequest}
     * @memberof MDBQuotasApiTransferQuotasBetweenProducts
     */
    readonly transferQuotasBetweenProductsRequest: TransferQuotasBetweenProductsRequest;
}

/**
 * Request parameters for uploadQuotasToProducts operation in MDBQuotasApi.
 * @export
 * @interface MDBQuotasApiUploadQuotasToProductsRequest
 */
export interface MDBQuotasApiUploadQuotasToProductsRequest {
    /**
     *
     * @type {UploadQuotasToProductsRequest}
     * @memberof MDBQuotasApiUploadQuotasToProducts
     */
    readonly uploadQuotasToProductsRequest: UploadQuotasToProductsRequest;
}

/**
 * MDBQuotasApi - object-oriented interface
 * @export
 * @class MDBQuotasApi
 * @extends {BaseAPI}
 */
export class MDBQuotasApi extends BaseAPI {
    /**
     *
     * @summary List MDB quotas by products
     * @param {MDBQuotasApiListQuotasByProductsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MDBQuotasApi
     */
    public listQuotasByProducts(
        requestParameters: MDBQuotasApiListQuotasByProductsRequest = {},
        options?: RawAxiosRequestConfig,
    ) {
        return MDBQuotasApiFp(this.configuration)
            .listQuotasByProducts(requestParameters.productIds, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary List MDB resources
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MDBQuotasApi
     */
    public listResources(options?: RawAxiosRequestConfig) {
        return MDBQuotasApiFp(this.configuration)
            .listResources(options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Simulate usage of quotas for MongoDB cluster
     * @param {MDBQuotasApiSimulateMongoDbQuotasUsageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MDBQuotasApi
     */
    public simulateMongoDbQuotasUsage(
        requestParameters: MDBQuotasApiSimulateMongoDbQuotasUsageRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return MDBQuotasApiFp(this.configuration)
            .simulateMongoDbQuotasUsage(
                requestParameters.simulateMongoDBQuotasUsageRequest,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Simulate transfer of MDB quotas between products
     * @param {MDBQuotasApiSimulateTransferQuotasBetweenProductsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MDBQuotasApi
     */
    public simulateTransferQuotasBetweenProducts(
        requestParameters: MDBQuotasApiSimulateTransferQuotasBetweenProductsRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return MDBQuotasApiFp(this.configuration)
            .simulateTransferQuotasBetweenProducts(
                requestParameters.transferQuotasBetweenProductsRequest,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Exchange MDB quotas between products
     * @param {MDBQuotasApiTransferQuotasBetweenProductsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MDBQuotasApi
     */
    public transferQuotasBetweenProducts(
        requestParameters: MDBQuotasApiTransferQuotasBetweenProductsRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return MDBQuotasApiFp(this.configuration)
            .transferQuotasBetweenProducts(
                requestParameters.transferQuotasBetweenProductsRequest,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Upload MDB quotas to multiple products
     * @param {MDBQuotasApiUploadQuotasToProductsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MDBQuotasApi
     */
    public uploadQuotasToProducts(
        requestParameters: MDBQuotasApiUploadQuotasToProductsRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return MDBQuotasApiFp(this.configuration)
            .uploadQuotasToProducts(requestParameters.uploadQuotasToProductsRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
}

/**
 * ManagedMongoDBBackupsApi - axios parameter creator
 * @export
 */
export const ManagedMongoDBBackupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Create MongoDB backup
         * @param {string} clusterId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBackup: async (
            clusterId: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('createBackup', 'clusterId', clusterId);
            const localVarPath = `/api/mdb/mongodb/clusters/{clusterId}/backups`.replace(
                `{${'clusterId'}}`,
                encodeURIComponent(String(clusterId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete backup of MongoDB cluster
         * @param {string} clusterId
         * @param {string} backupName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBackup: async (
            clusterId: string,
            backupName: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('deleteBackup', 'clusterId', clusterId);
            // verify required parameter 'backupName' is not null or undefined
            assertParamExists('deleteBackup', 'backupName', backupName);
            const localVarPath = `/api/mdb/mongodb/clusters/{clusterId}/backups/{backupName}`
                .replace(`{${'clusterId'}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${'backupName'}}`, encodeURIComponent(String(backupName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List MongoDB backups
         * @param {string} clusterId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBackups: async (
            clusterId: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('listBackups', 'clusterId', clusterId);
            const localVarPath = `/api/mdb/mongodb/clusters/{clusterId}/backups`.replace(
                `{${'clusterId'}}`,
                encodeURIComponent(String(clusterId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * ManagedMongoDBBackupsApi - functional programming interface
 * @export
 */
export const ManagedMongoDBBackupsApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = ManagedMongoDBBackupsApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Create MongoDB backup
         * @param {string} clusterId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBackup(
            clusterId: string,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduledOperationDTO>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBackup(
                clusterId,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['ManagedMongoDBBackupsApi.createBackup']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Delete backup of MongoDB cluster
         * @param {string} clusterId
         * @param {string} backupName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBackup(
            clusterId: string,
            backupName: string,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduledOperationDTO>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBackup(
                clusterId,
                backupName,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['ManagedMongoDBBackupsApi.deleteBackup']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary List MongoDB backups
         * @param {string} clusterId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBackups(
            clusterId: string,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListMongoBackupsResponseDTO>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBackups(
                clusterId,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['ManagedMongoDBBackupsApi.listBackups']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
    };
};

/**
 * ManagedMongoDBBackupsApi - factory interface
 * @export
 */
export const ManagedMongoDBBackupsApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = ManagedMongoDBBackupsApiFp(configuration);
    return {
        /**
         *
         * @summary Create MongoDB backup
         * @param {ManagedMongoDBBackupsApiCreateBackupRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBackup(
            requestParameters: ManagedMongoDBBackupsApiCreateBackupRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<ScheduledOperationDTO> {
            return localVarFp
                .createBackup(requestParameters.clusterId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete backup of MongoDB cluster
         * @param {ManagedMongoDBBackupsApiDeleteBackupRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBackup(
            requestParameters: ManagedMongoDBBackupsApiDeleteBackupRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<ScheduledOperationDTO> {
            return localVarFp
                .deleteBackup(requestParameters.clusterId, requestParameters.backupName, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List MongoDB backups
         * @param {ManagedMongoDBBackupsApiListBackupsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBackups(
            requestParameters: ManagedMongoDBBackupsApiListBackupsRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<ListMongoBackupsResponseDTO> {
            return localVarFp
                .listBackups(requestParameters.clusterId, options)
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createBackup operation in ManagedMongoDBBackupsApi.
 * @export
 * @interface ManagedMongoDBBackupsApiCreateBackupRequest
 */
export interface ManagedMongoDBBackupsApiCreateBackupRequest {
    /**
     *
     * @type {string}
     * @memberof ManagedMongoDBBackupsApiCreateBackup
     */
    readonly clusterId: string;
}

/**
 * Request parameters for deleteBackup operation in ManagedMongoDBBackupsApi.
 * @export
 * @interface ManagedMongoDBBackupsApiDeleteBackupRequest
 */
export interface ManagedMongoDBBackupsApiDeleteBackupRequest {
    /**
     *
     * @type {string}
     * @memberof ManagedMongoDBBackupsApiDeleteBackup
     */
    readonly clusterId: string;

    /**
     *
     * @type {string}
     * @memberof ManagedMongoDBBackupsApiDeleteBackup
     */
    readonly backupName: string;
}

/**
 * Request parameters for listBackups operation in ManagedMongoDBBackupsApi.
 * @export
 * @interface ManagedMongoDBBackupsApiListBackupsRequest
 */
export interface ManagedMongoDBBackupsApiListBackupsRequest {
    /**
     *
     * @type {string}
     * @memberof ManagedMongoDBBackupsApiListBackups
     */
    readonly clusterId: string;
}

/**
 * ManagedMongoDBBackupsApi - object-oriented interface
 * @export
 * @class ManagedMongoDBBackupsApi
 * @extends {BaseAPI}
 */
export class ManagedMongoDBBackupsApi extends BaseAPI {
    /**
     *
     * @summary Create MongoDB backup
     * @param {ManagedMongoDBBackupsApiCreateBackupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagedMongoDBBackupsApi
     */
    public createBackup(
        requestParameters: ManagedMongoDBBackupsApiCreateBackupRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return ManagedMongoDBBackupsApiFp(this.configuration)
            .createBackup(requestParameters.clusterId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Delete backup of MongoDB cluster
     * @param {ManagedMongoDBBackupsApiDeleteBackupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagedMongoDBBackupsApi
     */
    public deleteBackup(
        requestParameters: ManagedMongoDBBackupsApiDeleteBackupRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return ManagedMongoDBBackupsApiFp(this.configuration)
            .deleteBackup(requestParameters.clusterId, requestParameters.backupName, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary List MongoDB backups
     * @param {ManagedMongoDBBackupsApiListBackupsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagedMongoDBBackupsApi
     */
    public listBackups(
        requestParameters: ManagedMongoDBBackupsApiListBackupsRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return ManagedMongoDBBackupsApiFp(this.configuration)
            .listBackups(requestParameters.clusterId, options)
            .then((request) => request(this.axios, this.basePath));
    }
}

/**
 * ManagedMongoDBClustersApi - axios parameter creator
 * @export
 */
export const ManagedMongoDBClustersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Create MongoDB cluster
         * @param {CreateMongoClusterRequestDTO} createMongoClusterRequestDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCluster: async (
            createMongoClusterRequestDTO: CreateMongoClusterRequestDTO,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'createMongoClusterRequestDTO' is not null or undefined
            assertParamExists(
                'createCluster',
                'createMongoClusterRequestDTO',
                createMongoClusterRequestDTO,
            );
            const localVarPath = `/api/mdb/mongodb/clusters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = serializeDataIfNeeded(
                createMongoClusterRequestDTO,
                localVarRequestOptions,
                configuration,
            );

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete MongoDB cluster
         * @param {string} clusterId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCluster: async (
            clusterId: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('deleteCluster', 'clusterId', clusterId);
            const localVarPath = `/api/mdb/mongodb/clusters/{clusterId}`.replace(
                `{${'clusterId'}}`,
                encodeURIComponent(String(clusterId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get MongoDB cluster
         * @param {string} clusterId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCluster: async (
            clusterId: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('getCluster', 'clusterId', clusterId);
            const localVarPath = `/api/mdb/mongodb/clusters/{clusterId}`.replace(
                `{${'clusterId'}}`,
                encodeURIComponent(String(clusterId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List MongoDB clusters
         * @param {Array<string>} [projectIds]
         * @param {boolean} [isDeleted]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listClusters: async (
            projectIds?: Array<string>,
            isDeleted?: boolean,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            const localVarPath = `/api/mdb/mongodb/clusters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            if (projectIds) {
                localVarQueryParameter['projectIds'] = projectIds;
            }

            if (isDeleted !== undefined) {
                localVarQueryParameter['isDeleted'] = isDeleted;
            }

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List MongoDB versions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVersions: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/mdb/mongodb/versions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Restore MongoDB cluster
         * @param {string} clusterId
         * @param {string} backupName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreCluster: async (
            clusterId: string,
            backupName: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('restoreCluster', 'clusterId', clusterId);
            // verify required parameter 'backupName' is not null or undefined
            assertParamExists('restoreCluster', 'backupName', backupName);
            const localVarPath = `/api/mdb/mongodb/clusters/{clusterId}/restore/{backupName}`
                .replace(`{${'clusterId'}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${'backupName'}}`, encodeURIComponent(String(backupName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update MongoDB cluster
         * @param {string} clusterId
         * @param {UpdateMongoClusterRequestDTO} updateMongoClusterRequestDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCluster: async (
            clusterId: string,
            updateMongoClusterRequestDTO: UpdateMongoClusterRequestDTO,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('updateCluster', 'clusterId', clusterId);
            // verify required parameter 'updateMongoClusterRequestDTO' is not null or undefined
            assertParamExists(
                'updateCluster',
                'updateMongoClusterRequestDTO',
                updateMongoClusterRequestDTO,
            );
            const localVarPath = `/api/mdb/mongodb/clusters/{clusterId}`.replace(
                `{${'clusterId'}}`,
                encodeURIComponent(String(clusterId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = serializeDataIfNeeded(
                updateMongoClusterRequestDTO,
                localVarRequestOptions,
                configuration,
            );

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * ManagedMongoDBClustersApi - functional programming interface
 * @export
 */
export const ManagedMongoDBClustersApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = ManagedMongoDBClustersApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Create MongoDB cluster
         * @param {CreateMongoClusterRequestDTO} createMongoClusterRequestDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCluster(
            createMongoClusterRequestDTO: CreateMongoClusterRequestDTO,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (
                axios?: AxiosInstance,
                basePath?: string,
            ) => AxiosPromise<CreateMongoClusterResponseDTO>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCluster(
                createMongoClusterRequestDTO,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['ManagedMongoDBClustersApi.createCluster']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Delete MongoDB cluster
         * @param {string} clusterId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCluster(
            clusterId: string,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduledOperationDTO>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCluster(
                clusterId,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['ManagedMongoDBClustersApi.deleteCluster']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get MongoDB cluster
         * @param {string} clusterId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCluster(
            clusterId: string,
            options?: RawAxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MongoClusterDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCluster(
                clusterId,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['ManagedMongoDBClustersApi.getCluster']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary List MongoDB clusters
         * @param {Array<string>} [projectIds]
         * @param {boolean} [isDeleted]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listClusters(
            projectIds?: Array<string>,
            isDeleted?: boolean,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListMongoClustersResponseDTO>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listClusters(
                projectIds,
                isDeleted,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['ManagedMongoDBClustersApi.listClusters']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary List MongoDB versions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listVersions(
            options?: RawAxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListMongoVersionsResponseDTO>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listVersions(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['ManagedMongoDBClustersApi.listVersions']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Restore MongoDB cluster
         * @param {string} clusterId
         * @param {string} backupName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restoreCluster(
            clusterId: string,
            backupName: string,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduledOperationDTO>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restoreCluster(
                clusterId,
                backupName,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['ManagedMongoDBClustersApi.restoreCluster']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Update MongoDB cluster
         * @param {string} clusterId
         * @param {UpdateMongoClusterRequestDTO} updateMongoClusterRequestDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCluster(
            clusterId: string,
            updateMongoClusterRequestDTO: UpdateMongoClusterRequestDTO,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduledOperationDTO>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCluster(
                clusterId,
                updateMongoClusterRequestDTO,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['ManagedMongoDBClustersApi.updateCluster']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
    };
};

/**
 * ManagedMongoDBClustersApi - factory interface
 * @export
 */
export const ManagedMongoDBClustersApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = ManagedMongoDBClustersApiFp(configuration);
    return {
        /**
         *
         * @summary Create MongoDB cluster
         * @param {ManagedMongoDBClustersApiCreateClusterRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCluster(
            requestParameters: ManagedMongoDBClustersApiCreateClusterRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<CreateMongoClusterResponseDTO> {
            return localVarFp
                .createCluster(requestParameters.createMongoClusterRequestDTO, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete MongoDB cluster
         * @param {ManagedMongoDBClustersApiDeleteClusterRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCluster(
            requestParameters: ManagedMongoDBClustersApiDeleteClusterRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<ScheduledOperationDTO> {
            return localVarFp
                .deleteCluster(requestParameters.clusterId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get MongoDB cluster
         * @param {ManagedMongoDBClustersApiGetClusterRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCluster(
            requestParameters: ManagedMongoDBClustersApiGetClusterRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<MongoClusterDTO> {
            return localVarFp
                .getCluster(requestParameters.clusterId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List MongoDB clusters
         * @param {ManagedMongoDBClustersApiListClustersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listClusters(
            requestParameters: ManagedMongoDBClustersApiListClustersRequest = {},
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<ListMongoClustersResponseDTO> {
            return localVarFp
                .listClusters(requestParameters.projectIds, requestParameters.isDeleted, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List MongoDB versions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVersions(options?: RawAxiosRequestConfig): AxiosPromise<ListMongoVersionsResponseDTO> {
            return localVarFp.listVersions(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Restore MongoDB cluster
         * @param {ManagedMongoDBClustersApiRestoreClusterRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreCluster(
            requestParameters: ManagedMongoDBClustersApiRestoreClusterRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<ScheduledOperationDTO> {
            return localVarFp
                .restoreCluster(requestParameters.clusterId, requestParameters.backupName, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update MongoDB cluster
         * @param {ManagedMongoDBClustersApiUpdateClusterRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCluster(
            requestParameters: ManagedMongoDBClustersApiUpdateClusterRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<ScheduledOperationDTO> {
            return localVarFp
                .updateCluster(
                    requestParameters.clusterId,
                    requestParameters.updateMongoClusterRequestDTO,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createCluster operation in ManagedMongoDBClustersApi.
 * @export
 * @interface ManagedMongoDBClustersApiCreateClusterRequest
 */
export interface ManagedMongoDBClustersApiCreateClusterRequest {
    /**
     *
     * @type {CreateMongoClusterRequestDTO}
     * @memberof ManagedMongoDBClustersApiCreateCluster
     */
    readonly createMongoClusterRequestDTO: CreateMongoClusterRequestDTO;
}

/**
 * Request parameters for deleteCluster operation in ManagedMongoDBClustersApi.
 * @export
 * @interface ManagedMongoDBClustersApiDeleteClusterRequest
 */
export interface ManagedMongoDBClustersApiDeleteClusterRequest {
    /**
     *
     * @type {string}
     * @memberof ManagedMongoDBClustersApiDeleteCluster
     */
    readonly clusterId: string;
}

/**
 * Request parameters for getCluster operation in ManagedMongoDBClustersApi.
 * @export
 * @interface ManagedMongoDBClustersApiGetClusterRequest
 */
export interface ManagedMongoDBClustersApiGetClusterRequest {
    /**
     *
     * @type {string}
     * @memberof ManagedMongoDBClustersApiGetCluster
     */
    readonly clusterId: string;
}

/**
 * Request parameters for listClusters operation in ManagedMongoDBClustersApi.
 * @export
 * @interface ManagedMongoDBClustersApiListClustersRequest
 */
export interface ManagedMongoDBClustersApiListClustersRequest {
    /**
     *
     * @type {Array<string>}
     * @memberof ManagedMongoDBClustersApiListClusters
     */
    readonly projectIds?: Array<string>;

    /**
     *
     * @type {boolean}
     * @memberof ManagedMongoDBClustersApiListClusters
     */
    readonly isDeleted?: boolean;
}

/**
 * Request parameters for restoreCluster operation in ManagedMongoDBClustersApi.
 * @export
 * @interface ManagedMongoDBClustersApiRestoreClusterRequest
 */
export interface ManagedMongoDBClustersApiRestoreClusterRequest {
    /**
     *
     * @type {string}
     * @memberof ManagedMongoDBClustersApiRestoreCluster
     */
    readonly clusterId: string;

    /**
     *
     * @type {string}
     * @memberof ManagedMongoDBClustersApiRestoreCluster
     */
    readonly backupName: string;
}

/**
 * Request parameters for updateCluster operation in ManagedMongoDBClustersApi.
 * @export
 * @interface ManagedMongoDBClustersApiUpdateClusterRequest
 */
export interface ManagedMongoDBClustersApiUpdateClusterRequest {
    /**
     *
     * @type {string}
     * @memberof ManagedMongoDBClustersApiUpdateCluster
     */
    readonly clusterId: string;

    /**
     *
     * @type {UpdateMongoClusterRequestDTO}
     * @memberof ManagedMongoDBClustersApiUpdateCluster
     */
    readonly updateMongoClusterRequestDTO: UpdateMongoClusterRequestDTO;
}

/**
 * ManagedMongoDBClustersApi - object-oriented interface
 * @export
 * @class ManagedMongoDBClustersApi
 * @extends {BaseAPI}
 */
export class ManagedMongoDBClustersApi extends BaseAPI {
    /**
     *
     * @summary Create MongoDB cluster
     * @param {ManagedMongoDBClustersApiCreateClusterRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagedMongoDBClustersApi
     */
    public createCluster(
        requestParameters: ManagedMongoDBClustersApiCreateClusterRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return ManagedMongoDBClustersApiFp(this.configuration)
            .createCluster(requestParameters.createMongoClusterRequestDTO, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Delete MongoDB cluster
     * @param {ManagedMongoDBClustersApiDeleteClusterRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagedMongoDBClustersApi
     */
    public deleteCluster(
        requestParameters: ManagedMongoDBClustersApiDeleteClusterRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return ManagedMongoDBClustersApiFp(this.configuration)
            .deleteCluster(requestParameters.clusterId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get MongoDB cluster
     * @param {ManagedMongoDBClustersApiGetClusterRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagedMongoDBClustersApi
     */
    public getCluster(
        requestParameters: ManagedMongoDBClustersApiGetClusterRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return ManagedMongoDBClustersApiFp(this.configuration)
            .getCluster(requestParameters.clusterId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary List MongoDB clusters
     * @param {ManagedMongoDBClustersApiListClustersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagedMongoDBClustersApi
     */
    public listClusters(
        requestParameters: ManagedMongoDBClustersApiListClustersRequest = {},
        options?: RawAxiosRequestConfig,
    ) {
        return ManagedMongoDBClustersApiFp(this.configuration)
            .listClusters(requestParameters.projectIds, requestParameters.isDeleted, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary List MongoDB versions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagedMongoDBClustersApi
     */
    public listVersions(options?: RawAxiosRequestConfig) {
        return ManagedMongoDBClustersApiFp(this.configuration)
            .listVersions(options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Restore MongoDB cluster
     * @param {ManagedMongoDBClustersApiRestoreClusterRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagedMongoDBClustersApi
     */
    public restoreCluster(
        requestParameters: ManagedMongoDBClustersApiRestoreClusterRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return ManagedMongoDBClustersApiFp(this.configuration)
            .restoreCluster(requestParameters.clusterId, requestParameters.backupName, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Update MongoDB cluster
     * @param {ManagedMongoDBClustersApiUpdateClusterRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagedMongoDBClustersApi
     */
    public updateCluster(
        requestParameters: ManagedMongoDBClustersApiUpdateClusterRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return ManagedMongoDBClustersApiFp(this.configuration)
            .updateCluster(
                requestParameters.clusterId,
                requestParameters.updateMongoClusterRequestDTO,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }
}

/**
 * ManagedMongoDBDatabasesApi - axios parameter creator
 * @export
 */
export const ManagedMongoDBDatabasesApiAxiosParamCreator = function (
    configuration?: Configuration,
) {
    return {
        /**
         *
         * @summary Create MongoDB database
         * @param {string} clusterId
         * @param {CreateMongoDatabaseRequestDTO} createMongoDatabaseRequestDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDatabase: async (
            clusterId: string,
            createMongoDatabaseRequestDTO: CreateMongoDatabaseRequestDTO,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('createDatabase', 'clusterId', clusterId);
            // verify required parameter 'createMongoDatabaseRequestDTO' is not null or undefined
            assertParamExists(
                'createDatabase',
                'createMongoDatabaseRequestDTO',
                createMongoDatabaseRequestDTO,
            );
            const localVarPath = `/api/mdb/mongodb/clusters/{clusterId}/databases`.replace(
                `{${'clusterId'}}`,
                encodeURIComponent(String(clusterId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = serializeDataIfNeeded(
                createMongoDatabaseRequestDTO,
                localVarRequestOptions,
                configuration,
            );

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete MongoDB database
         * @param {string} clusterId
         * @param {string} databaseName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDatabase: async (
            clusterId: string,
            databaseName: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('deleteDatabase', 'clusterId', clusterId);
            // verify required parameter 'databaseName' is not null or undefined
            assertParamExists('deleteDatabase', 'databaseName', databaseName);
            const localVarPath = `/api/mdb/mongodb/clusters/{clusterId}/databases/{databaseName}`
                .replace(`{${'clusterId'}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${'databaseName'}}`, encodeURIComponent(String(databaseName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List MongoDB databases
         * @param {string} clusterId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabases: async (
            clusterId: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('listDatabases', 'clusterId', clusterId);
            const localVarPath = `/api/mdb/mongodb/clusters/{clusterId}/databases`.replace(
                `{${'clusterId'}}`,
                encodeURIComponent(String(clusterId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * ManagedMongoDBDatabasesApi - functional programming interface
 * @export
 */
export const ManagedMongoDBDatabasesApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = ManagedMongoDBDatabasesApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Create MongoDB database
         * @param {string} clusterId
         * @param {CreateMongoDatabaseRequestDTO} createMongoDatabaseRequestDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDatabase(
            clusterId: string,
            createMongoDatabaseRequestDTO: CreateMongoDatabaseRequestDTO,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduledOperationDTO>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDatabase(
                clusterId,
                createMongoDatabaseRequestDTO,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['ManagedMongoDBDatabasesApi.createDatabase']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Delete MongoDB database
         * @param {string} clusterId
         * @param {string} databaseName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDatabase(
            clusterId: string,
            databaseName: string,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduledOperationDTO>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDatabase(
                clusterId,
                databaseName,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['ManagedMongoDBDatabasesApi.deleteDatabase']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary List MongoDB databases
         * @param {string} clusterId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDatabases(
            clusterId: string,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (
                axios?: AxiosInstance,
                basePath?: string,
            ) => AxiosPromise<ListMongoDatabasesResponseDTO>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDatabases(
                clusterId,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['ManagedMongoDBDatabasesApi.listDatabases']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
    };
};

/**
 * ManagedMongoDBDatabasesApi - factory interface
 * @export
 */
export const ManagedMongoDBDatabasesApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = ManagedMongoDBDatabasesApiFp(configuration);
    return {
        /**
         *
         * @summary Create MongoDB database
         * @param {ManagedMongoDBDatabasesApiCreateDatabaseRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDatabase(
            requestParameters: ManagedMongoDBDatabasesApiCreateDatabaseRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<ScheduledOperationDTO> {
            return localVarFp
                .createDatabase(
                    requestParameters.clusterId,
                    requestParameters.createMongoDatabaseRequestDTO,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete MongoDB database
         * @param {ManagedMongoDBDatabasesApiDeleteDatabaseRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDatabase(
            requestParameters: ManagedMongoDBDatabasesApiDeleteDatabaseRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<ScheduledOperationDTO> {
            return localVarFp
                .deleteDatabase(
                    requestParameters.clusterId,
                    requestParameters.databaseName,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List MongoDB databases
         * @param {ManagedMongoDBDatabasesApiListDatabasesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabases(
            requestParameters: ManagedMongoDBDatabasesApiListDatabasesRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<ListMongoDatabasesResponseDTO> {
            return localVarFp
                .listDatabases(requestParameters.clusterId, options)
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createDatabase operation in ManagedMongoDBDatabasesApi.
 * @export
 * @interface ManagedMongoDBDatabasesApiCreateDatabaseRequest
 */
export interface ManagedMongoDBDatabasesApiCreateDatabaseRequest {
    /**
     *
     * @type {string}
     * @memberof ManagedMongoDBDatabasesApiCreateDatabase
     */
    readonly clusterId: string;

    /**
     *
     * @type {CreateMongoDatabaseRequestDTO}
     * @memberof ManagedMongoDBDatabasesApiCreateDatabase
     */
    readonly createMongoDatabaseRequestDTO: CreateMongoDatabaseRequestDTO;
}

/**
 * Request parameters for deleteDatabase operation in ManagedMongoDBDatabasesApi.
 * @export
 * @interface ManagedMongoDBDatabasesApiDeleteDatabaseRequest
 */
export interface ManagedMongoDBDatabasesApiDeleteDatabaseRequest {
    /**
     *
     * @type {string}
     * @memberof ManagedMongoDBDatabasesApiDeleteDatabase
     */
    readonly clusterId: string;

    /**
     *
     * @type {string}
     * @memberof ManagedMongoDBDatabasesApiDeleteDatabase
     */
    readonly databaseName: string;
}

/**
 * Request parameters for listDatabases operation in ManagedMongoDBDatabasesApi.
 * @export
 * @interface ManagedMongoDBDatabasesApiListDatabasesRequest
 */
export interface ManagedMongoDBDatabasesApiListDatabasesRequest {
    /**
     *
     * @type {string}
     * @memberof ManagedMongoDBDatabasesApiListDatabases
     */
    readonly clusterId: string;
}

/**
 * ManagedMongoDBDatabasesApi - object-oriented interface
 * @export
 * @class ManagedMongoDBDatabasesApi
 * @extends {BaseAPI}
 */
export class ManagedMongoDBDatabasesApi extends BaseAPI {
    /**
     *
     * @summary Create MongoDB database
     * @param {ManagedMongoDBDatabasesApiCreateDatabaseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagedMongoDBDatabasesApi
     */
    public createDatabase(
        requestParameters: ManagedMongoDBDatabasesApiCreateDatabaseRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return ManagedMongoDBDatabasesApiFp(this.configuration)
            .createDatabase(
                requestParameters.clusterId,
                requestParameters.createMongoDatabaseRequestDTO,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Delete MongoDB database
     * @param {ManagedMongoDBDatabasesApiDeleteDatabaseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagedMongoDBDatabasesApi
     */
    public deleteDatabase(
        requestParameters: ManagedMongoDBDatabasesApiDeleteDatabaseRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return ManagedMongoDBDatabasesApiFp(this.configuration)
            .deleteDatabase(requestParameters.clusterId, requestParameters.databaseName, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary List MongoDB databases
     * @param {ManagedMongoDBDatabasesApiListDatabasesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagedMongoDBDatabasesApi
     */
    public listDatabases(
        requestParameters: ManagedMongoDBDatabasesApiListDatabasesRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return ManagedMongoDBDatabasesApiFp(this.configuration)
            .listDatabases(requestParameters.clusterId, options)
            .then((request) => request(this.axios, this.basePath));
    }
}

/**
 * ManagedMongoDBInternalsApi - axios parameter creator
 * @export
 */
export const ManagedMongoDBInternalsApiAxiosParamCreator = function (
    configuration?: Configuration,
) {
    return {
        /**
         *
         * @summary Update MongoDB hosts
         * @param {UpdateMongoHostsRequest} updateMongoHostsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHosts: async (
            updateMongoHostsRequest: UpdateMongoHostsRequest,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'updateMongoHostsRequest' is not null or undefined
            assertParamExists('updateHosts', 'updateMongoHostsRequest', updateMongoHostsRequest);
            const localVarPath = `/api/managed-mongodb/v1/internal/hosts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = serializeDataIfNeeded(
                updateMongoHostsRequest,
                localVarRequestOptions,
                configuration,
            );

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * ManagedMongoDBInternalsApi - functional programming interface
 * @export
 */
export const ManagedMongoDBInternalsApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = ManagedMongoDBInternalsApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Update MongoDB hosts
         * @param {UpdateMongoHostsRequest} updateMongoHostsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateHosts(
            updateMongoHostsRequest: UpdateMongoHostsRequest,
            options?: RawAxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateHosts(
                updateMongoHostsRequest,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['ManagedMongoDBInternalsApi.updateHosts']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
    };
};

/**
 * ManagedMongoDBInternalsApi - factory interface
 * @export
 */
export const ManagedMongoDBInternalsApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = ManagedMongoDBInternalsApiFp(configuration);
    return {
        /**
         *
         * @summary Update MongoDB hosts
         * @param {ManagedMongoDBInternalsApiUpdateHostsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHosts(
            requestParameters: ManagedMongoDBInternalsApiUpdateHostsRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .updateHosts(requestParameters.updateMongoHostsRequest, options)
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for updateHosts operation in ManagedMongoDBInternalsApi.
 * @export
 * @interface ManagedMongoDBInternalsApiUpdateHostsRequest
 */
export interface ManagedMongoDBInternalsApiUpdateHostsRequest {
    /**
     *
     * @type {UpdateMongoHostsRequest}
     * @memberof ManagedMongoDBInternalsApiUpdateHosts
     */
    readonly updateMongoHostsRequest: UpdateMongoHostsRequest;
}

/**
 * ManagedMongoDBInternalsApi - object-oriented interface
 * @export
 * @class ManagedMongoDBInternalsApi
 * @extends {BaseAPI}
 */
export class ManagedMongoDBInternalsApi extends BaseAPI {
    /**
     *
     * @summary Update MongoDB hosts
     * @param {ManagedMongoDBInternalsApiUpdateHostsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagedMongoDBInternalsApi
     */
    public updateHosts(
        requestParameters: ManagedMongoDBInternalsApiUpdateHostsRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return ManagedMongoDBInternalsApiFp(this.configuration)
            .updateHosts(requestParameters.updateMongoHostsRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
}

/**
 * ManagedMongoDBUsersApi - axios parameter creator
 * @export
 */
export const ManagedMongoDBUsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Create MongoDB user
         * @param {string} clusterId
         * @param {CreateMongoUserRequestDTO} createMongoUserRequestDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: async (
            clusterId: string,
            createMongoUserRequestDTO: CreateMongoUserRequestDTO,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('createUser', 'clusterId', clusterId);
            // verify required parameter 'createMongoUserRequestDTO' is not null or undefined
            assertParamExists('createUser', 'createMongoUserRequestDTO', createMongoUserRequestDTO);
            const localVarPath = `/api/mdb/mongodb/clusters/{clusterId}/users`.replace(
                `{${'clusterId'}}`,
                encodeURIComponent(String(clusterId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = serializeDataIfNeeded(
                createMongoUserRequestDTO,
                localVarRequestOptions,
                configuration,
            );

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete MongoDB user
         * @param {string} clusterId
         * @param {string} userName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (
            clusterId: string,
            userName: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('deleteUser', 'clusterId', clusterId);
            // verify required parameter 'userName' is not null or undefined
            assertParamExists('deleteUser', 'userName', userName);
            const localVarPath = `/api/mdb/mongodb/clusters/{clusterId}/users/{userName}`
                .replace(`{${'clusterId'}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${'userName'}}`, encodeURIComponent(String(userName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List available MongoDB roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoles: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/mdb/mongodb/users/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List MongoDB users
         * @param {string} clusterId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers: async (
            clusterId: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'clusterId' is not null or undefined
            assertParamExists('listUsers', 'clusterId', clusterId);
            const localVarPath = `/api/mdb/mongodb/clusters/{clusterId}/users`.replace(
                `{${'clusterId'}}`,
                encodeURIComponent(String(clusterId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * ManagedMongoDBUsersApi - functional programming interface
 * @export
 */
export const ManagedMongoDBUsersApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = ManagedMongoDBUsersApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Create MongoDB user
         * @param {string} clusterId
         * @param {CreateMongoUserRequestDTO} createMongoUserRequestDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUser(
            clusterId: string,
            createMongoUserRequestDTO: CreateMongoUserRequestDTO,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduledOperationDTO>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(
                clusterId,
                createMongoUserRequestDTO,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['ManagedMongoDBUsersApi.createUser']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Delete MongoDB user
         * @param {string} clusterId
         * @param {string} userName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(
            clusterId: string,
            userName: string,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduledOperationDTO>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(
                clusterId,
                userName,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['ManagedMongoDBUsersApi.deleteUser']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary List available MongoDB roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRoles(
            options?: RawAxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListMongoRolesResponseDTO>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRoles(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['ManagedMongoDBUsersApi.listRoles']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary List MongoDB users
         * @param {string} clusterId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUsers(
            clusterId: string,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListMongoUsersResponseDTO>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUsers(clusterId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['ManagedMongoDBUsersApi.listUsers']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
    };
};

/**
 * ManagedMongoDBUsersApi - factory interface
 * @export
 */
export const ManagedMongoDBUsersApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = ManagedMongoDBUsersApiFp(configuration);
    return {
        /**
         *
         * @summary Create MongoDB user
         * @param {ManagedMongoDBUsersApiCreateUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(
            requestParameters: ManagedMongoDBUsersApiCreateUserRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<ScheduledOperationDTO> {
            return localVarFp
                .createUser(
                    requestParameters.clusterId,
                    requestParameters.createMongoUserRequestDTO,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete MongoDB user
         * @param {ManagedMongoDBUsersApiDeleteUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(
            requestParameters: ManagedMongoDBUsersApiDeleteUserRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<ScheduledOperationDTO> {
            return localVarFp
                .deleteUser(requestParameters.clusterId, requestParameters.userName, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List available MongoDB roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoles(options?: RawAxiosRequestConfig): AxiosPromise<ListMongoRolesResponseDTO> {
            return localVarFp.listRoles(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List MongoDB users
         * @param {ManagedMongoDBUsersApiListUsersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers(
            requestParameters: ManagedMongoDBUsersApiListUsersRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<ListMongoUsersResponseDTO> {
            return localVarFp
                .listUsers(requestParameters.clusterId, options)
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createUser operation in ManagedMongoDBUsersApi.
 * @export
 * @interface ManagedMongoDBUsersApiCreateUserRequest
 */
export interface ManagedMongoDBUsersApiCreateUserRequest {
    /**
     *
     * @type {string}
     * @memberof ManagedMongoDBUsersApiCreateUser
     */
    readonly clusterId: string;

    /**
     *
     * @type {CreateMongoUserRequestDTO}
     * @memberof ManagedMongoDBUsersApiCreateUser
     */
    readonly createMongoUserRequestDTO: CreateMongoUserRequestDTO;
}

/**
 * Request parameters for deleteUser operation in ManagedMongoDBUsersApi.
 * @export
 * @interface ManagedMongoDBUsersApiDeleteUserRequest
 */
export interface ManagedMongoDBUsersApiDeleteUserRequest {
    /**
     *
     * @type {string}
     * @memberof ManagedMongoDBUsersApiDeleteUser
     */
    readonly clusterId: string;

    /**
     *
     * @type {string}
     * @memberof ManagedMongoDBUsersApiDeleteUser
     */
    readonly userName: string;
}

/**
 * Request parameters for listUsers operation in ManagedMongoDBUsersApi.
 * @export
 * @interface ManagedMongoDBUsersApiListUsersRequest
 */
export interface ManagedMongoDBUsersApiListUsersRequest {
    /**
     *
     * @type {string}
     * @memberof ManagedMongoDBUsersApiListUsers
     */
    readonly clusterId: string;
}

/**
 * ManagedMongoDBUsersApi - object-oriented interface
 * @export
 * @class ManagedMongoDBUsersApi
 * @extends {BaseAPI}
 */
export class ManagedMongoDBUsersApi extends BaseAPI {
    /**
     *
     * @summary Create MongoDB user
     * @param {ManagedMongoDBUsersApiCreateUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagedMongoDBUsersApi
     */
    public createUser(
        requestParameters: ManagedMongoDBUsersApiCreateUserRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return ManagedMongoDBUsersApiFp(this.configuration)
            .createUser(
                requestParameters.clusterId,
                requestParameters.createMongoUserRequestDTO,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Delete MongoDB user
     * @param {ManagedMongoDBUsersApiDeleteUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagedMongoDBUsersApi
     */
    public deleteUser(
        requestParameters: ManagedMongoDBUsersApiDeleteUserRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return ManagedMongoDBUsersApiFp(this.configuration)
            .deleteUser(requestParameters.clusterId, requestParameters.userName, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary List available MongoDB roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagedMongoDBUsersApi
     */
    public listRoles(options?: RawAxiosRequestConfig) {
        return ManagedMongoDBUsersApiFp(this.configuration)
            .listRoles(options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary List MongoDB users
     * @param {ManagedMongoDBUsersApiListUsersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagedMongoDBUsersApi
     */
    public listUsers(
        requestParameters: ManagedMongoDBUsersApiListUsersRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return ManagedMongoDBUsersApiFp(this.configuration)
            .listUsers(requestParameters.clusterId, options)
            .then((request) => request(this.axios, this.basePath));
    }
}

/**
 * OperationsApi - axios parameter creator
 * @export
 */
export const OperationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary List operations
         * @param {string} [clusterId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOperations: async (
            clusterId?: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            const localVarPath = `/api/mdb/operations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            if (clusterId !== undefined) {
                localVarQueryParameter['clusterId'] = clusterId;
            }

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Restart operation
         * @param {string} operationId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartOperation: async (
            operationId: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'operationId' is not null or undefined
            assertParamExists('restartOperation', 'operationId', operationId);
            const localVarPath = `/api/mdb/operations/{operationId}/restart`.replace(
                `{${'operationId'}}`,
                encodeURIComponent(String(operationId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * OperationsApi - functional programming interface
 * @export
 */
export const OperationsApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = OperationsApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary List operations
         * @param {string} [clusterId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOperations(
            clusterId?: string,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListOperationsResponseDTO>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOperations(
                clusterId,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['OperationsApi.listOperations']?.[localVarOperationServerIndex]
                    ?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Restart operation
         * @param {string} operationId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restartOperation(
            operationId: string,
            options?: RawAxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restartOperation(
                operationId,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['OperationsApi.restartOperation']?.[localVarOperationServerIndex]
                    ?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
    };
};

/**
 * OperationsApi - factory interface
 * @export
 */
export const OperationsApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = OperationsApiFp(configuration);
    return {
        /**
         *
         * @summary List operations
         * @param {OperationsApiListOperationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOperations(
            requestParameters: OperationsApiListOperationsRequest = {},
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<ListOperationsResponseDTO> {
            return localVarFp
                .listOperations(requestParameters.clusterId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Restart operation
         * @param {OperationsApiRestartOperationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartOperation(
            requestParameters: OperationsApiRestartOperationRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .restartOperation(requestParameters.operationId, options)
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for listOperations operation in OperationsApi.
 * @export
 * @interface OperationsApiListOperationsRequest
 */
export interface OperationsApiListOperationsRequest {
    /**
     *
     * @type {string}
     * @memberof OperationsApiListOperations
     */
    readonly clusterId?: string;
}

/**
 * Request parameters for restartOperation operation in OperationsApi.
 * @export
 * @interface OperationsApiRestartOperationRequest
 */
export interface OperationsApiRestartOperationRequest {
    /**
     *
     * @type {string}
     * @memberof OperationsApiRestartOperation
     */
    readonly operationId: string;
}

/**
 * OperationsApi - object-oriented interface
 * @export
 * @class OperationsApi
 * @extends {BaseAPI}
 */
export class OperationsApi extends BaseAPI {
    /**
     *
     * @summary List operations
     * @param {OperationsApiListOperationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationsApi
     */
    public listOperations(
        requestParameters: OperationsApiListOperationsRequest = {},
        options?: RawAxiosRequestConfig,
    ) {
        return OperationsApiFp(this.configuration)
            .listOperations(requestParameters.clusterId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Restart operation
     * @param {OperationsApiRestartOperationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationsApi
     */
    public restartOperation(
        requestParameters: OperationsApiRestartOperationRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return OperationsApiFp(this.configuration)
            .restartOperation(requestParameters.operationId, options)
            .then((request) => request(this.axios, this.basePath));
    }
}

/**
 * OrganizationUnitsApi - axios parameter creator
 * @export
 */
export const OrganizationUnitsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Add account to org. unit link
         * @param {string} ouId
         * @param {string} accountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAccountToOrganizationUnit: async (
            ouId: string,
            accountId: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'ouId' is not null or undefined
            assertParamExists('addAccountToOrganizationUnit', 'ouId', ouId);
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('addAccountToOrganizationUnit', 'accountId', accountId);
            const localVarPath = `/api/v1/organization-units/{ouId}/accounts/{accountId}`
                .replace(`{${'ouId'}}`, encodeURIComponent(String(ouId)))
                .replace(`{${'accountId'}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create a new organization unit
         * @param {OrganizationUnitPostDTO} organizationUnitPostDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationUnit: async (
            organizationUnitPostDTO: OrganizationUnitPostDTO,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'organizationUnitPostDTO' is not null or undefined
            assertParamExists(
                'createOrganizationUnit',
                'organizationUnitPostDTO',
                organizationUnitPostDTO,
            );
            const localVarPath = `/api/v1/organization-units`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = serializeDataIfNeeded(
                organizationUnitPostDTO,
                localVarRequestOptions,
                configuration,
            );

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete an organization unit by ID
         * @param {string} ouId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationUnit: async (
            ouId: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'ouId' is not null or undefined
            assertParamExists('deleteOrganizationUnit', 'ouId', ouId);
            const localVarPath = `/api/v1/organization-units/{ouId}`.replace(
                `{${'ouId'}}`,
                encodeURIComponent(String(ouId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all organization unit accounts
         * @param {string} ouId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsByouId: async (
            ouId: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'ouId' is not null or undefined
            assertParamExists('getAccountsByouId', 'ouId', ouId);
            const localVarPath = `/api/v1/organization-units/{ouId}/accounts`.replace(
                `{${'ouId'}}`,
                encodeURIComponent(String(ouId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all organization units
         * @param {string} [search]
         * @param {string} [parentOuId]
         * @param {string} [dcId]
         * @param {number} [limit]
         * @param {number} [offset]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllOrganizationUnits: async (
            search?: string,
            parentOuId?: string,
            dcId?: string,
            limit?: number,
            offset?: number,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/organization-units`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (parentOuId !== undefined) {
                localVarQueryParameter['parentOuId'] = parentOuId;
            }

            if (dcId !== undefined) {
                localVarQueryParameter['dcId'] = dcId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get an organization unit by ID
         * @param {string} ouId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationUnitById: async (
            ouId: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'ouId' is not null or undefined
            assertParamExists('getOrganizationUnitById', 'ouId', ouId);
            const localVarPath = `/api/v1/organization-units/{ouId}`.replace(
                `{${'ouId'}}`,
                encodeURIComponent(String(ouId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Получение дочерних элементов organization-unit
         * @param {string} ouId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationUnitChildren: async (
            ouId: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'ouId' is not null or undefined
            assertParamExists('getOrganizationUnitChildren', 'ouId', ouId);
            const localVarPath = `/api/v1/organization-units/{ouId}/children`.replace(
                `{${'ouId'}}`,
                encodeURIComponent(String(ouId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Получение родительских элементов organization-unit
         * @param {string} ouId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationUnitParents: async (
            ouId: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'ouId' is not null or undefined
            assertParamExists('getOrganizationUnitParents', 'ouId', ouId);
            const localVarPath = `/api/v1/organization-units/{ouId}/parents`.replace(
                `{${'ouId'}}`,
                encodeURIComponent(String(ouId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Получение дерева organization-unit
         * @param {string} ouId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationUnitTree: async (
            ouId: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'ouId' is not null or undefined
            assertParamExists('getOrganizationUnitTree', 'ouId', ouId);
            const localVarPath = `/api/v1/organization-units/{ouId}/tree`.replace(
                `{${'ouId'}}`,
                encodeURIComponent(String(ouId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete account to org. unit link
         * @param {string} ouId
         * @param {string} accountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAccountFromOrganizationUnit: async (
            ouId: string,
            accountId: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'ouId' is not null or undefined
            assertParamExists('removeAccountFromOrganizationUnit', 'ouId', ouId);
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('removeAccountFromOrganizationUnit', 'accountId', accountId);
            const localVarPath = `/api/v1/organization-units/{ouId}/accounts/{accountId}`
                .replace(`{${'ouId'}}`, encodeURIComponent(String(ouId)))
                .replace(`{${'accountId'}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update an organization unit by ID
         * @param {string} ouId
         * @param {OrganizationUnitPostDTO} organizationUnitPostDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationUnit: async (
            ouId: string,
            organizationUnitPostDTO: OrganizationUnitPostDTO,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'ouId' is not null or undefined
            assertParamExists('updateOrganizationUnit', 'ouId', ouId);
            // verify required parameter 'organizationUnitPostDTO' is not null or undefined
            assertParamExists(
                'updateOrganizationUnit',
                'organizationUnitPostDTO',
                organizationUnitPostDTO,
            );
            const localVarPath = `/api/v1/organization-units/{ouId}`.replace(
                `{${'ouId'}}`,
                encodeURIComponent(String(ouId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = serializeDataIfNeeded(
                organizationUnitPostDTO,
                localVarRequestOptions,
                configuration,
            );

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * OrganizationUnitsApi - functional programming interface
 * @export
 */
export const OrganizationUnitsApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganizationUnitsApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Add account to org. unit link
         * @param {string} ouId
         * @param {string} accountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addAccountToOrganizationUnit(
            ouId: string,
            accountId: string,
            options?: RawAxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addAccountToOrganizationUnit(
                ouId,
                accountId,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['OrganizationUnitsApi.addAccountToOrganizationUnit']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Create a new organization unit
         * @param {OrganizationUnitPostDTO} organizationUnitPostDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrganizationUnit(
            organizationUnitPostDTO: OrganizationUnitPostDTO,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationUnitDTO>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrganizationUnit(
                organizationUnitPostDTO,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['OrganizationUnitsApi.createOrganizationUnit']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Delete an organization unit by ID
         * @param {string} ouId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrganizationUnit(
            ouId: string,
            options?: RawAxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrganizationUnit(
                ouId,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['OrganizationUnitsApi.deleteOrganizationUnit']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get all organization unit accounts
         * @param {string} ouId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountsByouId(
            ouId: string,
            options?: RawAxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AccountDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountsByouId(
                ouId,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['OrganizationUnitsApi.getAccountsByouId']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get all organization units
         * @param {string} [search]
         * @param {string} [parentOuId]
         * @param {string} [dcId]
         * @param {number} [limit]
         * @param {number} [offset]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllOrganizationUnits(
            search?: string,
            parentOuId?: string,
            dcId?: string,
            limit?: number,
            offset?: number,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (
                axios?: AxiosInstance,
                basePath?: string,
            ) => AxiosPromise<PaginatedOrganizationUnitResponse>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllOrganizationUnits(
                search,
                parentOuId,
                dcId,
                limit,
                offset,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['OrganizationUnitsApi.getAllOrganizationUnits']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get an organization unit by ID
         * @param {string} ouId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationUnitById(
            ouId: string,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationUnitDTO>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationUnitById(
                ouId,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['OrganizationUnitsApi.getOrganizationUnitById']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Получение дочерних элементов organization-unit
         * @param {string} ouId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationUnitChildren(
            ouId: string,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationUnitDTO>>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationUnitChildren(
                ouId,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['OrganizationUnitsApi.getOrganizationUnitChildren']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Получение родительских элементов organization-unit
         * @param {string} ouId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationUnitParents(
            ouId: string,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationUnitDTO>>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationUnitParents(
                ouId,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['OrganizationUnitsApi.getOrganizationUnitParents']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Получение дерева organization-unit
         * @param {string} ouId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationUnitTree(
            ouId: string,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationTreeDTO>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationUnitTree(
                ouId,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['OrganizationUnitsApi.getOrganizationUnitTree']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Delete account to org. unit link
         * @param {string} ouId
         * @param {string} accountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeAccountFromOrganizationUnit(
            ouId: string,
            accountId: string,
            options?: RawAxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs =
                await localVarAxiosParamCreator.removeAccountFromOrganizationUnit(
                    ouId,
                    accountId,
                    options,
                );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['OrganizationUnitsApi.removeAccountFromOrganizationUnit']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Update an organization unit by ID
         * @param {string} ouId
         * @param {OrganizationUnitPostDTO} organizationUnitPostDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOrganizationUnit(
            ouId: string,
            organizationUnitPostDTO: OrganizationUnitPostDTO,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationUnitDTO>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOrganizationUnit(
                ouId,
                organizationUnitPostDTO,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['OrganizationUnitsApi.updateOrganizationUnit']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
    };
};

/**
 * OrganizationUnitsApi - factory interface
 * @export
 */
export const OrganizationUnitsApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = OrganizationUnitsApiFp(configuration);
    return {
        /**
         *
         * @summary Add account to org. unit link
         * @param {OrganizationUnitsApiAddAccountToOrganizationUnitRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAccountToOrganizationUnit(
            requestParameters: OrganizationUnitsApiAddAccountToOrganizationUnitRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .addAccountToOrganizationUnit(
                    requestParameters.ouId,
                    requestParameters.accountId,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Create a new organization unit
         * @param {OrganizationUnitsApiCreateOrganizationUnitRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationUnit(
            requestParameters: OrganizationUnitsApiCreateOrganizationUnitRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<OrganizationUnitDTO> {
            return localVarFp
                .createOrganizationUnit(requestParameters.organizationUnitPostDTO, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete an organization unit by ID
         * @param {OrganizationUnitsApiDeleteOrganizationUnitRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationUnit(
            requestParameters: OrganizationUnitsApiDeleteOrganizationUnitRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .deleteOrganizationUnit(requestParameters.ouId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get all organization unit accounts
         * @param {OrganizationUnitsApiGetAccountsByouIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsByouId(
            requestParameters: OrganizationUnitsApiGetAccountsByouIdRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<Array<AccountDTO>> {
            return localVarFp
                .getAccountsByouId(requestParameters.ouId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get all organization units
         * @param {OrganizationUnitsApiGetAllOrganizationUnitsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllOrganizationUnits(
            requestParameters: OrganizationUnitsApiGetAllOrganizationUnitsRequest = {},
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<PaginatedOrganizationUnitResponse> {
            return localVarFp
                .getAllOrganizationUnits(
                    requestParameters.search,
                    requestParameters.parentOuId,
                    requestParameters.dcId,
                    requestParameters.limit,
                    requestParameters.offset,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get an organization unit by ID
         * @param {OrganizationUnitsApiGetOrganizationUnitByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationUnitById(
            requestParameters: OrganizationUnitsApiGetOrganizationUnitByIdRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<OrganizationUnitDTO> {
            return localVarFp
                .getOrganizationUnitById(requestParameters.ouId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Получение дочерних элементов organization-unit
         * @param {OrganizationUnitsApiGetOrganizationUnitChildrenRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationUnitChildren(
            requestParameters: OrganizationUnitsApiGetOrganizationUnitChildrenRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<Array<OrganizationUnitDTO>> {
            return localVarFp
                .getOrganizationUnitChildren(requestParameters.ouId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Получение родительских элементов organization-unit
         * @param {OrganizationUnitsApiGetOrganizationUnitParentsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationUnitParents(
            requestParameters: OrganizationUnitsApiGetOrganizationUnitParentsRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<Array<OrganizationUnitDTO>> {
            return localVarFp
                .getOrganizationUnitParents(requestParameters.ouId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Получение дерева organization-unit
         * @param {OrganizationUnitsApiGetOrganizationUnitTreeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationUnitTree(
            requestParameters: OrganizationUnitsApiGetOrganizationUnitTreeRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<OrganizationTreeDTO> {
            return localVarFp
                .getOrganizationUnitTree(requestParameters.ouId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete account to org. unit link
         * @param {OrganizationUnitsApiRemoveAccountFromOrganizationUnitRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAccountFromOrganizationUnit(
            requestParameters: OrganizationUnitsApiRemoveAccountFromOrganizationUnitRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .removeAccountFromOrganizationUnit(
                    requestParameters.ouId,
                    requestParameters.accountId,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update an organization unit by ID
         * @param {OrganizationUnitsApiUpdateOrganizationUnitRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationUnit(
            requestParameters: OrganizationUnitsApiUpdateOrganizationUnitRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<OrganizationUnitDTO> {
            return localVarFp
                .updateOrganizationUnit(
                    requestParameters.ouId,
                    requestParameters.organizationUnitPostDTO,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addAccountToOrganizationUnit operation in OrganizationUnitsApi.
 * @export
 * @interface OrganizationUnitsApiAddAccountToOrganizationUnitRequest
 */
export interface OrganizationUnitsApiAddAccountToOrganizationUnitRequest {
    /**
     *
     * @type {string}
     * @memberof OrganizationUnitsApiAddAccountToOrganizationUnit
     */
    readonly ouId: string;

    /**
     *
     * @type {string}
     * @memberof OrganizationUnitsApiAddAccountToOrganizationUnit
     */
    readonly accountId: string;
}

/**
 * Request parameters for createOrganizationUnit operation in OrganizationUnitsApi.
 * @export
 * @interface OrganizationUnitsApiCreateOrganizationUnitRequest
 */
export interface OrganizationUnitsApiCreateOrganizationUnitRequest {
    /**
     *
     * @type {OrganizationUnitPostDTO}
     * @memberof OrganizationUnitsApiCreateOrganizationUnit
     */
    readonly organizationUnitPostDTO: OrganizationUnitPostDTO;
}

/**
 * Request parameters for deleteOrganizationUnit operation in OrganizationUnitsApi.
 * @export
 * @interface OrganizationUnitsApiDeleteOrganizationUnitRequest
 */
export interface OrganizationUnitsApiDeleteOrganizationUnitRequest {
    /**
     *
     * @type {string}
     * @memberof OrganizationUnitsApiDeleteOrganizationUnit
     */
    readonly ouId: string;
}

/**
 * Request parameters for getAccountsByouId operation in OrganizationUnitsApi.
 * @export
 * @interface OrganizationUnitsApiGetAccountsByouIdRequest
 */
export interface OrganizationUnitsApiGetAccountsByouIdRequest {
    /**
     *
     * @type {string}
     * @memberof OrganizationUnitsApiGetAccountsByouId
     */
    readonly ouId: string;
}

/**
 * Request parameters for getAllOrganizationUnits operation in OrganizationUnitsApi.
 * @export
 * @interface OrganizationUnitsApiGetAllOrganizationUnitsRequest
 */
export interface OrganizationUnitsApiGetAllOrganizationUnitsRequest {
    /**
     *
     * @type {string}
     * @memberof OrganizationUnitsApiGetAllOrganizationUnits
     */
    readonly search?: string;

    /**
     *
     * @type {string}
     * @memberof OrganizationUnitsApiGetAllOrganizationUnits
     */
    readonly parentOuId?: string;

    /**
     *
     * @type {string}
     * @memberof OrganizationUnitsApiGetAllOrganizationUnits
     */
    readonly dcId?: string;

    /**
     *
     * @type {number}
     * @memberof OrganizationUnitsApiGetAllOrganizationUnits
     */
    readonly limit?: number;

    /**
     *
     * @type {number}
     * @memberof OrganizationUnitsApiGetAllOrganizationUnits
     */
    readonly offset?: number;
}

/**
 * Request parameters for getOrganizationUnitById operation in OrganizationUnitsApi.
 * @export
 * @interface OrganizationUnitsApiGetOrganizationUnitByIdRequest
 */
export interface OrganizationUnitsApiGetOrganizationUnitByIdRequest {
    /**
     *
     * @type {string}
     * @memberof OrganizationUnitsApiGetOrganizationUnitById
     */
    readonly ouId: string;
}

/**
 * Request parameters for getOrganizationUnitChildren operation in OrganizationUnitsApi.
 * @export
 * @interface OrganizationUnitsApiGetOrganizationUnitChildrenRequest
 */
export interface OrganizationUnitsApiGetOrganizationUnitChildrenRequest {
    /**
     *
     * @type {string}
     * @memberof OrganizationUnitsApiGetOrganizationUnitChildren
     */
    readonly ouId: string;
}

/**
 * Request parameters for getOrganizationUnitParents operation in OrganizationUnitsApi.
 * @export
 * @interface OrganizationUnitsApiGetOrganizationUnitParentsRequest
 */
export interface OrganizationUnitsApiGetOrganizationUnitParentsRequest {
    /**
     *
     * @type {string}
     * @memberof OrganizationUnitsApiGetOrganizationUnitParents
     */
    readonly ouId: string;
}

/**
 * Request parameters for getOrganizationUnitTree operation in OrganizationUnitsApi.
 * @export
 * @interface OrganizationUnitsApiGetOrganizationUnitTreeRequest
 */
export interface OrganizationUnitsApiGetOrganizationUnitTreeRequest {
    /**
     *
     * @type {string}
     * @memberof OrganizationUnitsApiGetOrganizationUnitTree
     */
    readonly ouId: string;
}

/**
 * Request parameters for removeAccountFromOrganizationUnit operation in OrganizationUnitsApi.
 * @export
 * @interface OrganizationUnitsApiRemoveAccountFromOrganizationUnitRequest
 */
export interface OrganizationUnitsApiRemoveAccountFromOrganizationUnitRequest {
    /**
     *
     * @type {string}
     * @memberof OrganizationUnitsApiRemoveAccountFromOrganizationUnit
     */
    readonly ouId: string;

    /**
     *
     * @type {string}
     * @memberof OrganizationUnitsApiRemoveAccountFromOrganizationUnit
     */
    readonly accountId: string;
}

/**
 * Request parameters for updateOrganizationUnit operation in OrganizationUnitsApi.
 * @export
 * @interface OrganizationUnitsApiUpdateOrganizationUnitRequest
 */
export interface OrganizationUnitsApiUpdateOrganizationUnitRequest {
    /**
     *
     * @type {string}
     * @memberof OrganizationUnitsApiUpdateOrganizationUnit
     */
    readonly ouId: string;

    /**
     *
     * @type {OrganizationUnitPostDTO}
     * @memberof OrganizationUnitsApiUpdateOrganizationUnit
     */
    readonly organizationUnitPostDTO: OrganizationUnitPostDTO;
}

/**
 * OrganizationUnitsApi - object-oriented interface
 * @export
 * @class OrganizationUnitsApi
 * @extends {BaseAPI}
 */
export class OrganizationUnitsApi extends BaseAPI {
    /**
     *
     * @summary Add account to org. unit link
     * @param {OrganizationUnitsApiAddAccountToOrganizationUnitRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationUnitsApi
     */
    public addAccountToOrganizationUnit(
        requestParameters: OrganizationUnitsApiAddAccountToOrganizationUnitRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return OrganizationUnitsApiFp(this.configuration)
            .addAccountToOrganizationUnit(
                requestParameters.ouId,
                requestParameters.accountId,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Create a new organization unit
     * @param {OrganizationUnitsApiCreateOrganizationUnitRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationUnitsApi
     */
    public createOrganizationUnit(
        requestParameters: OrganizationUnitsApiCreateOrganizationUnitRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return OrganizationUnitsApiFp(this.configuration)
            .createOrganizationUnit(requestParameters.organizationUnitPostDTO, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Delete an organization unit by ID
     * @param {OrganizationUnitsApiDeleteOrganizationUnitRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationUnitsApi
     */
    public deleteOrganizationUnit(
        requestParameters: OrganizationUnitsApiDeleteOrganizationUnitRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return OrganizationUnitsApiFp(this.configuration)
            .deleteOrganizationUnit(requestParameters.ouId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get all organization unit accounts
     * @param {OrganizationUnitsApiGetAccountsByouIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationUnitsApi
     */
    public getAccountsByouId(
        requestParameters: OrganizationUnitsApiGetAccountsByouIdRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return OrganizationUnitsApiFp(this.configuration)
            .getAccountsByouId(requestParameters.ouId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get all organization units
     * @param {OrganizationUnitsApiGetAllOrganizationUnitsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationUnitsApi
     */
    public getAllOrganizationUnits(
        requestParameters: OrganizationUnitsApiGetAllOrganizationUnitsRequest = {},
        options?: RawAxiosRequestConfig,
    ) {
        return OrganizationUnitsApiFp(this.configuration)
            .getAllOrganizationUnits(
                requestParameters.search,
                requestParameters.parentOuId,
                requestParameters.dcId,
                requestParameters.limit,
                requestParameters.offset,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get an organization unit by ID
     * @param {OrganizationUnitsApiGetOrganizationUnitByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationUnitsApi
     */
    public getOrganizationUnitById(
        requestParameters: OrganizationUnitsApiGetOrganizationUnitByIdRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return OrganizationUnitsApiFp(this.configuration)
            .getOrganizationUnitById(requestParameters.ouId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Получение дочерних элементов organization-unit
     * @param {OrganizationUnitsApiGetOrganizationUnitChildrenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationUnitsApi
     */
    public getOrganizationUnitChildren(
        requestParameters: OrganizationUnitsApiGetOrganizationUnitChildrenRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return OrganizationUnitsApiFp(this.configuration)
            .getOrganizationUnitChildren(requestParameters.ouId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Получение родительских элементов organization-unit
     * @param {OrganizationUnitsApiGetOrganizationUnitParentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationUnitsApi
     */
    public getOrganizationUnitParents(
        requestParameters: OrganizationUnitsApiGetOrganizationUnitParentsRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return OrganizationUnitsApiFp(this.configuration)
            .getOrganizationUnitParents(requestParameters.ouId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Получение дерева organization-unit
     * @param {OrganizationUnitsApiGetOrganizationUnitTreeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationUnitsApi
     */
    public getOrganizationUnitTree(
        requestParameters: OrganizationUnitsApiGetOrganizationUnitTreeRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return OrganizationUnitsApiFp(this.configuration)
            .getOrganizationUnitTree(requestParameters.ouId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Delete account to org. unit link
     * @param {OrganizationUnitsApiRemoveAccountFromOrganizationUnitRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationUnitsApi
     */
    public removeAccountFromOrganizationUnit(
        requestParameters: OrganizationUnitsApiRemoveAccountFromOrganizationUnitRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return OrganizationUnitsApiFp(this.configuration)
            .removeAccountFromOrganizationUnit(
                requestParameters.ouId,
                requestParameters.accountId,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Update an organization unit by ID
     * @param {OrganizationUnitsApiUpdateOrganizationUnitRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationUnitsApi
     */
    public updateOrganizationUnit(
        requestParameters: OrganizationUnitsApiUpdateOrganizationUnitRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return OrganizationUnitsApiFp(this.configuration)
            .updateOrganizationUnit(
                requestParameters.ouId,
                requestParameters.organizationUnitPostDTO,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }
}

/**
 * PermissionsApi - axios parameter creator
 * @export
 */
export const PermissionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Checking if the current user has access
         * @param {string} actionType
         * @param {string} [resourceId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkPermission: async (
            actionType: string,
            resourceId?: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'actionType' is not null or undefined
            assertParamExists('checkPermission', 'actionType', actionType);
            const localVarPath = `/api/v1/permissions/check`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            if (actionType !== undefined) {
                localVarQueryParameter['actionType'] = actionType;
            }

            if (resourceId !== undefined) {
                localVarQueryParameter['resourceId'] = resourceId;
            }

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a permission by ID
         * @param {string} permissionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPermissionById: async (
            permissionId: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'permissionId' is not null or undefined
            assertParamExists('getPermissionById', 'permissionId', permissionId);
            const localVarPath = `/api/v1/permissions/{permissionId}`.replace(
                `{${'permissionId'}}`,
                encodeURIComponent(String(permissionId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * PermissionsApi - functional programming interface
 * @export
 */
export const PermissionsApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = PermissionsApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Checking if the current user has access
         * @param {string} actionType
         * @param {string} [resourceId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkPermission(
            actionType: string,
            resourceId?: string,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckPermission200Response>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkPermission(
                actionType,
                resourceId,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['PermissionsApi.checkPermission']?.[localVarOperationServerIndex]
                    ?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get a permission by ID
         * @param {string} permissionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPermissionById(
            permissionId: string,
            options?: RawAxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PermissionDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPermissionById(
                permissionId,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['PermissionsApi.getPermissionById']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
    };
};

/**
 * PermissionsApi - factory interface
 * @export
 */
export const PermissionsApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = PermissionsApiFp(configuration);
    return {
        /**
         *
         * @summary Checking if the current user has access
         * @param {PermissionsApiCheckPermissionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkPermission(
            requestParameters: PermissionsApiCheckPermissionRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<CheckPermission200Response> {
            return localVarFp
                .checkPermission(
                    requestParameters.actionType,
                    requestParameters.resourceId,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a permission by ID
         * @param {PermissionsApiGetPermissionByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPermissionById(
            requestParameters: PermissionsApiGetPermissionByIdRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<PermissionDTO> {
            return localVarFp
                .getPermissionById(requestParameters.permissionId, options)
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for checkPermission operation in PermissionsApi.
 * @export
 * @interface PermissionsApiCheckPermissionRequest
 */
export interface PermissionsApiCheckPermissionRequest {
    /**
     *
     * @type {string}
     * @memberof PermissionsApiCheckPermission
     */
    readonly actionType: string;

    /**
     *
     * @type {string}
     * @memberof PermissionsApiCheckPermission
     */
    readonly resourceId?: string;
}

/**
 * Request parameters for getPermissionById operation in PermissionsApi.
 * @export
 * @interface PermissionsApiGetPermissionByIdRequest
 */
export interface PermissionsApiGetPermissionByIdRequest {
    /**
     *
     * @type {string}
     * @memberof PermissionsApiGetPermissionById
     */
    readonly permissionId: string;
}

/**
 * PermissionsApi - object-oriented interface
 * @export
 * @class PermissionsApi
 * @extends {BaseAPI}
 */
export class PermissionsApi extends BaseAPI {
    /**
     *
     * @summary Checking if the current user has access
     * @param {PermissionsApiCheckPermissionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionsApi
     */
    public checkPermission(
        requestParameters: PermissionsApiCheckPermissionRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return PermissionsApiFp(this.configuration)
            .checkPermission(requestParameters.actionType, requestParameters.resourceId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get a permission by ID
     * @param {PermissionsApiGetPermissionByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionsApi
     */
    public getPermissionById(
        requestParameters: PermissionsApiGetPermissionByIdRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return PermissionsApiFp(this.configuration)
            .getPermissionById(requestParameters.permissionId, options)
            .then((request) => request(this.axios, this.basePath));
    }
}

/**
 * ProductsApi - axios parameter creator
 * @export
 */
export const ProductsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Create a new product
         * @param {ProductPostDTO} productPostDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProduct: async (
            productPostDTO: ProductPostDTO,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'productPostDTO' is not null or undefined
            assertParamExists('createProduct', 'productPostDTO', productPostDTO);
            const localVarPath = `/api/v1/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = serializeDataIfNeeded(
                productPostDTO,
                localVarRequestOptions,
                configuration,
            );

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a product by ID
         * @param {string} productId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProduct: async (
            productId: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('deleteProduct', 'productId', productId);
            const localVarPath = `/api/v1/products/{productId}`.replace(
                `{${'productId'}}`,
                encodeURIComponent(String(productId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Getting child elements of all products by a tree
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllProductTree: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/products-tree`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all products
         * @param {string} [search]
         * @param {number} [limit]
         * @param {number} [offset]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllProducts: async (
            search?: string,
            limit?: number,
            offset?: number,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a product by ID
         * @param {string} productId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductById: async (
            productId: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('getProductById', 'productId', productId);
            const localVarPath = `/api/v1/products/{productId}`.replace(
                `{${'productId'}}`,
                encodeURIComponent(String(productId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Getting child elements of a product
         * @param {string} productId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductChildren: async (
            productId: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('getProductChildren', 'productId', productId);
            const localVarPath = `/api/v1/products/{productId}/children`.replace(
                `{${'productId'}}`,
                encodeURIComponent(String(productId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Getting the parent elements of a product
         * @param {string} productId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductParents: async (
            productId: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('getProductParents', 'productId', productId);
            const localVarPath = `/api/v1/products/{productId}/parents`.replace(
                `{${'productId'}}`,
                encodeURIComponent(String(productId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Getting child elements of a product by a tree
         * @param {string} productId
         * @param {number} [depth]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductTree: async (
            productId: string,
            depth?: number,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('getProductTree', 'productId', productId);
            const localVarPath = `/api/v1/products/{productId}/tree`.replace(
                `{${'productId'}}`,
                encodeURIComponent(String(productId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Obtaining the root elements of products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductsRoots: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/products-roots`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update a product by ID
         * @param {string} productId
         * @param {ProductPostDTO} productPostDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProduct: async (
            productId: string,
            productPostDTO: ProductPostDTO,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('updateProduct', 'productId', productId);
            // verify required parameter 'productPostDTO' is not null or undefined
            assertParamExists('updateProduct', 'productPostDTO', productPostDTO);
            const localVarPath = `/api/v1/products/{productId}`.replace(
                `{${'productId'}}`,
                encodeURIComponent(String(productId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = serializeDataIfNeeded(
                productPostDTO,
                localVarRequestOptions,
                configuration,
            );

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * ProductsApi - functional programming interface
 * @export
 */
export const ProductsApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductsApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Create a new product
         * @param {ProductPostDTO} productPostDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProduct(
            productPostDTO: ProductPostDTO,
            options?: RawAxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProduct(
                productPostDTO,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['ProductsApi.createProduct']?.[localVarOperationServerIndex]
                    ?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Delete a product by ID
         * @param {string} productId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProduct(
            productId: string,
            options?: RawAxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProduct(
                productId,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['ProductsApi.deleteProduct']?.[localVarOperationServerIndex]
                    ?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Getting child elements of all products by a tree
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllProductTree(
            options?: RawAxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProductTreeDTO>>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllProductTree(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['ProductsApi.getAllProductTree']?.[localVarOperationServerIndex]
                    ?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get all products
         * @param {string} [search]
         * @param {number} [limit]
         * @param {number} [offset]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllProducts(
            search?: string,
            limit?: number,
            offset?: number,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedProductResponse>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllProducts(
                search,
                limit,
                offset,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['ProductsApi.getAllProducts']?.[localVarOperationServerIndex]
                    ?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get a product by ID
         * @param {string} productId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductById(
            productId: string,
            options?: RawAxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProductById(
                productId,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['ProductsApi.getProductById']?.[localVarOperationServerIndex]
                    ?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Getting child elements of a product
         * @param {string} productId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductChildren(
            productId: string,
            options?: RawAxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProductDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProductChildren(
                productId,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['ProductsApi.getProductChildren']?.[localVarOperationServerIndex]
                    ?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Getting the parent elements of a product
         * @param {string} productId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductParents(
            productId: string,
            options?: RawAxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProductDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProductParents(
                productId,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['ProductsApi.getProductParents']?.[localVarOperationServerIndex]
                    ?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Getting child elements of a product by a tree
         * @param {string} productId
         * @param {number} [depth]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductTree(
            productId: string,
            depth?: number,
            options?: RawAxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductTreeDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProductTree(
                productId,
                depth,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['ProductsApi.getProductTree']?.[localVarOperationServerIndex]
                    ?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Obtaining the root elements of products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductsRoots(
            options?: RawAxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProductDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProductsRoots(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['ProductsApi.getProductsRoots']?.[localVarOperationServerIndex]
                    ?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Update a product by ID
         * @param {string} productId
         * @param {ProductPostDTO} productPostDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProduct(
            productId: string,
            productPostDTO: ProductPostDTO,
            options?: RawAxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProduct(
                productId,
                productPostDTO,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['ProductsApi.updateProduct']?.[localVarOperationServerIndex]
                    ?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
    };
};

/**
 * ProductsApi - factory interface
 * @export
 */
export const ProductsApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = ProductsApiFp(configuration);
    return {
        /**
         *
         * @summary Create a new product
         * @param {ProductsApiCreateProductRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProduct(
            requestParameters: ProductsApiCreateProductRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<ProductDTO> {
            return localVarFp
                .createProduct(requestParameters.productPostDTO, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a product by ID
         * @param {ProductsApiDeleteProductRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProduct(
            requestParameters: ProductsApiDeleteProductRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .deleteProduct(requestParameters.productId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Getting child elements of all products by a tree
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllProductTree(options?: RawAxiosRequestConfig): AxiosPromise<Array<ProductTreeDTO>> {
            return localVarFp
                .getAllProductTree(options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get all products
         * @param {ProductsApiGetAllProductsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllProducts(
            requestParameters: ProductsApiGetAllProductsRequest = {},
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<PaginatedProductResponse> {
            return localVarFp
                .getAllProducts(
                    requestParameters.search,
                    requestParameters.limit,
                    requestParameters.offset,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a product by ID
         * @param {ProductsApiGetProductByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductById(
            requestParameters: ProductsApiGetProductByIdRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<ProductDTO> {
            return localVarFp
                .getProductById(requestParameters.productId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Getting child elements of a product
         * @param {ProductsApiGetProductChildrenRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductChildren(
            requestParameters: ProductsApiGetProductChildrenRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<Array<ProductDTO>> {
            return localVarFp
                .getProductChildren(requestParameters.productId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Getting the parent elements of a product
         * @param {ProductsApiGetProductParentsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductParents(
            requestParameters: ProductsApiGetProductParentsRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<Array<ProductDTO>> {
            return localVarFp
                .getProductParents(requestParameters.productId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Getting child elements of a product by a tree
         * @param {ProductsApiGetProductTreeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductTree(
            requestParameters: ProductsApiGetProductTreeRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<ProductTreeDTO> {
            return localVarFp
                .getProductTree(requestParameters.productId, requestParameters.depth, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Obtaining the root elements of products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductsRoots(options?: RawAxiosRequestConfig): AxiosPromise<Array<ProductDTO>> {
            return localVarFp.getProductsRoots(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update a product by ID
         * @param {ProductsApiUpdateProductRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProduct(
            requestParameters: ProductsApiUpdateProductRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<ProductDTO> {
            return localVarFp
                .updateProduct(
                    requestParameters.productId,
                    requestParameters.productPostDTO,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createProduct operation in ProductsApi.
 * @export
 * @interface ProductsApiCreateProductRequest
 */
export interface ProductsApiCreateProductRequest {
    /**
     *
     * @type {ProductPostDTO}
     * @memberof ProductsApiCreateProduct
     */
    readonly productPostDTO: ProductPostDTO;
}

/**
 * Request parameters for deleteProduct operation in ProductsApi.
 * @export
 * @interface ProductsApiDeleteProductRequest
 */
export interface ProductsApiDeleteProductRequest {
    /**
     *
     * @type {string}
     * @memberof ProductsApiDeleteProduct
     */
    readonly productId: string;
}

/**
 * Request parameters for getAllProducts operation in ProductsApi.
 * @export
 * @interface ProductsApiGetAllProductsRequest
 */
export interface ProductsApiGetAllProductsRequest {
    /**
     *
     * @type {string}
     * @memberof ProductsApiGetAllProducts
     */
    readonly search?: string;

    /**
     *
     * @type {number}
     * @memberof ProductsApiGetAllProducts
     */
    readonly limit?: number;

    /**
     *
     * @type {number}
     * @memberof ProductsApiGetAllProducts
     */
    readonly offset?: number;
}

/**
 * Request parameters for getProductById operation in ProductsApi.
 * @export
 * @interface ProductsApiGetProductByIdRequest
 */
export interface ProductsApiGetProductByIdRequest {
    /**
     *
     * @type {string}
     * @memberof ProductsApiGetProductById
     */
    readonly productId: string;
}

/**
 * Request parameters for getProductChildren operation in ProductsApi.
 * @export
 * @interface ProductsApiGetProductChildrenRequest
 */
export interface ProductsApiGetProductChildrenRequest {
    /**
     *
     * @type {string}
     * @memberof ProductsApiGetProductChildren
     */
    readonly productId: string;
}

/**
 * Request parameters for getProductParents operation in ProductsApi.
 * @export
 * @interface ProductsApiGetProductParentsRequest
 */
export interface ProductsApiGetProductParentsRequest {
    /**
     *
     * @type {string}
     * @memberof ProductsApiGetProductParents
     */
    readonly productId: string;
}

/**
 * Request parameters for getProductTree operation in ProductsApi.
 * @export
 * @interface ProductsApiGetProductTreeRequest
 */
export interface ProductsApiGetProductTreeRequest {
    /**
     *
     * @type {string}
     * @memberof ProductsApiGetProductTree
     */
    readonly productId: string;

    /**
     *
     * @type {number}
     * @memberof ProductsApiGetProductTree
     */
    readonly depth?: number;
}

/**
 * Request parameters for updateProduct operation in ProductsApi.
 * @export
 * @interface ProductsApiUpdateProductRequest
 */
export interface ProductsApiUpdateProductRequest {
    /**
     *
     * @type {string}
     * @memberof ProductsApiUpdateProduct
     */
    readonly productId: string;

    /**
     *
     * @type {ProductPostDTO}
     * @memberof ProductsApiUpdateProduct
     */
    readonly productPostDTO: ProductPostDTO;
}

/**
 * ProductsApi - object-oriented interface
 * @export
 * @class ProductsApi
 * @extends {BaseAPI}
 */
export class ProductsApi extends BaseAPI {
    /**
     *
     * @summary Create a new product
     * @param {ProductsApiCreateProductRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public createProduct(
        requestParameters: ProductsApiCreateProductRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return ProductsApiFp(this.configuration)
            .createProduct(requestParameters.productPostDTO, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Delete a product by ID
     * @param {ProductsApiDeleteProductRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public deleteProduct(
        requestParameters: ProductsApiDeleteProductRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return ProductsApiFp(this.configuration)
            .deleteProduct(requestParameters.productId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Getting child elements of all products by a tree
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public getAllProductTree(options?: RawAxiosRequestConfig) {
        return ProductsApiFp(this.configuration)
            .getAllProductTree(options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get all products
     * @param {ProductsApiGetAllProductsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public getAllProducts(
        requestParameters: ProductsApiGetAllProductsRequest = {},
        options?: RawAxiosRequestConfig,
    ) {
        return ProductsApiFp(this.configuration)
            .getAllProducts(
                requestParameters.search,
                requestParameters.limit,
                requestParameters.offset,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get a product by ID
     * @param {ProductsApiGetProductByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public getProductById(
        requestParameters: ProductsApiGetProductByIdRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return ProductsApiFp(this.configuration)
            .getProductById(requestParameters.productId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Getting child elements of a product
     * @param {ProductsApiGetProductChildrenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public getProductChildren(
        requestParameters: ProductsApiGetProductChildrenRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return ProductsApiFp(this.configuration)
            .getProductChildren(requestParameters.productId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Getting the parent elements of a product
     * @param {ProductsApiGetProductParentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public getProductParents(
        requestParameters: ProductsApiGetProductParentsRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return ProductsApiFp(this.configuration)
            .getProductParents(requestParameters.productId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Getting child elements of a product by a tree
     * @param {ProductsApiGetProductTreeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public getProductTree(
        requestParameters: ProductsApiGetProductTreeRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return ProductsApiFp(this.configuration)
            .getProductTree(requestParameters.productId, requestParameters.depth, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Obtaining the root elements of products
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public getProductsRoots(options?: RawAxiosRequestConfig) {
        return ProductsApiFp(this.configuration)
            .getProductsRoots(options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Update a product by ID
     * @param {ProductsApiUpdateProductRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public updateProduct(
        requestParameters: ProductsApiUpdateProductRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return ProductsApiFp(this.configuration)
            .updateProduct(requestParameters.productId, requestParameters.productPostDTO, options)
            .then((request) => request(this.axios, this.basePath));
    }
}

/**
 * ProjectsApi - axios parameter creator
 * @export
 */
export const ProjectsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Create project
         * @param {CreateProjectRequestDTO} createProjectRequestDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProject: async (
            createProjectRequestDTO: CreateProjectRequestDTO,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'createProjectRequestDTO' is not null or undefined
            assertParamExists('createProject', 'createProjectRequestDTO', createProjectRequestDTO);
            const localVarPath = `/api/mdb/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = serializeDataIfNeeded(
                createProjectRequestDTO,
                localVarRequestOptions,
                configuration,
            );

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete project
         * @param {string} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProject: async (
            projectId: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('deleteProject', 'projectId', projectId);
            const localVarPath = `/api/mdb/projects/{projectId}`.replace(
                `{${'projectId'}}`,
                encodeURIComponent(String(projectId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get project
         * @param {string} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject: async (
            projectId: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getProject', 'projectId', projectId);
            const localVarPath = `/api/mdb/projects/{projectId}`.replace(
                `{${'projectId'}}`,
                encodeURIComponent(String(projectId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List projects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjects: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/mdb/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update project
         * @param {string} projectId
         * @param {UpdateProjectRequestDTO} updateProjectRequestDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProject: async (
            projectId: string,
            updateProjectRequestDTO: UpdateProjectRequestDTO,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('updateProject', 'projectId', projectId);
            // verify required parameter 'updateProjectRequestDTO' is not null or undefined
            assertParamExists('updateProject', 'updateProjectRequestDTO', updateProjectRequestDTO);
            const localVarPath = `/api/mdb/projects/{projectId}`.replace(
                `{${'projectId'}}`,
                encodeURIComponent(String(projectId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = serializeDataIfNeeded(
                updateProjectRequestDTO,
                localVarRequestOptions,
                configuration,
            );

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * ProjectsApi - functional programming interface
 * @export
 */
export const ProjectsApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectsApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Create project
         * @param {CreateProjectRequestDTO} createProjectRequestDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProject(
            createProjectRequestDTO: CreateProjectRequestDTO,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateProjectResponseDTO>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProject(
                createProjectRequestDTO,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['ProjectsApi.createProject']?.[localVarOperationServerIndex]
                    ?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Delete project
         * @param {string} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProject(
            projectId: string,
            options?: RawAxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProject(
                projectId,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['ProjectsApi.deleteProject']?.[localVarOperationServerIndex]
                    ?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get project
         * @param {string} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProject(
            projectId: string,
            options?: RawAxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProject(
                projectId,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['ProjectsApi.getProject']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary List projects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProjects(
            options?: RawAxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListProjectsResponseDTO>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProjects(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['ProjectsApi.listProjects']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Update project
         * @param {string} projectId
         * @param {UpdateProjectRequestDTO} updateProjectRequestDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProject(
            projectId: string,
            updateProjectRequestDTO: UpdateProjectRequestDTO,
            options?: RawAxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProject(
                projectId,
                updateProjectRequestDTO,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['ProjectsApi.updateProject']?.[localVarOperationServerIndex]
                    ?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
    };
};

/**
 * ProjectsApi - factory interface
 * @export
 */
export const ProjectsApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = ProjectsApiFp(configuration);
    return {
        /**
         *
         * @summary Create project
         * @param {ProjectsApiCreateProjectRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProject(
            requestParameters: ProjectsApiCreateProjectRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<CreateProjectResponseDTO> {
            return localVarFp
                .createProject(requestParameters.createProjectRequestDTO, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete project
         * @param {ProjectsApiDeleteProjectRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProject(
            requestParameters: ProjectsApiDeleteProjectRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .deleteProject(requestParameters.projectId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get project
         * @param {ProjectsApiGetProjectRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject(
            requestParameters: ProjectsApiGetProjectRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<ProjectDTO> {
            return localVarFp
                .getProject(requestParameters.projectId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List projects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjects(options?: RawAxiosRequestConfig): AxiosPromise<ListProjectsResponseDTO> {
            return localVarFp.listProjects(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update project
         * @param {ProjectsApiUpdateProjectRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProject(
            requestParameters: ProjectsApiUpdateProjectRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .updateProject(
                    requestParameters.projectId,
                    requestParameters.updateProjectRequestDTO,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createProject operation in ProjectsApi.
 * @export
 * @interface ProjectsApiCreateProjectRequest
 */
export interface ProjectsApiCreateProjectRequest {
    /**
     *
     * @type {CreateProjectRequestDTO}
     * @memberof ProjectsApiCreateProject
     */
    readonly createProjectRequestDTO: CreateProjectRequestDTO;
}

/**
 * Request parameters for deleteProject operation in ProjectsApi.
 * @export
 * @interface ProjectsApiDeleteProjectRequest
 */
export interface ProjectsApiDeleteProjectRequest {
    /**
     *
     * @type {string}
     * @memberof ProjectsApiDeleteProject
     */
    readonly projectId: string;
}

/**
 * Request parameters for getProject operation in ProjectsApi.
 * @export
 * @interface ProjectsApiGetProjectRequest
 */
export interface ProjectsApiGetProjectRequest {
    /**
     *
     * @type {string}
     * @memberof ProjectsApiGetProject
     */
    readonly projectId: string;
}

/**
 * Request parameters for updateProject operation in ProjectsApi.
 * @export
 * @interface ProjectsApiUpdateProjectRequest
 */
export interface ProjectsApiUpdateProjectRequest {
    /**
     *
     * @type {string}
     * @memberof ProjectsApiUpdateProject
     */
    readonly projectId: string;

    /**
     *
     * @type {UpdateProjectRequestDTO}
     * @memberof ProjectsApiUpdateProject
     */
    readonly updateProjectRequestDTO: UpdateProjectRequestDTO;
}

/**
 * ProjectsApi - object-oriented interface
 * @export
 * @class ProjectsApi
 * @extends {BaseAPI}
 */
export class ProjectsApi extends BaseAPI {
    /**
     *
     * @summary Create project
     * @param {ProjectsApiCreateProjectRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public createProject(
        requestParameters: ProjectsApiCreateProjectRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return ProjectsApiFp(this.configuration)
            .createProject(requestParameters.createProjectRequestDTO, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Delete project
     * @param {ProjectsApiDeleteProjectRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public deleteProject(
        requestParameters: ProjectsApiDeleteProjectRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return ProjectsApiFp(this.configuration)
            .deleteProject(requestParameters.projectId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get project
     * @param {ProjectsApiGetProjectRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public getProject(
        requestParameters: ProjectsApiGetProjectRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return ProjectsApiFp(this.configuration)
            .getProject(requestParameters.projectId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary List projects
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public listProjects(options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration)
            .listProjects(options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Update project
     * @param {ProjectsApiUpdateProjectRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public updateProject(
        requestParameters: ProjectsApiUpdateProjectRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return ProjectsApiFp(this.configuration)
            .updateProject(
                requestParameters.projectId,
                requestParameters.updateProjectRequestDTO,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }
}

/**
 * ResourcePresetsApi - axios parameter creator
 * @export
 */
export const ResourcePresetsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Create resource preset
         * @param {V1CreateResourcePresetRequest} v1CreateResourcePresetRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createResourcePreset: async (
            v1CreateResourcePresetRequest: V1CreateResourcePresetRequest,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'v1CreateResourcePresetRequest' is not null or undefined
            assertParamExists(
                'createResourcePreset',
                'v1CreateResourcePresetRequest',
                v1CreateResourcePresetRequest,
            );
            const localVarPath = `/api/v1/resource-presets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = serializeDataIfNeeded(
                v1CreateResourcePresetRequest,
                localVarRequestOptions,
                configuration,
            );

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete resource preset
         * @param {string} resourcePresetId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResourcePreset: async (
            resourcePresetId: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'resourcePresetId' is not null or undefined
            assertParamExists('deleteResourcePreset', 'resourcePresetId', resourcePresetId);
            const localVarPath = `/api/v1/resource-presets/{resourcePresetId}`.replace(
                `{${'resourcePresetId'}}`,
                encodeURIComponent(String(resourcePresetId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get resource preset
         * @param {string} resourcePresetId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResourcePreset: async (
            resourcePresetId: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'resourcePresetId' is not null or undefined
            assertParamExists('getResourcePreset', 'resourcePresetId', resourcePresetId);
            const localVarPath = `/api/v1/resource-presets/{resourcePresetId}`.replace(
                `{${'resourcePresetId'}}`,
                encodeURIComponent(String(resourcePresetId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get resource presets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResourcePresets: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/resource-presets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update resource preset
         * @param {string} resourcePresetId
         * @param {V1UpdateResourcePresetRequest} v1UpdateResourcePresetRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResourcePreset: async (
            resourcePresetId: string,
            v1UpdateResourcePresetRequest: V1UpdateResourcePresetRequest,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'resourcePresetId' is not null or undefined
            assertParamExists('updateResourcePreset', 'resourcePresetId', resourcePresetId);
            // verify required parameter 'v1UpdateResourcePresetRequest' is not null or undefined
            assertParamExists(
                'updateResourcePreset',
                'v1UpdateResourcePresetRequest',
                v1UpdateResourcePresetRequest,
            );
            const localVarPath = `/api/v1/resource-presets/{resourcePresetId}`.replace(
                `{${'resourcePresetId'}}`,
                encodeURIComponent(String(resourcePresetId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = serializeDataIfNeeded(
                v1UpdateResourcePresetRequest,
                localVarRequestOptions,
                configuration,
            );

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * ResourcePresetsApi - functional programming interface
 * @export
 */
export const ResourcePresetsApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = ResourcePresetsApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Create resource preset
         * @param {V1CreateResourcePresetRequest} v1CreateResourcePresetRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createResourcePreset(
            v1CreateResourcePresetRequest: V1CreateResourcePresetRequest,
            options?: RawAxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createResourcePreset(
                v1CreateResourcePresetRequest,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['ResourcePresetsApi.createResourcePreset']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Delete resource preset
         * @param {string} resourcePresetId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteResourcePreset(
            resourcePresetId: string,
            options?: RawAxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteResourcePreset(
                resourcePresetId,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['ResourcePresetsApi.deleteResourcePreset']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get resource preset
         * @param {string} resourcePresetId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getResourcePreset(
            resourcePresetId: string,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1ResourcePresetResponse>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getResourcePreset(
                resourcePresetId,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['ResourcePresetsApi.getResourcePreset']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get resource presets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listResourcePresets(
            options?: RawAxiosRequestConfig,
        ): Promise<
            (
                axios?: AxiosInstance,
                basePath?: string,
            ) => AxiosPromise<V1ListResourcePresetsResponse>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listResourcePresets(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['ResourcePresetsApi.listResourcePresets']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Update resource preset
         * @param {string} resourcePresetId
         * @param {V1UpdateResourcePresetRequest} v1UpdateResourcePresetRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateResourcePreset(
            resourcePresetId: string,
            v1UpdateResourcePresetRequest: V1UpdateResourcePresetRequest,
            options?: RawAxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateResourcePreset(
                resourcePresetId,
                v1UpdateResourcePresetRequest,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['ResourcePresetsApi.updateResourcePreset']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
    };
};

/**
 * ResourcePresetsApi - factory interface
 * @export
 */
export const ResourcePresetsApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = ResourcePresetsApiFp(configuration);
    return {
        /**
         *
         * @summary Create resource preset
         * @param {ResourcePresetsApiCreateResourcePresetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createResourcePreset(
            requestParameters: ResourcePresetsApiCreateResourcePresetRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .createResourcePreset(requestParameters.v1CreateResourcePresetRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete resource preset
         * @param {ResourcePresetsApiDeleteResourcePresetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResourcePreset(
            requestParameters: ResourcePresetsApiDeleteResourcePresetRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .deleteResourcePreset(requestParameters.resourcePresetId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get resource preset
         * @param {ResourcePresetsApiGetResourcePresetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResourcePreset(
            requestParameters: ResourcePresetsApiGetResourcePresetRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<V1ResourcePresetResponse> {
            return localVarFp
                .getResourcePreset(requestParameters.resourcePresetId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get resource presets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResourcePresets(
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<V1ListResourcePresetsResponse> {
            return localVarFp
                .listResourcePresets(options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update resource preset
         * @param {ResourcePresetsApiUpdateResourcePresetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResourcePreset(
            requestParameters: ResourcePresetsApiUpdateResourcePresetRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .updateResourcePreset(
                    requestParameters.resourcePresetId,
                    requestParameters.v1UpdateResourcePresetRequest,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createResourcePreset operation in ResourcePresetsApi.
 * @export
 * @interface ResourcePresetsApiCreateResourcePresetRequest
 */
export interface ResourcePresetsApiCreateResourcePresetRequest {
    /**
     *
     * @type {V1CreateResourcePresetRequest}
     * @memberof ResourcePresetsApiCreateResourcePreset
     */
    readonly v1CreateResourcePresetRequest: V1CreateResourcePresetRequest;
}

/**
 * Request parameters for deleteResourcePreset operation in ResourcePresetsApi.
 * @export
 * @interface ResourcePresetsApiDeleteResourcePresetRequest
 */
export interface ResourcePresetsApiDeleteResourcePresetRequest {
    /**
     *
     * @type {string}
     * @memberof ResourcePresetsApiDeleteResourcePreset
     */
    readonly resourcePresetId: string;
}

/**
 * Request parameters for getResourcePreset operation in ResourcePresetsApi.
 * @export
 * @interface ResourcePresetsApiGetResourcePresetRequest
 */
export interface ResourcePresetsApiGetResourcePresetRequest {
    /**
     *
     * @type {string}
     * @memberof ResourcePresetsApiGetResourcePreset
     */
    readonly resourcePresetId: string;
}

/**
 * Request parameters for updateResourcePreset operation in ResourcePresetsApi.
 * @export
 * @interface ResourcePresetsApiUpdateResourcePresetRequest
 */
export interface ResourcePresetsApiUpdateResourcePresetRequest {
    /**
     *
     * @type {string}
     * @memberof ResourcePresetsApiUpdateResourcePreset
     */
    readonly resourcePresetId: string;

    /**
     *
     * @type {V1UpdateResourcePresetRequest}
     * @memberof ResourcePresetsApiUpdateResourcePreset
     */
    readonly v1UpdateResourcePresetRequest: V1UpdateResourcePresetRequest;
}

/**
 * ResourcePresetsApi - object-oriented interface
 * @export
 * @class ResourcePresetsApi
 * @extends {BaseAPI}
 */
export class ResourcePresetsApi extends BaseAPI {
    /**
     *
     * @summary Create resource preset
     * @param {ResourcePresetsApiCreateResourcePresetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourcePresetsApi
     */
    public createResourcePreset(
        requestParameters: ResourcePresetsApiCreateResourcePresetRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return ResourcePresetsApiFp(this.configuration)
            .createResourcePreset(requestParameters.v1CreateResourcePresetRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Delete resource preset
     * @param {ResourcePresetsApiDeleteResourcePresetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourcePresetsApi
     */
    public deleteResourcePreset(
        requestParameters: ResourcePresetsApiDeleteResourcePresetRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return ResourcePresetsApiFp(this.configuration)
            .deleteResourcePreset(requestParameters.resourcePresetId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get resource preset
     * @param {ResourcePresetsApiGetResourcePresetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourcePresetsApi
     */
    public getResourcePreset(
        requestParameters: ResourcePresetsApiGetResourcePresetRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return ResourcePresetsApiFp(this.configuration)
            .getResourcePreset(requestParameters.resourcePresetId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get resource presets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourcePresetsApi
     */
    public listResourcePresets(options?: RawAxiosRequestConfig) {
        return ResourcePresetsApiFp(this.configuration)
            .listResourcePresets(options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Update resource preset
     * @param {ResourcePresetsApiUpdateResourcePresetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourcePresetsApi
     */
    public updateResourcePreset(
        requestParameters: ResourcePresetsApiUpdateResourcePresetRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return ResourcePresetsApiFp(this.configuration)
            .updateResourcePreset(
                requestParameters.resourcePresetId,
                requestParameters.v1UpdateResourcePresetRequest,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }
}

/**
 * RolesApi - axios parameter creator
 * @export
 */
export const RolesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Create a new role
         * @param {RoleWithPermissionsPostDTO} roleWithPermissionsPostDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRole: async (
            roleWithPermissionsPostDTO: RoleWithPermissionsPostDTO,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'roleWithPermissionsPostDTO' is not null or undefined
            assertParamExists(
                'createRole',
                'roleWithPermissionsPostDTO',
                roleWithPermissionsPostDTO,
            );
            const localVarPath = `/api/v1/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = serializeDataIfNeeded(
                roleWithPermissionsPostDTO,
                localVarRequestOptions,
                configuration,
            );

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a role by ID
         * @param {string} roleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRole: async (
            roleId: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('deleteRole', 'roleId', roleId);
            const localVarPath = `/api/v1/roles/{roleId}`.replace(
                `{${'roleId'}}`,
                encodeURIComponent(String(roleId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all roles
         * @param {string} [search]
         * @param {string} [productId]
         * @param {string} [orgUnitId]
         * @param {number} [limit]
         * @param {number} [offset]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRoles: async (
            search?: string,
            productId?: string,
            orgUnitId?: string,
            limit?: number,
            offset?: number,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (productId !== undefined) {
                localVarQueryParameter['productId'] = productId;
            }

            if (orgUnitId !== undefined) {
                localVarQueryParameter['orgUnitId'] = orgUnitId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get role permission
         * @param {string} roleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPermissionsByRoleId: async (
            roleId: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('getPermissionsByRoleId', 'roleId', roleId);
            const localVarPath = `/api/v1/roles/{roleId}/permissions`.replace(
                `{${'roleId'}}`,
                encodeURIComponent(String(roleId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a role by ID
         * @param {string} roleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoleById: async (
            roleId: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('getRoleById', 'roleId', roleId);
            const localVarPath = `/api/v1/roles/{roleId}`.replace(
                `{${'roleId'}}`,
                encodeURIComponent(String(roleId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get role history
         * @param {string} roleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoleHistory: async (
            roleId: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('getRoleHistory', 'roleId', roleId);
            const localVarPath = `/api/v1/roles/{roleId}/history`.replace(
                `{${'roleId'}}`,
                encodeURIComponent(String(roleId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update a role by ID
         * @param {string} roleId
         * @param {RoleWithPermissionsPostDTO} roleWithPermissionsPostDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRole: async (
            roleId: string,
            roleWithPermissionsPostDTO: RoleWithPermissionsPostDTO,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('updateRole', 'roleId', roleId);
            // verify required parameter 'roleWithPermissionsPostDTO' is not null or undefined
            assertParamExists(
                'updateRole',
                'roleWithPermissionsPostDTO',
                roleWithPermissionsPostDTO,
            );
            const localVarPath = `/api/v1/roles/{roleId}`.replace(
                `{${'roleId'}}`,
                encodeURIComponent(String(roleId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = serializeDataIfNeeded(
                roleWithPermissionsPostDTO,
                localVarRequestOptions,
                configuration,
            );

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * RolesApi - functional programming interface
 * @export
 */
export const RolesApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = RolesApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Create a new role
         * @param {RoleWithPermissionsPostDTO} roleWithPermissionsPostDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRole(
            roleWithPermissionsPostDTO: RoleWithPermissionsPostDTO,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleWithPermissionsDTO>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRole(
                roleWithPermissionsPostDTO,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['RolesApi.createRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Delete a role by ID
         * @param {string} roleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRole(
            roleId: string,
            options?: RawAxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRole(roleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['RolesApi.deleteRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get all roles
         * @param {string} [search]
         * @param {string} [productId]
         * @param {string} [orgUnitId]
         * @param {number} [limit]
         * @param {number} [offset]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllRoles(
            search?: string,
            productId?: string,
            orgUnitId?: string,
            limit?: number,
            offset?: number,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedRoleResponse>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllRoles(
                search,
                productId,
                orgUnitId,
                limit,
                offset,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['RolesApi.getAllRoles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get role permission
         * @param {string} roleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPermissionsByRoleId(
            roleId: string,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleWithPermissionsDTO>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPermissionsByRoleId(
                roleId,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['RolesApi.getPermissionsByRoleId']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get a role by ID
         * @param {string} roleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoleById(
            roleId: string,
            options?: RawAxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoleById(roleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['RolesApi.getRoleById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get role history
         * @param {string} roleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoleHistory(
            roleId: string,
            options?: RawAxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleHistoryDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoleHistory(
                roleId,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['RolesApi.getRoleHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Update a role by ID
         * @param {string} roleId
         * @param {RoleWithPermissionsPostDTO} roleWithPermissionsPostDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRole(
            roleId: string,
            roleWithPermissionsPostDTO: RoleWithPermissionsPostDTO,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleWithPermissionsDTO>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRole(
                roleId,
                roleWithPermissionsPostDTO,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['RolesApi.updateRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
    };
};

/**
 * RolesApi - factory interface
 * @export
 */
export const RolesApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = RolesApiFp(configuration);
    return {
        /**
         *
         * @summary Create a new role
         * @param {RolesApiCreateRoleRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRole(
            requestParameters: RolesApiCreateRoleRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<RoleWithPermissionsDTO> {
            return localVarFp
                .createRole(requestParameters.roleWithPermissionsPostDTO, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a role by ID
         * @param {RolesApiDeleteRoleRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRole(
            requestParameters: RolesApiDeleteRoleRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .deleteRole(requestParameters.roleId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get all roles
         * @param {RolesApiGetAllRolesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRoles(
            requestParameters: RolesApiGetAllRolesRequest = {},
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<PaginatedRoleResponse> {
            return localVarFp
                .getAllRoles(
                    requestParameters.search,
                    requestParameters.productId,
                    requestParameters.orgUnitId,
                    requestParameters.limit,
                    requestParameters.offset,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get role permission
         * @param {RolesApiGetPermissionsByRoleIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPermissionsByRoleId(
            requestParameters: RolesApiGetPermissionsByRoleIdRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<RoleWithPermissionsDTO> {
            return localVarFp
                .getPermissionsByRoleId(requestParameters.roleId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a role by ID
         * @param {RolesApiGetRoleByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoleById(
            requestParameters: RolesApiGetRoleByIdRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<RoleDTO> {
            return localVarFp
                .getRoleById(requestParameters.roleId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get role history
         * @param {RolesApiGetRoleHistoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoleHistory(
            requestParameters: RolesApiGetRoleHistoryRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<RoleHistoryDTO> {
            return localVarFp
                .getRoleHistory(requestParameters.roleId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update a role by ID
         * @param {RolesApiUpdateRoleRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRole(
            requestParameters: RolesApiUpdateRoleRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<RoleWithPermissionsDTO> {
            return localVarFp
                .updateRole(
                    requestParameters.roleId,
                    requestParameters.roleWithPermissionsPostDTO,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createRole operation in RolesApi.
 * @export
 * @interface RolesApiCreateRoleRequest
 */
export interface RolesApiCreateRoleRequest {
    /**
     *
     * @type {RoleWithPermissionsPostDTO}
     * @memberof RolesApiCreateRole
     */
    readonly roleWithPermissionsPostDTO: RoleWithPermissionsPostDTO;
}

/**
 * Request parameters for deleteRole operation in RolesApi.
 * @export
 * @interface RolesApiDeleteRoleRequest
 */
export interface RolesApiDeleteRoleRequest {
    /**
     *
     * @type {string}
     * @memberof RolesApiDeleteRole
     */
    readonly roleId: string;
}

/**
 * Request parameters for getAllRoles operation in RolesApi.
 * @export
 * @interface RolesApiGetAllRolesRequest
 */
export interface RolesApiGetAllRolesRequest {
    /**
     *
     * @type {string}
     * @memberof RolesApiGetAllRoles
     */
    readonly search?: string;

    /**
     *
     * @type {string}
     * @memberof RolesApiGetAllRoles
     */
    readonly productId?: string;

    /**
     *
     * @type {string}
     * @memberof RolesApiGetAllRoles
     */
    readonly orgUnitId?: string;

    /**
     *
     * @type {number}
     * @memberof RolesApiGetAllRoles
     */
    readonly limit?: number;

    /**
     *
     * @type {number}
     * @memberof RolesApiGetAllRoles
     */
    readonly offset?: number;
}

/**
 * Request parameters for getPermissionsByRoleId operation in RolesApi.
 * @export
 * @interface RolesApiGetPermissionsByRoleIdRequest
 */
export interface RolesApiGetPermissionsByRoleIdRequest {
    /**
     *
     * @type {string}
     * @memberof RolesApiGetPermissionsByRoleId
     */
    readonly roleId: string;
}

/**
 * Request parameters for getRoleById operation in RolesApi.
 * @export
 * @interface RolesApiGetRoleByIdRequest
 */
export interface RolesApiGetRoleByIdRequest {
    /**
     *
     * @type {string}
     * @memberof RolesApiGetRoleById
     */
    readonly roleId: string;
}

/**
 * Request parameters for getRoleHistory operation in RolesApi.
 * @export
 * @interface RolesApiGetRoleHistoryRequest
 */
export interface RolesApiGetRoleHistoryRequest {
    /**
     *
     * @type {string}
     * @memberof RolesApiGetRoleHistory
     */
    readonly roleId: string;
}

/**
 * Request parameters for updateRole operation in RolesApi.
 * @export
 * @interface RolesApiUpdateRoleRequest
 */
export interface RolesApiUpdateRoleRequest {
    /**
     *
     * @type {string}
     * @memberof RolesApiUpdateRole
     */
    readonly roleId: string;

    /**
     *
     * @type {RoleWithPermissionsPostDTO}
     * @memberof RolesApiUpdateRole
     */
    readonly roleWithPermissionsPostDTO: RoleWithPermissionsPostDTO;
}

/**
 * RolesApi - object-oriented interface
 * @export
 * @class RolesApi
 * @extends {BaseAPI}
 */
export class RolesApi extends BaseAPI {
    /**
     *
     * @summary Create a new role
     * @param {RolesApiCreateRoleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public createRole(
        requestParameters: RolesApiCreateRoleRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return RolesApiFp(this.configuration)
            .createRole(requestParameters.roleWithPermissionsPostDTO, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Delete a role by ID
     * @param {RolesApiDeleteRoleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public deleteRole(
        requestParameters: RolesApiDeleteRoleRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return RolesApiFp(this.configuration)
            .deleteRole(requestParameters.roleId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get all roles
     * @param {RolesApiGetAllRolesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public getAllRoles(
        requestParameters: RolesApiGetAllRolesRequest = {},
        options?: RawAxiosRequestConfig,
    ) {
        return RolesApiFp(this.configuration)
            .getAllRoles(
                requestParameters.search,
                requestParameters.productId,
                requestParameters.orgUnitId,
                requestParameters.limit,
                requestParameters.offset,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get role permission
     * @param {RolesApiGetPermissionsByRoleIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public getPermissionsByRoleId(
        requestParameters: RolesApiGetPermissionsByRoleIdRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return RolesApiFp(this.configuration)
            .getPermissionsByRoleId(requestParameters.roleId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get a role by ID
     * @param {RolesApiGetRoleByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public getRoleById(
        requestParameters: RolesApiGetRoleByIdRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return RolesApiFp(this.configuration)
            .getRoleById(requestParameters.roleId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get role history
     * @param {RolesApiGetRoleHistoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public getRoleHistory(
        requestParameters: RolesApiGetRoleHistoryRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return RolesApiFp(this.configuration)
            .getRoleHistory(requestParameters.roleId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Update a role by ID
     * @param {RolesApiUpdateRoleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public updateRole(
        requestParameters: RolesApiUpdateRoleRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return RolesApiFp(this.configuration)
            .updateRole(
                requestParameters.roleId,
                requestParameters.roleWithPermissionsPostDTO,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }
}

/**
 * RolesRequestsApi - axios parameter creator
 * @export
 */
export const RolesRequestsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Create a new role request
         * @param {RoleRequestPostDTO} roleRequestPostDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRoleRequest: async (
            roleRequestPostDTO: RoleRequestPostDTO,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'roleRequestPostDTO' is not null or undefined
            assertParamExists('createRoleRequest', 'roleRequestPostDTO', roleRequestPostDTO);
            const localVarPath = `/api/v1/roles-requests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = serializeDataIfNeeded(
                roleRequestPostDTO,
                localVarRequestOptions,
                configuration,
            );

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all roles requests
         * @param {string} [ownerId]
         * @param {string} [status]
         * @param {string} [accountId]
         * @param {string} [roleId]
         * @param {number} [limit]
         * @param {number} [offset]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRolesRequests: async (
            ownerId?: string,
            status?: string,
            accountId?: string,
            roleId?: string,
            limit?: number,
            offset?: number,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/roles-requests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            if (ownerId !== undefined) {
                localVarQueryParameter['ownerId'] = ownerId;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (roleId !== undefined) {
                localVarQueryParameter['roleId'] = roleId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a role Request by ID
         * @param {string} roleRequestId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoleRequestById: async (
            roleRequestId: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'roleRequestId' is not null or undefined
            assertParamExists('getRoleRequestById', 'roleRequestId', roleRequestId);
            const localVarPath = `/api/v1/roles-requests/{roleRequestId}`.replace(
                `{${'roleRequestId'}}`,
                encodeURIComponent(String(roleRequestId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update a role request by ID
         * @param {string} roleRequestId
         * @param {RoleRequestPostDTO} roleRequestPostDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRoleRequest: async (
            roleRequestId: string,
            roleRequestPostDTO: RoleRequestPostDTO,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'roleRequestId' is not null or undefined
            assertParamExists('updateRoleRequest', 'roleRequestId', roleRequestId);
            // verify required parameter 'roleRequestPostDTO' is not null or undefined
            assertParamExists('updateRoleRequest', 'roleRequestPostDTO', roleRequestPostDTO);
            const localVarPath = `/api/v1/roles-requests/{roleRequestId}`.replace(
                `{${'roleRequestId'}}`,
                encodeURIComponent(String(roleRequestId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = serializeDataIfNeeded(
                roleRequestPostDTO,
                localVarRequestOptions,
                configuration,
            );

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update a role request status by ID
         * @param {string} roleRequestId
         * @param {string} newStatus
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRoleRequestStatus: async (
            roleRequestId: string,
            newStatus: string,
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'roleRequestId' is not null or undefined
            assertParamExists('updateRoleRequestStatus', 'roleRequestId', roleRequestId);
            // verify required parameter 'newStatus' is not null or undefined
            assertParamExists('updateRoleRequestStatus', 'newStatus', newStatus);
            const localVarPath = `/api/v1/roles-requests/{roleRequestId}`.replace(
                `{${'roleRequestId'}}`,
                encodeURIComponent(String(roleRequestId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            if (newStatus !== undefined) {
                localVarQueryParameter['newStatus'] = newStatus;
            }

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * RolesRequestsApi - functional programming interface
 * @export
 */
export const RolesRequestsApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = RolesRequestsApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Create a new role request
         * @param {RoleRequestPostDTO} roleRequestPostDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRoleRequest(
            roleRequestPostDTO: RoleRequestPostDTO,
            options?: RawAxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleRequestDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRoleRequest(
                roleRequestPostDTO,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['RolesRequestsApi.createRoleRequest']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get all roles requests
         * @param {string} [ownerId]
         * @param {string} [status]
         * @param {string} [accountId]
         * @param {string} [roleId]
         * @param {number} [limit]
         * @param {number} [offset]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllRolesRequests(
            ownerId?: string,
            status?: string,
            accountId?: string,
            roleId?: string,
            limit?: number,
            offset?: number,
            options?: RawAxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedRoleRequestResponse>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllRolesRequests(
                ownerId,
                status,
                accountId,
                roleId,
                limit,
                offset,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['RolesRequestsApi.getAllRolesRequests']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get a role Request by ID
         * @param {string} roleRequestId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoleRequestById(
            roleRequestId: string,
            options?: RawAxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleRequestDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoleRequestById(
                roleRequestId,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['RolesRequestsApi.getRoleRequestById']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Update a role request by ID
         * @param {string} roleRequestId
         * @param {RoleRequestPostDTO} roleRequestPostDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRoleRequest(
            roleRequestId: string,
            roleRequestPostDTO: RoleRequestPostDTO,
            options?: RawAxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleRequestDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRoleRequest(
                roleRequestId,
                roleRequestPostDTO,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['RolesRequestsApi.updateRoleRequest']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Update a role request status by ID
         * @param {string} roleRequestId
         * @param {string} newStatus
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRoleRequestStatus(
            roleRequestId: string,
            newStatus: string,
            options?: RawAxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleRequestDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRoleRequestStatus(
                roleRequestId,
                newStatus,
                options,
            );
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['RolesRequestsApi.updateRoleRequestStatus']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
    };
};

/**
 * RolesRequestsApi - factory interface
 * @export
 */
export const RolesRequestsApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = RolesRequestsApiFp(configuration);
    return {
        /**
         *
         * @summary Create a new role request
         * @param {RolesRequestsApiCreateRoleRequestRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRoleRequest(
            requestParameters: RolesRequestsApiCreateRoleRequestRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<RoleRequestDTO> {
            return localVarFp
                .createRoleRequest(requestParameters.roleRequestPostDTO, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get all roles requests
         * @param {RolesRequestsApiGetAllRolesRequestsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRolesRequests(
            requestParameters: RolesRequestsApiGetAllRolesRequestsRequest = {},
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<PaginatedRoleRequestResponse> {
            return localVarFp
                .getAllRolesRequests(
                    requestParameters.ownerId,
                    requestParameters.status,
                    requestParameters.accountId,
                    requestParameters.roleId,
                    requestParameters.limit,
                    requestParameters.offset,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a role Request by ID
         * @param {RolesRequestsApiGetRoleRequestByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoleRequestById(
            requestParameters: RolesRequestsApiGetRoleRequestByIdRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<RoleRequestDTO> {
            return localVarFp
                .getRoleRequestById(requestParameters.roleRequestId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update a role request by ID
         * @param {RolesRequestsApiUpdateRoleRequestRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRoleRequest(
            requestParameters: RolesRequestsApiUpdateRoleRequestRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<RoleRequestDTO> {
            return localVarFp
                .updateRoleRequest(
                    requestParameters.roleRequestId,
                    requestParameters.roleRequestPostDTO,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update a role request status by ID
         * @param {RolesRequestsApiUpdateRoleRequestStatusRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRoleRequestStatus(
            requestParameters: RolesRequestsApiUpdateRoleRequestStatusRequest,
            options?: RawAxiosRequestConfig,
        ): AxiosPromise<RoleRequestDTO> {
            return localVarFp
                .updateRoleRequestStatus(
                    requestParameters.roleRequestId,
                    requestParameters.newStatus,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createRoleRequest operation in RolesRequestsApi.
 * @export
 * @interface RolesRequestsApiCreateRoleRequestRequest
 */
export interface RolesRequestsApiCreateRoleRequestRequest {
    /**
     *
     * @type {RoleRequestPostDTO}
     * @memberof RolesRequestsApiCreateRoleRequest
     */
    readonly roleRequestPostDTO: RoleRequestPostDTO;
}

/**
 * Request parameters for getAllRolesRequests operation in RolesRequestsApi.
 * @export
 * @interface RolesRequestsApiGetAllRolesRequestsRequest
 */
export interface RolesRequestsApiGetAllRolesRequestsRequest {
    /**
     *
     * @type {string}
     * @memberof RolesRequestsApiGetAllRolesRequests
     */
    readonly ownerId?: string;

    /**
     *
     * @type {string}
     * @memberof RolesRequestsApiGetAllRolesRequests
     */
    readonly status?: string;

    /**
     *
     * @type {string}
     * @memberof RolesRequestsApiGetAllRolesRequests
     */
    readonly accountId?: string;

    /**
     *
     * @type {string}
     * @memberof RolesRequestsApiGetAllRolesRequests
     */
    readonly roleId?: string;

    /**
     *
     * @type {number}
     * @memberof RolesRequestsApiGetAllRolesRequests
     */
    readonly limit?: number;

    /**
     *
     * @type {number}
     * @memberof RolesRequestsApiGetAllRolesRequests
     */
    readonly offset?: number;
}

/**
 * Request parameters for getRoleRequestById operation in RolesRequestsApi.
 * @export
 * @interface RolesRequestsApiGetRoleRequestByIdRequest
 */
export interface RolesRequestsApiGetRoleRequestByIdRequest {
    /**
     *
     * @type {string}
     * @memberof RolesRequestsApiGetRoleRequestById
     */
    readonly roleRequestId: string;
}

/**
 * Request parameters for updateRoleRequest operation in RolesRequestsApi.
 * @export
 * @interface RolesRequestsApiUpdateRoleRequestRequest
 */
export interface RolesRequestsApiUpdateRoleRequestRequest {
    /**
     *
     * @type {string}
     * @memberof RolesRequestsApiUpdateRoleRequest
     */
    readonly roleRequestId: string;

    /**
     *
     * @type {RoleRequestPostDTO}
     * @memberof RolesRequestsApiUpdateRoleRequest
     */
    readonly roleRequestPostDTO: RoleRequestPostDTO;
}

/**
 * Request parameters for updateRoleRequestStatus operation in RolesRequestsApi.
 * @export
 * @interface RolesRequestsApiUpdateRoleRequestStatusRequest
 */
export interface RolesRequestsApiUpdateRoleRequestStatusRequest {
    /**
     *
     * @type {string}
     * @memberof RolesRequestsApiUpdateRoleRequestStatus
     */
    readonly roleRequestId: string;

    /**
     *
     * @type {string}
     * @memberof RolesRequestsApiUpdateRoleRequestStatus
     */
    readonly newStatus: string;
}

/**
 * RolesRequestsApi - object-oriented interface
 * @export
 * @class RolesRequestsApi
 * @extends {BaseAPI}
 */
export class RolesRequestsApi extends BaseAPI {
    /**
     *
     * @summary Create a new role request
     * @param {RolesRequestsApiCreateRoleRequestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesRequestsApi
     */
    public createRoleRequest(
        requestParameters: RolesRequestsApiCreateRoleRequestRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return RolesRequestsApiFp(this.configuration)
            .createRoleRequest(requestParameters.roleRequestPostDTO, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get all roles requests
     * @param {RolesRequestsApiGetAllRolesRequestsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesRequestsApi
     */
    public getAllRolesRequests(
        requestParameters: RolesRequestsApiGetAllRolesRequestsRequest = {},
        options?: RawAxiosRequestConfig,
    ) {
        return RolesRequestsApiFp(this.configuration)
            .getAllRolesRequests(
                requestParameters.ownerId,
                requestParameters.status,
                requestParameters.accountId,
                requestParameters.roleId,
                requestParameters.limit,
                requestParameters.offset,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get a role Request by ID
     * @param {RolesRequestsApiGetRoleRequestByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesRequestsApi
     */
    public getRoleRequestById(
        requestParameters: RolesRequestsApiGetRoleRequestByIdRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return RolesRequestsApiFp(this.configuration)
            .getRoleRequestById(requestParameters.roleRequestId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Update a role request by ID
     * @param {RolesRequestsApiUpdateRoleRequestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesRequestsApi
     */
    public updateRoleRequest(
        requestParameters: RolesRequestsApiUpdateRoleRequestRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return RolesRequestsApiFp(this.configuration)
            .updateRoleRequest(
                requestParameters.roleRequestId,
                requestParameters.roleRequestPostDTO,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Update a role request status by ID
     * @param {RolesRequestsApiUpdateRoleRequestStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesRequestsApi
     */
    public updateRoleRequestStatus(
        requestParameters: RolesRequestsApiUpdateRoleRequestStatusRequest,
        options?: RawAxiosRequestConfig,
    ) {
        return RolesRequestsApiFp(this.configuration)
            .updateRoleRequestStatus(
                requestParameters.roleRequestId,
                requestParameters.newStatus,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }
}

/**
 * V1PingControllerApi - axios parameter creator
 * @export
 */
export const V1PingControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ClustersCreateCluster: async (
            options: RawAxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            const localVarPath = `/ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions =
                baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * V1PingControllerApi - functional programming interface
 * @export
 */
export const V1PingControllerApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = V1PingControllerApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ClustersCreateCluster(
            options?: RawAxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs =
                await localVarAxiosParamCreator.v1ClustersCreateCluster(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath =
                operationServerMap['V1PingControllerApi.v1ClustersCreateCluster']?.[
                    localVarOperationServerIndex
                ]?.url;
            return (axios, basePath) =>
                createRequestFunction(
                    localVarAxiosArgs,
                    globalAxios,
                    BASE_PATH,
                    configuration,
                )(axios, localVarOperationServerBasePath || basePath);
        },
    };
};

/**
 * V1PingControllerApi - factory interface
 * @export
 */
export const V1PingControllerApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = V1PingControllerApiFp(configuration);
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ClustersCreateCluster(options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp
                .v1ClustersCreateCluster(options)
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * V1PingControllerApi - object-oriented interface
 * @export
 * @class V1PingControllerApi
 * @extends {BaseAPI}
 */
export class V1PingControllerApi extends BaseAPI {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1PingControllerApi
     */
    public v1ClustersCreateCluster(options?: RawAxiosRequestConfig) {
        return V1PingControllerApiFp(this.configuration)
            .v1ClustersCreateCluster(options)
            .then((request) => request(this.axios, this.basePath));
    }
}
